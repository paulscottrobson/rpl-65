TOK_NOT_CONTROL = $06
TOK_STRUCT_INC = $06
TOK_STRUCT_DEC = $09
TOK_STRUCT_NEUTRAL = $0c

KWD_SYS_EOL                    = $0000 ; %eol
KWD_SYS_CONST                  = $0001 ; %const
KWD_SYS_CALL                   = $0002 ; %call
KWD_SYS_COMMENT                = $0003 ; %comment
KWD_SYS_QSTRING                = $0004 ; %qstring
KWD_SYS_DEFINE                 = $0005 ; %define
KWD_IF                         = $0006 ; if
KWD_REPEAT                     = $0007 ; repeat
KWD_FOR                        = $0008 ; for
KWD_ENDIF                      = $0009 ; endif
KWD_UNTIL                      = $000a ; until
KWD_NEXT                       = $000b ; next
KWD_STAR                       = $000c ; *
KWD_SLASH                      = $000d ; /
KWD_MOD                        = $000e ; mod
KWD_PLUS                       = $000f ; +
KWD_MINUS                      = $0010 ; -
KWD_AND                        = $0011 ; and
KWD_OR                         = $0012 ; or
KWD_XOR                        = $0013 ; xor
KWD_SHL                        = $0014 ; shl
KWD_SHR                        = $0015 ; shr
KWD_EQUAL                      = $0016 ; =
KWD_LESSGREATER                = $0017 ; <>
KWD_GREATER                    = $0018 ; >
KWD_LESS                       = $0019 ; <
KWD_GREATEREQUAL               = $001a ; >=
KWD_LESSEQUAL                  = $001b ; <=
KWD_CAT                        = $001c ; c@
KWD_CPLING                     = $001d ; c!
KWD_AT                         = $001e ; @
KWD_PLING                      = $001f ; !
KWD_DPLING                     = $0020 ; d!
KWD_ALLOC                      = $0021 ; alloc
KWD_HAT                        = $0022 ; ^
KWD_LSQPAREN                   = $0023 ; [
KWD_RSQPAREN                   = $0024 ; ]
KWD_SYS                        = $0025 ; sys
KWD_QMARK                      = $0026 ; ?
KWD_ABS                        = $0027 ; abs
KWD_NEGATE                     = $0028 ; negate
KWD_NOT                        = $0029 ; not
KWD_PLUSPLUS                   = $002a ; ++
KWD_MINUSMINUS                 = $002b ; --
KWD_BSWAP                      = $002c ; bswap
KWD_LESSLESS                   = $002d ; <<
KWD_GREATERGREATER             = $002e ; >>
KWD_SGN                        = $002f ; sgn
KWD_RND                        = $0030 ; rnd
KWD_CLR                        = $0031 ; clr
KWD_DROP                       = $0032 ; drop
KWD_DUP                        = $0033 ; dup
KWD_NIP                        = $0034 ; nip
KWD_OVER                       = $0035 ; over
KWD_SWAP                       = $0036 ; swap
KWD_ELSE                       = $0037 ; else
KWD_INDEX                      = $0038 ; index
KWD_SEMICOLON                  = $0039 ; ;
KWD_ASSERT                     = $003a ; assert
KWD_LIST                       = $003b ; list
KWD_NEW                        = $003c ; new
KWD_OLD                        = $003d ; old
KWD_STOP                       = $003e ; stop
KWD_RUN                        = $003f ; run
KWD_END                        = $0040 ; end
KWD_SAVE                       = $0041 ; save
KWD_LOAD                       = $0042 ; load

KeywordText:
	.text $01,$ff                          ; $0000 %eol
	.text $01,$ff                          ; $0001 %const
	.text $01,$ff                          ; $0002 %call
	.text $01,$ff                          ; $0003 %comment
	.text $01,$ff                          ; $0004 %qstring
	.text $01,$ff                          ; $0005 %define
	.text $02,$49,$c6                      ; $0006 if
	.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
	.text $03,$46,$4f,$d2                  ; $0008 for
	.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
	.text $05,$55,$4e,$54,$49,$cc          ; $000a until
	.text $04,$4e,$45,$58,$d4              ; $000b next
	.text $01,$aa                          ; $000c *
	.text $01,$af                          ; $000d /
	.text $03,$4d,$4f,$c4                  ; $000e mod
	.text $01,$ab                          ; $000f +
	.text $01,$ad                          ; $0010 -
	.text $03,$41,$4e,$c4                  ; $0011 and
	.text $02,$4f,$d2                      ; $0012 or
	.text $03,$58,$4f,$d2                  ; $0013 xor
	.text $03,$53,$48,$cc                  ; $0014 shl
	.text $03,$53,$48,$d2                  ; $0015 shr
	.text $01,$bd                          ; $0016 =
	.text $02,$3c,$be                      ; $0017 <>
	.text $01,$be                          ; $0018 >
	.text $01,$bc                          ; $0019 <
	.text $02,$3e,$bd                      ; $001a >=
	.text $02,$3c,$bd                      ; $001b <=
	.text $02,$43,$c0                      ; $001c c@
	.text $02,$43,$a1                      ; $001d c!
	.text $01,$c0                          ; $001e @
	.text $01,$a1                          ; $001f !
	.text $02,$44,$a1                      ; $0020 d!
	.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
	.text $01,$de                          ; $0022 ^
	.text $01,$db                          ; $0023 [
	.text $01,$dd                          ; $0024 ]
	.text $03,$53,$59,$d3                  ; $0025 sys
	.text $01,$bf                          ; $0026 ?
	.text $03,$41,$42,$d3                  ; $0027 abs
	.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
	.text $03,$4e,$4f,$d4                  ; $0029 not
	.text $02,$2b,$ab                      ; $002a ++
	.text $02,$2d,$ad                      ; $002b --
	.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
	.text $02,$3c,$bc                      ; $002d <<
	.text $02,$3e,$be                      ; $002e >>
	.text $03,$53,$47,$ce                  ; $002f sgn
	.text $03,$52,$4e,$c4                  ; $0030 rnd
	.text $03,$43,$4c,$d2                  ; $0031 clr
	.text $04,$44,$52,$4f,$d0              ; $0032 drop
	.text $03,$44,$55,$d0                  ; $0033 dup
	.text $03,$4e,$49,$d0                  ; $0034 nip
	.text $04,$4f,$56,$45,$d2              ; $0035 over
	.text $04,$53,$57,$41,$d0              ; $0036 swap
	.text $04,$45,$4c,$53,$c5              ; $0037 else
	.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
	.text $01,$bb                          ; $0039 ;
	.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
	.text $04,$4c,$49,$53,$d4              ; $003b list
	.text $03,$4e,$45,$d7                  ; $003c new
	.text $03,$4f,$4c,$c4                  ; $003d old
	.text $04,$53,$54,$4f,$d0              ; $003e stop
	.text $03,$52,$55,$ce                  ; $003f run
	.text $03,$45,$4e,$c4                  ; $0040 end
	.text $04,$53,$41,$56,$c5              ; $0041 save
	.text $04,$4c,$4f,$41,$c4              ; $0042 load
	.byte 0

	.align 2
DispatchHandler:
	.word ExecuteNextLine          ; $0000 %eol
	.word LongConstant             ; $0001 %const
	.word Command_Call             ; $0002 %call
	.word ExecuteComment           ; $0003 %comment
	.word StringConstant           ; $0004 %qstring
	.word SyntaxError              ; $0005 %define
	.word Structure_If             ; $0006 if
	.word Struct_Repeat            ; $0007 repeat
	.word Struct_For               ; $0008 for
	.word Structure_Endif          ; $0009 endif
	.word Struct_Until             ; $000a until
	.word Struct_Next              ; $000b next
	.word MulInteger16             ; $000c *
	.word DivInteger16             ; $000d /
	.word ModInteger16             ; $000e mod
	.word Stack_Add                ; $000f +
	.word Stack_Sub                ; $0010 -
	.word Stack_And                ; $0011 and
	.word Stack_Or                 ; $0012 or
	.word Stack_Xor                ; $0013 xor
	.word Stack_Shl                ; $0014 shl
	.word Stack_Shr                ; $0015 shr
	.word Comp_Equal               ; $0016 =
	.word Comp_NotEqual            ; $0017 <>
	.word Comp_Greater             ; $0018 >
	.word Comp_Less                ; $0019 <
	.word Comp_GreaterEqual        ; $001a >=
	.word Comp_LessEqual           ; $001b <=
	.word Mem_Peek                 ; $001c c@
	.word Mem_Poke                 ; $001d c!
	.word Mem_WPeek                ; $001e @
	.word Mem_WPoke                ; $001f !
	.word Mem_DWPoke               ; $0020 d!
	.word Mem_Alloc                ; $0021 alloc
	.word Command_Store            ; $0022 ^
	.word SyntaxError              ; $0023 [
	.word SyntaxError              ; $0024 ]
	.word Command_Sys              ; $0025 sys
	.word Command_DumpStack        ; $0026 ?
	.word Unary_Absolute           ; $0027 abs
	.word Unary_Negate             ; $0028 negate
	.word Unary_Not                ; $0029 not
	.word Unary_Increment          ; $002a ++
	.word Unary_Decrement          ; $002b --
	.word Unary_BSwap              ; $002c bswap
	.word Unary_Shl                ; $002d <<
	.word Unary_Shr                ; $002e >>
	.word Unary_Sgn                ; $002f sgn
	.word Random_Handler           ; $0030 rnd
	.word Stack_Empty              ; $0031 clr
	.word Stack_Drop               ; $0032 drop
	.word Stack_Dup                ; $0033 dup
	.word Stack_Nip                ; $0034 nip
	.word Stack_Over               ; $0035 over
	.word Stack_Swap               ; $0036 swap
	.word Structure_Else           ; $0037 else
	.word Struct_Index             ; $0038 index
	.word Command_Return           ; $0039 ;
	.word Command_Assert           ; $003a assert
	.word Cmd_List                 ; $003b list
	.word Command_New              ; $003c new
	.word Command_Old              ; $003d old
	.word Command_Stop             ; $003e stop
	.word ExecuteProgram           ; $003f run
	.word Command_End              ; $0040 end
	.word SyntaxError              ; $0041 save
	.word SyntaxError              ; $0042 load

