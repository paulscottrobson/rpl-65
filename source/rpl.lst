
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Sat Nov 16 12:10:55 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer (must be on a page boundary)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					zTemp4:			.word ?
>000c					zTemp5:			.word ?
>000e					iStack:			.word ?						; stack pointer
>0010					signCount:		.byte ? 					; divide sign count.
>0011					allocPtr:		.word ? 					; memory allocation pointer (down)
>0013					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0015					randomSeed:		.word ? 					; random number seed
>0017					prefixCharacter:.byte ?						; char to print before listed element.
>0018					breakCount:		.byte ? 					; counter avoids repeated break checks
>0019					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	13 e8 03 03 0d 54 48 45			.byte	$13,$e8,$03,$03,$0d,$54,$48,$45,$20,$42,$41,$4c,$4c,$20,$44,$45,$4d,$4f,$00,$07,$f2,$03,$02,$ec,$04,$00,$10,$fc,$03,$01,$00,$04,$21,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$4c,$04,$02,$56,$04,$0b,$00,$05,$24,$04,$07,$00,$12,$2e,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$4c,$04,$02,$9c,$04,$0b,$00,$06,$38,$04,$80,$0a,$00,$05,$42,$04,$40,$00,$23,$4c,$04,$05,$0b,$c2,$c1,$cc,$cc,$db,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$56,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$60,$04,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$74,$04,$39,$00,$1c,$6a,$04,$05,$0b,$d2,$c1,$ce,$c4,$cf,$cd,$db,$d3,$c9,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$74,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$7e,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$88,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$92,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$9c,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$a6,$04,$a0,$02,$74,$04,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ba,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ce,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$d8,$04,$01,$51,$00,$02,$74,$04,$00,$05,$e2,$04,$39,$00,$15,$ec,$04,$05,$05,$c3,$cc,$c5,$c1,$f2,$80,$01,$20,$9f,$1f,$90,$01,$22,$9f,$1d,$00,$0a,$f6,$04,$01,$80,$00,$bc,$0c,$08,$00,$0e,$00,$05,$a0,$01,$23,$9f,$1d,$81,$01,$23,$9f,$1d,$00,$06,$0a,$05,$0b,$39,$00
>1008	20 42 41 4c 4c 20 44 45 4d 4f 00 07 f2 03 02 ec
>1018	04 00 10 fc 03 01 00 04 21 22 c2 c1 cc cc cd c5
>1028	ed 00 0b 06 04 a0 22 c3 cf d5 ce f4 00 0d 10 04
>1038	01 8e 00 22 e1 01 d2 ff 25 00 12 1a 04 c3 cf d5
>1048	ce f4 08 38 02 4c 04 02 56 04 0b 00 05 24 04 07
>1058	00 12 2e 04 c3 cf d5 ce f4 08 38 02 4c 04 02 9c
>1068	04 0b 00 06 38 04 80 0a 00 05 42 04 40 00 23 4c
>1078	04 05 0b c2 c1 cc cc db d3 c5 cc c5 c3 f4 2d 2d
>1088	2d 2d c2 c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 39
>1098	00 29 56 04 05 09 c2 c1 cc cc db c9 ce c9 f4 30
>10a8	27 01 50 00 0e 22 c2 c1 cc ec 23 80 24 30 27 bc
>10b8	0e 22 c2 c1 cc ec 23 81 24 00 2d 60 04 02 6a 04
>10c8	22 c2 c1 cc ec 23 82 24 02 6a 04 22 c2 c1 cc ec
>10d8	23 83 24 30 87 11 2a 22 c2 c1 cc ec 23 84 24 01
>10e8	51 00 02 74 04 39 00 1c 6a 04 05 0b d2 c1 ce c4
>10f8	cf cd db d3 c9 c7 ee 30 81 11 06 81 37 01 ff ff
>1108	09 39 00 0f 74 04 05 09 c2 c1 cc cc db c4 d2 c1
>1118	f7 00 10 7e 04 c2 c1 cc ec 23 80 24 2d 01 20 9f
>1128	1d 00 0f 88 04 c2 c1 cc ec 23 81 24 01 21 9f 1d
>1138	00 19 92 04 90 01 22 9f 1d 01 23 9f 1d c2 c1 cc
>1148	ec 23 84 24 01 23 9f 1d 39 00 0f 9c 04 05 09 c2
>1158	c1 cc cc db cd cf d6 e5 00 08 a6 04 a0 02 74 04
>1168	00 1c b0 04 c2 c1 cc ec 23 80 24 c2 c1 cc ec 23
>1178	82 24 0f 33 22 c2 c1 cc ec 23 80 24 00 1f ba 04
>1188	33 01 50 00 1a 36 80 19 12 06 c2 c1 cc ec 23 82
>1198	24 28 22 c2 c1 cc ec 23 82 24 09 00 1c c4 04 c2
>11a8	c1 cc ec 23 81 24 c2 c1 cc ec 23 83 24 0f 33 22
>11b8	c2 c1 cc ec 23 81 24 00 1d ce 04 33 bc 1a 36 80
>11c8	19 12 06 c2 c1 cc ec 23 83 24 28 22 c2 c1 cc ec
>11d8	23 83 24 09 00 0a d8 04 01 51 00 02 74 04 00 05
>11e8	e2 04 39 00 15 ec 04 05 05 c3 cc c5 c1 f2 80 01
>11f8	20 9f 1f 90 01 22 9f 1d 00 0a f6 04 01 80 00 bc
>1208	0c 08 00 0e 00 05 a0 01 23 9f 1d 81 01 23 9f 1d
>1218	00 06 0a 05 0b 39 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 31 a3	jsr $a331			jsr 	ExternInitialise			; set up external stuff.
.a006	a2 63		ldx #$63			ldx 	#BootPrompt & $FF 			; print start up.
.a008	a0 a0		ldy #$a0			ldy 	#BootPrompt >> 8
.a00a	20 53 a2	jsr $a253			jsr 	PrintStringXY
.a00d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.a00f	a0 8f		ldy #$8f			ldy 	#(HighMemory-ProgramStart) >> 8
.a011	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.a014	a2 80		ldx #$80			ldx 	#BootPrompt2 & $FF
.a016	a0 a0		ldy #$a0			ldy 	#BootPrompt2 >> 8
.a018	20 53 a2	jsr $a253			jsr 	PrintStringXY
.a01b					WarmStart:
.a01b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a01d	9a		txs				txs
.a01e	20 86 a3	jsr $a386			jsr 	ExternInput					; input a line.
.a021	ad 00 08	lda $0800			lda 	InputBuffer 				; get the first character.
.a024	48		pha				pha
.a025	20 a8 a7	jsr $a7a8			jsr 	TokeniseInputBuffer 		; tokenise it
.a028	68		pla				pla
.a029	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.a02b	f0 0d		beq $a03a			beq 	ExecuteLine
.a02d	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.a030	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.a032	f0 0d		beq $a041			beq 	LineNumber
.a034	29 c0		and #$c0			and 	#$C0
.a036	c9 80		cmp #$80			cmp 	#$80
.a038	f0 07		beq $a041			beq 	LineNumber
.a03a					ExecuteLine:
.a03a	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.a03c	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.a03e	4c 72 a2	jmp $a272			jmp 	ExecuteFromXY
.a041					LineNumber:
.a041	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.a044	a2 00		ldx #$00			ldx 	#0
.a046	a0 04		ldy #$04			ldy 	#4
.a048	38		sec				sec
.a049	e9 80		sbc #$80			sbc 	#$80
.a04b	c9 40		cmp #$40			cmp 	#$40
.a04d	90 08		bcc $a057			bcc 	_HaveLineNumber
.a04f	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.a052	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.a055	a0 06		ldy #$06			ldy 	#6
.a057					_HaveLineNumber:
.a057	48		pha				pha 								; a fudge. Because you use
.a058	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.a05b	c9 3b		cmp #$3b			cmp 	#KWD_LIST 					; this to be executed and not
.a05d	f0 db		beq $a03a			beq 	ExecuteLine 				; to be code.
.a05f	68		pla				pla
.a060	4c 7b a4	jmp $a47b			jmp 	EditProgram
.a063					BootPrompt:
>a063	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (16-NOV-19) ***",13,13
>a06b	36 35 20 28 31 36 2d 4e 4f 56 2d 31 39 29 20 2a
>a07b	2a 2a 0d 0d
>a07f	00						.byte 	0
.a080					BootPrompt2:
>a080	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>a088	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a094					KeywordText:
>a094	01 ff					.text $01,$ff                          ; $0000 %eol
>a096	01 ff					.text $01,$ff                          ; $0001 %const
>a098	01 ff					.text $01,$ff                          ; $0002 %call
>a09a	01 ff					.text $01,$ff                          ; $0003 %comment
>a09c	01 ff					.text $01,$ff                          ; $0004 %qstring
>a09e	01 ff					.text $01,$ff                          ; $0005 %define
>a0a0	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a0a3	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a0aa	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a0ae	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a0b4	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a0ba	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a0bf	01 aa					.text $01,$aa                          ; $000c *
>a0c1	01 af					.text $01,$af                          ; $000d /
>a0c3	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a0c7	01 ab					.text $01,$ab                          ; $000f +
>a0c9	01 ad					.text $01,$ad                          ; $0010 -
>a0cb	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a0cf	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a0d2	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a0d6	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a0da	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a0de	01 bd					.text $01,$bd                          ; $0016 =
>a0e0	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a0e3	01 be					.text $01,$be                          ; $0018 >
>a0e5	01 bc					.text $01,$bc                          ; $0019 <
>a0e7	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a0ea	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a0ed	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a0f0	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a0f3	01 c0					.text $01,$c0                          ; $001e @
>a0f5	01 a1					.text $01,$a1                          ; $001f !
>a0f7	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a0fa	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a100	01 de					.text $01,$de                          ; $0022 ^
>a102	01 db					.text $01,$db                          ; $0023 [
>a104	01 dd					.text $01,$dd                          ; $0024 ]
>a106	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a10a	01 bf					.text $01,$bf                          ; $0026 ?
>a10c	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a110	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a117	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a11b	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a11e	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a121	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a127	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a12a	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a12d	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a131	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a135	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a139	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a13e	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a142	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a146	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a14b	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a150	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a155	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a15b	01 bb					.text $01,$bb                          ; $0039 ;
>a15d	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a164	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a169	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a16d	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a171	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a176	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a17a	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a17e	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a183	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a188	00					.byte 0
>a189						.align 2
.a18a					DispatchHandler:
>a18a	f2 a2					.word ExecuteNextLine          ; $0000 %eol
>a18c	08 a3					.word LongConstant             ; $0001 %const
>a18e	fc b0					.word Command_Call             ; $0002 %call
>a190	f2 a2					.word ExecuteComment           ; $0003 %comment
>a192	19 a3					.word StringConstant           ; $0004 %qstring
>a194	10 a2					.word SyntaxError              ; $0005 %define
>a196	72 b1					.word Structure_If             ; $0006 if
>a198	26 b2					.word Struct_Repeat            ; $0007 repeat
>a19a	62 b2					.word Struct_For               ; $0008 for
>a19c	af b1					.word Structure_Endif          ; $0009 endif
>a19e	32 b2					.word Struct_Until             ; $000a until
>a1a0	a5 b2					.word Struct_Next              ; $000b next
>a1a2	00 b0					.word MulInteger16             ; $000c *
>a1a4	7e af					.word DivInteger16             ; $000d /
>a1a6	ef af					.word ModInteger16             ; $000e mod
>a1a8	6a ae					.word Stack_Add                ; $000f +
>a1aa	82 ae					.word Stack_Sub                ; $0010 -
>a1ac	9a ae					.word Stack_And                ; $0011 and
>a1ae	c8 ae					.word Stack_Or                 ; $0012 or
>a1b0	b1 ae					.word Stack_Xor                ; $0013 xor
>a1b2	df ae					.word Stack_Shl                ; $0014 shl
>a1b4	e3 ae					.word Stack_Shr                ; $0015 shr
>a1b6	14 af					.word Comp_Equal               ; $0016 =
>a1b8	18 af					.word Comp_NotEqual            ; $0017 <>
>a1ba	61 af					.word Comp_Greater             ; $0018 >
>a1bc	3c af					.word Comp_Less                ; $0019 <
>a1be	40 af					.word Comp_GreaterEqual        ; $001a >=
>a1c0	5d af					.word Comp_LessEqual           ; $001b <=
>a1c2	d4 ab					.word Mem_Peek                 ; $001c c@
>a1c4	06 ac					.word Mem_Poke                 ; $001d c!
>a1c6	ea ab					.word Mem_WPeek                ; $001e @
>a1c8	1b ac					.word Mem_WPoke                ; $001f !
>a1ca	39 ac					.word Mem_DWPoke               ; $0020 d!
>a1cc	53 ac					.word Mem_Alloc                ; $0021 alloc
>a1ce	70 ad					.word Command_Store            ; $0022 ^
>a1d0	10 a2					.word SyntaxError              ; $0023 [
>a1d2	10 a2					.word SyntaxError              ; $0024 ]
>a1d4	01 ae					.word Command_Sys              ; $0025 sys
>a1d6	23 ae					.word Command_DumpStack        ; $0026 ?
>a1d8	3e b0					.word Unary_Absolute           ; $0027 abs
>a1da	47 b0					.word Unary_Negate             ; $0028 negate
>a1dc	5c b0					.word Unary_Not                ; $0029 not
>a1de	70 b0					.word Unary_Increment          ; $002a ++
>a1e0	7c b0					.word Unary_Decrement          ; $002b --
>a1e2	8b b0					.word Unary_BSwap              ; $002c bswap
>a1e4	9d b0					.word Unary_Shl                ; $002d <<
>a1e6	a7 b0					.word Unary_Shr                ; $002e >>
>a1e8	b1 b0					.word Unary_Sgn                ; $002f sgn
>a1ea	d4 b0					.word Random_Handler           ; $0030 rnd
>a1ec	10 ad					.word Stack_Empty              ; $0031 clr
>a1ee	16 ad					.word Stack_Drop               ; $0032 drop
>a1f0	1b ad					.word Stack_Dup                ; $0033 dup
>a1f2	2c ad					.word Stack_Nip                ; $0034 nip
>a1f4	3d ad					.word Stack_Over               ; $0035 over
>a1f6	4e ad					.word Stack_Swap               ; $0036 swap
>a1f8	95 b1					.word Structure_Else           ; $0037 else
>a1fa	86 b2					.word Struct_Index             ; $0038 index
>a1fc	52 b1					.word Command_Return           ; $0039 ;
>a1fe	ea ad					.word Command_Assert           ; $003a assert
>a200	e5 a9					.word Cmd_List                 ; $003b list
>a202	af ad					.word Command_New              ; $003c new
>a204	b6 ad					.word Command_Old              ; $003d old
>a206	e0 ad					.word Command_Stop             ; $003e stop
>a208	6e a2					.word ExecuteProgram           ; $003f run
>a20a	dc ad					.word Command_End              ; $0040 end
>a20c	81 ac					.word System_Save              ; $0041 save
>a20e	9c ac					.word System_Load              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a210					SyntaxError:
.a210	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a213	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a21a					ErrorHandler:
.a21a	fa		plx				plx 								; pull address off.
.a21b	7a		ply				ply
.a21c	e8		inx				inx 								; point to message
.a21d	d0 01		bne $a220			bne 	_EHNoCarry
.a21f	c8		iny				iny
.a220					_EHNoCarry:
.a220	20 53 a2	jsr $a253			jsr 	PrintStringXY 				; print string at XY
.a223	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a225	f0 13		beq $a23a			beq 	_EHNoLine
.a227	a2 42		ldx #$42			ldx 	#_EHMessage & $FF 			; print " AT "
.a229	a0 a2		ldy #$a2			ldy 	#_EHMessage >> 8
.a22b	20 53 a2	jsr $a253			jsr 	PrintStringXY
.a22e	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a230	b1 00		lda ($00),y			lda 	(codePtr),y
.a232	aa		tax				tax
.a233	c8		iny				iny
.a234	b1 00		lda ($00),y			lda 	(codePtr),y
.a236	a8		tay				tay
.a237	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.a23a					_EHNoLine:
.a23a	a9 0d		lda #$0d			lda 	#13
.a23c	20 64 a2	jsr $a264			jsr 	PrintCharacter
.a23f	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a242					_EHMessage:
>a242	20 41 54 20 00					.text	" AT ",0
.a247					PrintIntegerUnsigned:
.a247	20 63 a6	jsr $a663			jsr 	IntToString
.a24a	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a24c	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a24e	20 53 a2	jsr $a253			jsr 	PrintStringXY
.a251	98		tya				tya
.a252	60		rts				rts
.a253					PrintStringXY:
.a253	86 02		stx $02				stx 	zTemp0
.a255	84 03		sty $03				sty 	zTemp0+1
.a257	a0 00		ldy #$00			ldy 	#0
.a259	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a25b	f0 06		beq $a263			beq 	_PSExit
.a25d	20 64 a2	jsr $a264			jsr 	PrintCharacter
.a260	c8		iny				iny
.a261	80 f6		bra $a259			bra 	_PSLoop
.a263	60		rts		_PSExit:rts
.a264					PrintCharacter:
.a264	48		pha				pha
.a265	da		phx				phx
.a266	5a		phy				phy
.a267	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a26a	7a		ply				ply
.a26b	fa		plx				plx
.a26c	68		pla				pla
.a26d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a26e					ExecuteProgram:
.a26e	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.a270	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.a272					ExecuteFromXY:
.a272	20 5a a5	jsr $a55a			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a275	20 96 a5	jsr $a596			jsr 	StackReset 					; reset the CPU stack.
.a278	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a27a	80 0a		bra $a286			bra 	ExecuteLoop
.a27c					ShortConstant:
.a27c	c8		iny				iny 								; skip short const
.a27d	e8		inx				inx 								; space on stack
.a27e	29 3f		and #$3f			and 	#$3F 						; the value
.a280	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a283	9e 00 07	stz $0700,x			stz 	highStack,x
.a286					ExecuteLoop:
.a286	e6 18		inc $18				inc 	breakCount 					; check break sometimes.
.a288	d0 03		bne $a28d			bne 	_EXNoBreak
.a28a	20 45 a3	jsr $a345			jsr 	ExternCheckBreak
.a28d					_EXNoBreak:
.a28d	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a28f	f0 57		beq $a2e8			beq 	_ELUnderflow
.a291	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a293	30 07		bmi $a29c			bmi 	_ELNotToken
.a295	c8		iny				iny 								; skip the token
.a296	da		phx				phx 								; save X on the stack
.a297	0a		asl a				asl 	a 							; double the token, put into X
.a298	aa		tax				tax
.a299	7c 8a a1	jmp ($a18a,x)			jmp 	(DispatchHandler,x)
.a29c					_ELNotToken:
.a29c	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a29e	90 dc		bcc $a27c			bcc 	ShortConstant 				; yes, it's a short constant
.a2a0	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a2a2	90 1e		bcc $a2c2			bcc 	_ELNotFastVariable
.a2a4	c8		iny				iny 								; get the next token.
.a2a5	b1 00		lda ($00),y			lda 	(codePtr),y
.a2a7	88		dey				dey
.a2a8	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a2aa	f0 16		beq $a2c2			beq 	_ELNotFastVariable 			; which we can optimise.
.a2ac	5a		phy				phy 								; save Y
.a2ad	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a2af	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a2b0	a8		tay				tay 								; access via Y
.a2b1	e8		inx				inx 								; make space on the stack.
.a2b2	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a2b5	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2b8	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a2bb	9d 00 07	sta $0700,x			sta 	highStack,x
.a2be	7a		ply				ply 								; restore code pointer
.a2bf	c8		iny				iny 								; skip variable.
.a2c0	80 c4		bra $a286			bra 	ExecuteLoop
.a2c2					_ELNotFastVariable:
.a2c2	18		clc				clc									; do not autocreate if not found.
.a2c3	20 ae a6	jsr $a6ae			jsr 	VariableFind				; find the variable.
.a2c6	90 14		bcc $a2dc			bcc 	_ELUnknown
.a2c8	20 21 a4	jsr $a421			jsr 	IndexCheck
.a2cb	5a		phy				phy 								; copy to stack
.a2cc	e8		inx				inx
.a2cd	b2 02		lda ($02)			lda 	(zTemp0)
.a2cf	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2d2	a0 01		ldy #$01			ldy 	#1
.a2d4	b1 02		lda ($02),y			lda 	(zTemp0),y
.a2d6	9d 00 07	sta $0700,x			sta 	highStack,x
.a2d9	7a		ply				ply
.a2da	80 aa		bra $a286			bra 	ExecuteLoop
.a2dc					_ELUnknown:
.a2dc	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a2df	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a2e7	00
.a2e8					_ELUnderflow:
.a2e8	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a2eb	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a2f2					ExecuteNextLine:
.a2f2					ExecuteComment:
.a2f2	fa		plx				plx
.a2f3	18		clc				clc 								; skip forward
.a2f4	b2 00		lda ($00)			lda 	(codePtr)
.a2f6	18		clc				clc
.a2f7	65 00		adc $00				adc 	codePtr
.a2f9	85 00		sta $00				sta 	codePtr
.a2fb	90 02		bcc $a2ff			bcc 	_ENLNoCarry
.a2fd	e6 01		inc $01				inc 	codePtr+1
.a2ff					_ENLNoCarry:
.a2ff	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a301	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a303	d0 81		bne $a286			bne 	ExecuteLoop
.a305	4c dc ad	jmp $addc			jmp	 	Command_End 				; if zero end program.
.a308					LongConstant:
.a308	fa		plx				plx
.a309	e8		inx				inx 								; space for constant
.a30a	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a30c	9d 00 06	sta $0600,x			sta 	lowStack,x
.a30f	c8		iny				iny
.a310	b1 00		lda ($00),y			lda 	(codePtr),y
.a312	9d 00 07	sta $0700,x			sta 	highStack,x
.a315	c8		iny				iny
.a316	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.a319					StringConstant:
.a319	fa		plx				plx
.a31a	e8		inx				inx
.a31b	18		clc				clc 								; copy Y + codePtr in.
.a31c	98		tya				tya
.a31d	65 00		adc $00				adc 	codePtr
.a31f	9d 00 06	sta $0600,x			sta 	lowStack,x
.a322	a5 01		lda $01				lda 	codePtr+1
.a324	69 00		adc #$00			adc 	#0
.a326	9d 00 07	sta $0700,x			sta 	highStack,x
.a329	98		tya				tya 								; add 1 + length to Y
.a32a	38		sec				sec
.a32b	71 00		adc ($00),y			adc 	(codePtr),y
.a32d	a8		tay				tay
.a32e	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a331					ExternInitialise:
.a331	a9 02		lda #$02			lda 	#$02 						; set colour
.a333	8d 86 02	sta $0286			sta 	646
.a336	a9 0e		lda #$0e			lda 	#14							; lower case
.a338	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a33b	a9 93		lda #$93			lda 	#147 						; clear screen
.a33d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a340	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a342	4c 63 a3	jmp $a363			jmp 	ExternColour
.a345					ExternCheckBreak:
.a345	da		phx				phx 								; make sure we keep XY
.a346	5a		phy				phy
.a347	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a34a	f0 03		beq $a34f			beq		_ECBExit 					; stopped
.a34c	7a		ply				ply 								; restore and exit.
.a34d	fa		plx				plx
.a34e	60		rts				rts
.a34f					_ECBExit:
.a34f	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a352	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a359					ExternPrint:
.a359	48		pha				pha
.a35a	da		phx				phx
.a35b	5a		phy				phy
.a35c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a35f	7a		ply				ply
.a360	fa		plx				plx
.a361	68		pla				pla
.a362	60		rts				rts
.a363					ExternColour:
.a363	48		pha				pha
.a364	da		phx				phx
.a365	48		pha				pha
.a366	29 08		and #$08			and 	#8
.a368	0a		asl a				asl 	a
.a369	0a		asl a				asl 	a
.a36a	0a		asl a				asl 	a
.a36b	0a		asl a				asl 	a
.a36c	49 92		eor #$92			eor 	#$92
.a36e	20 59 a3	jsr $a359			jsr 	ExternPrint
.a371	68		pla				pla
.a372	29 07		and #$07			and 	#7
.a374	aa		tax				tax
.a375	bd 7e a3	lda $a37e,x			lda 	_ECTable,x
.a378	20 59 a3	jsr $a359			jsr 	ExternPrint
.a37b	fa		plx				plx
.a37c	68		pla				pla
.a37d	60		rts				rts
.a37e					_ECTable:
>a37e	90						.byte 	144
>a37f	1c						.byte 	28
>a380	1e						.byte 	30
>a381	9e						.byte 	158
>a382	1f						.byte 	31
>a383	9c						.byte 	156
>a384	9f						.byte 	159
>a385	05						.byte 	5
.a386					ExternInput:
.a386	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a388	85 02		sta $02				sta 	zTemp0
.a38a	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a38c	85 03		sta $03				sta 	zTemp0+1
.a38e	a9 07		lda #$07			lda 	#COL_WHITE
.a390	20 63 a3	jsr $a363			jsr 	ExternColour
.a393	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a396	29 7f		and #$7f			and 	#$7F
.a398	c9 0d		cmp #$0d			cmp 	#13
.a39a	f0 0a		beq $a3a6			beq 	_EIExit
.a39c	92 02		sta ($02)			sta 	(zTemp0)
.a39e	e6 02		inc $02				inc 	zTemp0
.a3a0	d0 f1		bne $a393			bne 	_EIRead
.a3a2	e6 03		inc $03				inc 	zTemp0+1
.a3a4	80 ed		bra $a393			bra 	_EIRead
.a3a6	a9 00		lda #$00	_EIExit:lda 	#0
.a3a8	92 02		sta ($02)			sta 	(zTemp0)
.a3aa	a9 0d		lda #$0d			lda 	#13
.a3ac	20 59 a3	jsr $a359			jsr 	ExternPrint
.a3af	60		rts				rts
.a3b0					ExternSave:
.a3b0	da		phx				phx
.a3b1	5a		phy				phy
.a3b2	85 06		sta $06				sta 	zTemp2 						; save start
.a3b4	84 07		sty $07				sty 	zTemp2+1
.a3b6	20 18 a4	jsr $a418			jsr 	EXGetLength 				; get length of file into A
.a3b9	a6 02		ldx $02				ldx 	zTemp0
.a3bb	a4 03		ldy $03				ldy 	zTemp0+1
.a3bd	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a3c0	a9 01		lda #$01			lda 	#1
.a3c2	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a3c4	a0 00		ldy #$00			ldy 	#0
.a3c6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a3c9	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a3cb	a4 05		ldy $05				ldy 	zTemp1+1
.a3cd	a9 06		lda #$06			lda 	#zTemp2
.a3cf	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a3d2	b0 03		bcs $a3d7			bcs 	_ESSave
.a3d4	7a		ply				ply
.a3d5	fa		plx				plx
.a3d6	60		rts				rts
.a3d7					_ESSave:
.a3d7	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a3da	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a3e2	4c 45 44 00
.a3e6					ExternLoad:
.a3e6	da		phx				phx 								; save XY
.a3e7	5a		phy				phy
.a3e8	48		pha				pha 								; save target
.a3e9	5a		phy				phy
.a3ea	20 18 a4	jsr $a418			jsr 	EXGetLength 				; get length of file into A
.a3ed	a6 02		ldx $02				ldx 	zTemp0
.a3ef	a4 03		ldy $03				ldy 	zTemp0+1
.a3f1	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a3f4	a9 01		lda #$01			lda 	#1
.a3f6	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a3f8	a0 00		ldy #$00			ldy 	#0
.a3fa	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a3fd	7a		ply				ply 								; restore target to YX and call load
.a3fe	fa		plx				plx
.a3ff	a9 00		lda #$00			lda 	#0 							; load command
.a401	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a404	b0 03		bcs $a409			bcs 	_ESLoad
.a406	7a		ply				ply
.a407	fa		plx				plx
.a408	60		rts				rts
.a409					_ESLoad:
.a409	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a40c	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a414	4c 45 44 00
.a418					EXGetLength:
.a418	b2 02		lda ($02)			lda 	(zTemp0) 					; get name length
.a41a	e6 02		inc $02				inc 	zTemp0 						; bump ptr past it
.a41c	d0 02		bne $a420			bne 	_EXGLExit
.a41e	e6 03		inc $03				inc 	zTemp0+1
.a420					_EXGLExit:
.a420	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a421					IndexCheck:
.a421	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a423	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a425	f0 01		beq $a428			beq 	_ICFound
.a427	60		rts				rts
.a428					_ICFound:
.a428	c8		iny				iny 							; get next
.a429	b1 00		lda ($00),y			lda 	(codePtr),y
.a42b	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a42d	f0 2b		beq $a45a			beq 	_ICStackIndex
.a42f	38		sec				sec
.a430	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a432	c9 40		cmp #$40			cmp 	#$40
.a434	b0 1a		bcs $a450			bcs 	_ICError
.a436	0a		asl a				asl 	a 						; double index clear carry
.a437	5a		phy				phy 							; put into Y
.a438	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a43a	48		pha				pha
.a43b	a0 01		ldy #$01			ldy 	#1
.a43d	b1 02		lda ($02),y			lda 	(zTemp0),y
.a43f	69 00		adc #$00			adc 	#0
.a441	85 03		sta $03				sta 	zTemp0+1
.a443	68		pla				pla
.a444	85 02		sta $02				sta 	zTemp0
.a446	7a		ply				ply 							; restore position.
.a447	c8		iny				iny								; skip index
.a448	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a44a	c8		iny				iny
.a44b	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a44d	d0 01		bne $a450			bne 	_ICError
.a44f	60		rts				rts
.a450					_ICError:
.a450	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a453	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a45a					_ICStackIndex:
.a45a	c8		iny				iny 							; skip the ]
.a45b	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a45e	0a		asl a				asl 	a
.a45f	85 04		sta $04				sta 	zTemp1
.a461	bd 00 07	lda $0700,x			lda 	highStack,x
.a464	2a		rol a				rol 	a
.a465	85 05		sta $05				sta 	zTemp1+1
.a467	ca		dex				dex 							; throw TOS.
.a468	5a		phy				phy
.a469	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a46b	b2 02		lda ($02)			lda 	(zTemp0)
.a46d	65 04		adc $04				adc 	zTemp1
.a46f	48		pha				pha
.a470	b1 02		lda ($02),y			lda 	(zTemp0),y
.a472	65 05		adc $05				adc 	zTemp1+1
.a474	85 03		sta $03				sta 	zTemp0+1
.a476	68		pla				pla
.a477	85 02		sta $02				sta 	zTemp0
.a479	7a		ply				ply 							; restore pos and exit.
.a47a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/program.asm

.a47b					EditProgram:
.a47b	86 0d		stx $0d				stx 	zTemp5+1 					; save line number.
.a47d	85 0c		sta $0c				sta 	zTemp5
.a47f	5a		phy				phy 								; save token buffer offset
.a480	20 a3 a4	jsr $a4a3			jsr 	EDFindLine					; find line address -> zTemp1
.a483	90 0f		bcc $a494			bcc 	_EPNotFound 				; if missing don't delete it.
.a485	a5 04		lda $04				lda 	zTemp1 						; save line address
.a487	48		pha				pha
.a488	a5 05		lda $05				lda 	zTemp1+1
.a48a	48		pha				pha
.a48b	20 d8 a4	jsr $a4d8			jsr 	EDDeleteLine 				; delete the line
.a48e	68		pla				pla 								; restore line address
.a48f	85 05		sta $05				sta 	zTemp1+1
.a491	68		pla				pla
.a492	85 04		sta $04				sta 	zTemp1
.a494					_EPNotFound:
.a494	7a		ply				ply 								; get offset
.a495	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; if something after line#
.a498	f0 03		beq $a49d			beq 	_EPNoInsert
.a49a	20 fb a4	jsr $a4fb			jsr 	EDInsertLine 				; insert line back in.
.a49d					_EPNoInsert:
.a49d	20 5a a5	jsr $a55a			jsr 	ResetMemory
.a4a0	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a4a3					EDFindLine:
.a4a3	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a4a5	85 04		sta $04				sta 	zTemp1
.a4a7	a9 10		lda #$10			lda 	#ProgramStart >> 8
.a4a9	85 05		sta $05				sta 	zTemp1+1
.a4ab					_EDFLLoop:
.a4ab	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a4ad	b1 04		lda ($04),y			lda 	(zTemp1),y
.a4af	f0 23		beq $a4d4			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a4b1	c8		iny				iny
.a4b2	38		sec				sec
.a4b3	a5 0c		lda $0c				lda 	zTemp5						; subtract the current from the target
.a4b5	f1 04		sbc ($04),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a4b7	aa		tax				tax	 								; this will return 10.
.a4b8	a5 0d		lda $0d				lda 	zTemp5+1
.a4ba	c8		iny				iny
.a4bb	f1 04		sbc ($04),y			sbc 	(zTemp1),y
.a4bd	90 15		bcc $a4d4			bcc 	_EDFLFail					; if target < current then failed.
.a4bf	d0 04		bne $a4c5			bne 	_EDFLNext 					; if non-zero then goto next
.a4c1	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a4c3	f0 11		beq $a4d6			beq 	_EDFLFound
.a4c5					_EDFLNext:
.a4c5	a0 00		ldy #$00			ldy 	#0 							; get offset
.a4c7	18		clc				clc
.a4c8	b1 04		lda ($04),y			lda 	(zTemp1),y
.a4ca	65 04		adc $04				adc 	zTemp1 						; add to pointer
.a4cc	85 04		sta $04				sta 	zTemp1
.a4ce	90 db		bcc $a4ab			bcc 	_EDFLLoop
.a4d0	e6 05		inc $05				inc 	zTemp1+1 					; carry out.
.a4d2	80 d7		bra $a4ab			bra 	_EDFLLoop
.a4d4					_EDFLFail:
.a4d4	18		clc				clc
.a4d5	60		rts				rts
.a4d6					_EDFLFound:
.a4d6	38		sec				sec
.a4d7	60		rts				rts
.a4d8					EDDeleteLine:
.a4d8	20 78 a5	jsr $a578			jsr 	ResetVarMemory
.a4db	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a4dd	a2 00		ldx #$00			ldx 	#0
.a4df	b1 04		lda ($04),y			lda 	(zTemp1),y
.a4e1	a8		tay				tay 								; put in Y
.a4e2					_EDDelLoop:
.a4e2	b1 04		lda ($04),y			lda 	(zTemp1),y 					; get it
.a4e4	81 04		sta ($04,x)			sta 	(zTemp1,x) 					; write it.
.a4e6	a5 04		lda $04				lda 	zTemp1 						; check if pointer has reached the end of
.a4e8	c5 13		cmp $13				cmp		memVarPtr 					; low memory. We will have copied down an
.a4ea	d0 06		bne $a4f2			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a4ec	a5 05		lda $05				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a4ee	c5 14		cmp $14				cmp 	memVarPtr+1					; doesn't really matter.
.a4f0	f0 08		beq $a4fa			beq		_EDDelExit
.a4f2					_EDDelNext:
.a4f2	e6 04		inc $04				inc 	zTemp1 						; go to next byte.
.a4f4	d0 ec		bne $a4e2			bne 	_EDDelLoop
.a4f6	e6 05		inc $05				inc 	zTemp1+1
.a4f8	80 e8		bra $a4e2			bra 	_EDDelLoop
.a4fa					_EDDelExit:
.a4fa	60		rts				rts
.a4fb					EDInsertLine:
.a4fb	84 02		sty $02				sty 	zTemp0						; zTemp0 = address of code.
.a4fd	a9 0a		lda #$0a			lda 	#TokenBuffer >> 8
.a4ff	85 03		sta $03				sta 	zTemp0+1
.a501	20 78 a5	jsr $a578			jsr 	ResetVarMemory
.a504	a5 13		lda $13				lda 	memVarPtr 					; copy high memory to zTemp3
.a506	85 08		sta $08				sta 	zTemp3
.a508	a5 14		lda $14				lda 	memVarPtr+1
.a50a	85 09		sta $09				sta 	zTemp3+1
.a50c	a5 19		lda $19				lda 	TokenOffset 				; work out the space needed.
.a50e	38		sec				sec
.a50f	e5 02		sbc $02				sbc 	zTemp0
.a511	18		clc				clc
.a512	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a514	48		pha				pha 								; save total size (e.g. offset)
.a515	85 0a		sta $0a				sta 	zTemp4 						; save for copying
.a517	a8		tay				tay 								; in Y
.a518	a2 00		ldx #$00			ldx 	#0
.a51a					_EDInsLoop:
.a51a	a1 08		lda ($08,x)			lda 	(zTemp3,x)					; copy it up
.a51c	91 08		sta ($08),y			sta 	(zTemp3),y
.a51e	a5 08		lda $08				lda 	zTemp3 						; reached the insert point (zTemp1)
.a520	c5 04		cmp $04				cmp 	zTemp1
.a522	d0 06		bne $a52a			bne 	_EDINextShift
.a524	a5 09		lda $09				lda 	zTemp3+1
.a526	c5 05		cmp $05				cmp 	zTemp1+1
.a528	f0 0a		beq $a534			beq 	_EDIShiftOver
.a52a					_EDINextShift:
.a52a	a5 08		lda $08				lda 	zTemp3 					; decrement the copy pointer.
.a52c	d0 02		bne $a530			bne 	_EDINoBorrow
.a52e	c6 09		dec $09				dec 	zTemp3+1
.a530					_EDINoBorrow:
.a530	c6 08		dec $08				dec 	zTemp3
.a532	80 e6		bra $a51a			bra 	_EDInsLoop
.a534					_EDIShiftOver:
.a534	68		pla				pla 								; this is the size + others, e.g. offset
.a535	a0 00		ldy #$00			ldy 	#0
.a537	91 08		sta ($08),y			sta 	(zTemp3),y 					; write that out.
.a539	a5 0c		lda $0c				lda 	zTemp5 						; write Line# out
.a53b	c8		iny				iny
.a53c	91 08		sta ($08),y			sta 	(zTemp3),y
.a53e	a5 0d		lda $0d				lda 	zTemp5+1
.a540	c8		iny				iny
.a541	91 08		sta ($08),y			sta 	(zTemp3),y
.a543	c8		iny				iny 								; where the code goes.
.a544	a2 00		ldx #$00			ldx 	#0 							; comes from
.a546					_EDICopyCode:
.a546	a1 02		lda ($02,x)			lda 	(zTemp0,x)					; read from the current line
.a548	91 08		sta ($08),y			sta 	(zTemp3),y 					; write out
.a54a	c8		iny				iny 								; bump pointers
.a54b	e6 02		inc $02				inc 	zTemp0
.a54d	d0 02		bne $a551			bne 	_EDINoCarry
.a54f	e6 03		inc $03				inc 	zTemp0+1
.a551					_EDINoCarry:
.a551	c6 0a		dec $0a				dec 	zTemp4 						; copy data in
.a553	a5 0a		lda $0a				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.a555	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.a557	d0 ed		bne $a546			bne 	_EDICopyCode
.a559	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a55a					ResetMemory:
.a55a	da		phx				phx									; save run address
.a55b	5a		phy				phy
.a55c	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a55e	85 11		sta $11				sta 	allocPtr
.a560	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a562	85 12		sta $12				sta 	allocPtr+1
.a564	20 78 a5	jsr $a578			jsr 	ResetVarMemory
.a567	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a569					_RMEraseHash:
.a569	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a56c	ca		dex				dex
.a56d	10 fa		bpl $a569			bpl 	_RMEraseHash
.a56f	7a		ply				ply 								; restore and set run address
.a570	fa		plx				plx
.a571	84 01		sty $01				sty 	codePtr+1
.a573	86 00		stx $00				stx 	codePtr
.a575	a0 03		ldy #$03			ldy 	#3
.a577	60		rts				rts
.a578					ResetVarMemory:
.a578	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a57a	85 13		sta $13				sta 	memVarPtr
.a57c	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a57e	85 14		sta $14				sta 	memVarPtr+1
.a580					_RMFindEnd:
.a580	b2 13		lda ($13)			lda 	(memVarPtr)					; offset 0, found end.
.a582	f0 0b		beq $a58f			beq 	_RMFoundEnd 				; advance to next.
.a584	18		clc				clc
.a585	65 13		adc $13				adc 	memVarPtr
.a587	85 13		sta $13				sta 	memVarPtr
.a589	90 f5		bcc $a580			bcc 	_RMFindEnd
.a58b	e6 14		inc $14				inc 	memVarPtr+1
.a58d	80 f1		bra $a580			bra 	_RMFindEnd
.a58f					_RMFoundEnd:
.a58f	e6 13		inc $13				inc 	memVarPtr 					; advance past last offset $00
.a591	d0 02		bne $a595			bne 	_RMNoCarry
.a593	e6 14		inc $14				inc 	memVarPtr+1
.a595					_RMNoCarry:
.a595	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a596					StackReset:
.a596	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a598	85 0e		sta $0e				sta 	iStack
.a59a	a9 09		lda #$09			lda 	#IntStack >> 8
.a59c	85 0f		sta $0f				sta 	iStack+1
.a59e	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a5a0	92 0e		sta ($0e)			sta 	(iStack)
.a5a2	60		rts				rts
.a5a3					StackPushByte:
.a5a3	c6 0e		dec $0e				dec 	iStack
.a5a5	92 0e		sta ($0e)			sta 	(iStack)
.a5a7	f0 01		beq $a5aa			beq 	_SPBUnderflow
.a5a9	60		rts				rts
.a5aa					_SPBUnderflow:
.a5aa	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a5ad	53 54 41 43 4b 00				.text 	"STACK",0
.a5b3					StackPushPosition:
.a5b3	98		tya				tya
.a5b4	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.a5b7	a5 01		lda $01				lda 	codePtr+1
.a5b9	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.a5bc	a5 00		lda $00				lda 	codePtr
.a5be	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.a5c1	60		rts				rts
.a5c2					StackCheckTop:
.a5c2	d2 0e		cmp ($0e)			cmp 	(iStack)
.a5c4	f0 02		beq $a5c8			beq 	_SCTOk
.a5c6	18		clc				clc
.a5c7	60		rts				rts
.a5c8	38		sec		_SCTOk:	sec
.a5c9	60		rts				rts
.a5ca					StackPop:
.a5ca	18		clc				clc
.a5cb	65 0e		adc $0e				adc 	iStack
.a5cd	85 0e		sta $0e				sta 	iStack
.a5cf	60		rts				rts
.a5d0					StackRestorePosition:
.a5d0	b1 0e		lda ($0e),y			lda 	(iStack),y
.a5d2	85 00		sta $00				sta 	codePtr
.a5d4	c8		iny				iny
.a5d5	b1 0e		lda ($0e),y			lda 	(iStack),y
.a5d7	85 01		sta $01				sta 	codePtr+1
.a5d9	c8		iny				iny
.a5da	b1 0e		lda ($0e),y			lda 	(iStack),y
.a5dc	a8		tay				tay
.a5dd	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a5de					StringToInt:
.a5de	86 08		stx $08				stx 	zTemp3 						; save string
.a5e0	84 09		sty $09				sty 	zTemp3+1
.a5e2	64 10		stz $10				stz 	signCount 					; signcount is the number of chars copied.
.a5e4	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a5e6	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a5e8	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a5ea	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a5ec	f0 03		beq $a5f1			beq 	_STIConvert 				; convert from character 1, base 16.
.a5ee	88		dey				dey 								; from character 0
.a5ef	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a5f1					_STIConvert:
.a5f1	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a5f3	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a5f5	f0 5f		beq $a656			beq 	_STIFail 					; if zero, then it has failed anyway.
.a5f7	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a5f9	64 03		stz $03				stz 	zTemp0+1
.a5fb					_STILoop:
.a5fb	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a5fd	c9 30		cmp #$30			cmp 	#"0"
.a5ff	90 55		bcc $a656			bcc 	_STIFail
.a601	c9 3a		cmp #$3a			cmp 	#"9"+1
.a603	90 08		bcc $a60d			bcc 	_STIOkay
.a605	c9 41		cmp #$41			cmp 	#"A"
.a607	90 4d		bcc $a656			bcc 	_STIFail
.a609	c9 47		cmp #$47			cmp 	#"F"+1
.a60b	b0 49		bcs $a656			bcs 	_STIFail
.a60d					_STIOkay:
.a60d	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a60f	85 06		sta $06				sta 	zTemp2
.a611	a5 03		lda $03				lda 	zTemp0+1
.a613	85 07		sta $07				sta 	zTemp2+1
.a615	64 02		stz $02				stz 	zTemp0 						; clear result
.a617	64 03		stz $03				stz 	zTemp0+1
.a619	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a61b					_STIMultiply:
.a61b	8a		txa				txa 								; shift Y right into carry.
.a61c	4a		lsr a				lsr 	a
.a61d	aa		tax				tax
.a61e	90 0d		bcc $a62d			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a620	18		clc				clc
.a621	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a623	65 02		adc $02				adc 	zTemp0
.a625	85 02		sta $02				sta 	zTemp0
.a627	a5 07		lda $07				lda 	zTemp2+1
.a629	65 03		adc $03				adc 	zTemp0+1
.a62b	85 03		sta $03				sta 	zTemp0+1
.a62d					_STINoAdd:
.a62d	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a62f	26 07		rol $07				rol 	zTemp2+1
.a631	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a633	d0 e6		bne $a61b			bne 	_STIMultiply
.a635	38		sec				sec 								; hex adjust
.a636	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a638	c9 3a		cmp #$3a			cmp 	#58
.a63a	90 03		bcc $a63f			bcc 	_STIDecimal
.a63c	38		sec				sec
.a63d	e9 07		sbc #$07			sbc 	#7
.a63f					_STIDecimal:
.a63f	38		sec				sec
.a640	e9 30		sbc #$30			sbc 	#48
.a642	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a644	b0 10		bcs $a656			bcs 	_STIFail
.a646	d8		cld				cld
.a647	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a649	85 02		sta $02				sta 	zTemp0
.a64b	90 02		bcc $a64f			bcc 	_STINoCarry
.a64d	e6 03		inc $03				inc 	zTemp0+1
.a64f					_STINoCarry:
.a64f	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a651	c8		iny				iny 								; point to next
.a652	e6 10		inc $10				inc 	SignCount
.a654	80 a5		bra $a5fb			bra 	_STILoop 					; and go round again.
.a656					_STIFail:
.a656	a5 10		lda $10				lda 	SignCount 					; if converted 0 charactes, fail.
.a658	f0 07		beq $a661			beq 	_STINoConvert
.a65a	98		tya				tya 								; convert count in A.
.a65b	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a65d	a4 03		ldy $03				ldy 	zTemp0+1
.a65f	38		sec				sec
.a660	60		rts				rts
.a661					_STINoConvert:
.a661	18		clc				clc
.a662	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a663					IntToString:
.a663	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a665	84 03		sty $03				sty 	zTemp0+1
.a667	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a669	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a66b					_ITSLoop:
.a66b	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a66d					_ITSSubtractLoop:
.a66d	38		sec				sec
.a66e	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a670	fd a6 a6	sbc $a6a6,x			sbc 	_ITSWords,x
.a673	48		pha				pha
.a674	a5 03		lda $03				lda 	zTemp0+1
.a676	fd a7 a6	sbc $a6a7,x			sbc 	_ITSWords+1,x
.a679	90 09		bcc $a684			bcc 	_ITSEndSub 					; can't subtract any more.
.a67b	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a67d	68		pla				pla
.a67e	85 02		sta $02				sta 	zTemp0
.a680	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a682	80 e9		bra $a66d			bra 	_ITSSubtractLoop
.a684					_ITSEndSub:
.a684	68		pla				pla 								; throw away the interim result
.a685	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a687	d0 04		bne $a68d			bne 	_ITSWriteOut 				; always write it out
.a689	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a68b	f0 06		beq $a693			beq 	_ITSNext 					; suppressing leading zeros.
.a68d					_ITSWriteOut:
.a68d	09 30		ora #$30			ora 	#48 						; output digit.
.a68f	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a692	c8		iny				iny
.a693					_ITSNext:
.a693	e8		inx				inx
.a694	e8		inx				inx
.a695	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a697	d0 d2		bne $a66b			bne 	_ITSLoop 					; do the new digits
.a699	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a69b	09 30		ora #$30			ora 	#48
.a69d	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a6a0	a9 00		lda #$00			lda 	#0
.a6a2	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a6a5	60		rts				rts
.a6a6					_ITSWords:
>a6a6	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a6ae					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a6ae					VariableFind:
.a6ae	da		phx				phx 								; save the stack position
.a6af	08		php				php 								; save the create flag
.a6b0	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a6b2	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a6b4	90 10		bcc $a6c6			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a6b6	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a6b8	0a		asl a				asl 	a 							; double clear carry
.a6b9	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a6bb	85 02		sta $02				sta 	zTemp0
.a6bd	a9 0f		lda #$0f			lda		#FastVariables >>8
.a6bf	85 03		sta $03				sta 	zTemp0+1
.a6c1	28		plp				plp 								; create flag is irrelevant.
.a6c2	fa		plx				plx									; restore the old stack position
.a6c3	c8		iny				iny 								; skip over the single identifier character
.a6c4	38		sec				sec 								; return with CS
.a6c5	60		rts				rts
.a6c6					_VFIsNotFastVariable:
.a6c6	20 98 a7	jsr $a798			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a6c9	20 f3 a6	jsr $a6f3			jsr 	VFSearch 					; try to find the variable.
.a6cc	b0 0d		bcs $a6db			bcs 	_VFEndSearch 				; found it, so exit
.a6ce	28		plp				plp 								; do we want autocreate
.a6cf	b0 03		bcs $a6d4			bcs 	_VFCreate
.a6d1	fa		plx				plx 								; restore stack position and return CC
.a6d2	18		clc				clc
.a6d3	60		rts				rts
.a6d4					_VFCreate:
.a6d4	20 98 a7	jsr $a798			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a6d7	20 2f a7	jsr $a72f			jsr 	VFCreate 					; create a new record and link it in.
.a6da	08		php				php 								; save a dummy P to be popped.
.a6db					_VFEndSearch:
.a6db	18		clc				clc 								; the data is at offset + 4
.a6dc	a5 04		lda $04				lda 	zTemp1
.a6de	69 04		adc #$04			adc 	#4
.a6e0	85 02		sta $02				sta 	zTemp0
.a6e2	a5 05		lda $05				lda 	zTemp1+1
.a6e4	69 00		adc #$00			adc 	#0
.a6e6	85 03		sta $03				sta 	zTemp0+1
.a6e8	28		plp				plp 								; dump the create flag
.a6e9					_VFSkipExit:
.a6e9	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a6eb	c8		iny				iny
.a6ec	c9 e0		cmp #$e0			cmp 	#$E0
.a6ee	90 f9		bcc $a6e9			bcc 	_VFSkipExit
.a6f0	fa		plx				plx 								; restore X
.a6f1	38		sec				sec
.a6f2	60		rts				rts
.a6f3					VFSearch:
.a6f3	48		pha				pha 								; save AXY.
.a6f4	da		phx				phx
.a6f5	5a		phy				phy
.a6f6	98		tya				tya									; add Y to codePtr, put in zTemp2
.a6f7	18		clc				clc 								; so it points to the identifier.
.a6f8	65 00		adc $00				adc 	codePtr
.a6fa	85 06		sta $06				sta 	zTemp2
.a6fc	a5 01		lda $01				lda 	codePtr+1
.a6fe	69 00		adc #$00			adc 	#0
.a700	85 07		sta $07				sta 	zTemp2+1
.a702					_VFSLoop:
.a702	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a704	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a706	f0 22		beq $a72a			beq 	_VFSFailed 					; failed.
.a708	aa		tax				tax 								; MSB in X
.a709	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a70b	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a70d	86 05		stx $05				stx 	zTemp1+1
.a70f	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a711	b1 04		lda ($04),y			lda 	(zTemp1),y
.a713	85 08		sta $08				sta 	zTemp3
.a715	c8		iny				iny
.a716	b1 04		lda ($04),y			lda 	(zTemp1),y
.a718	85 09		sta $09				sta 	zTemp3+1
.a71a	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a71c					_VFSCheckName:
.a71c	c8		iny				iny
.a71d	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a71f	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a721	d0 df		bne $a702			bne 	_VFSLoop
.a723	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a725	90 f5		bcc $a71c			bcc 	_VFSCheckName
.a727	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a728	80 01		bra $a72b			bra		_VFSExit
.a72a					_VFSFailed:
.a72a	18		clc				clc
.a72b					_VFSExit:
.a72b	7a		ply				ply 								; restore registers and exit.
.a72c	fa		plx				plx
.a72d	68		pla				pla
.a72e	60		rts				rts
.a72f					VFCreate:
.a72f	48		pha				pha 								; save registers
.a730	da		phx				phx
.a731	5a		phy				phy
.a732	18		clc				clc 								; add 6 to memVarPtr, saving its
.a733	a5 13		lda $13				lda 	memVarPtr 					; address in zTemp0 as we go.
.a735	85 02		sta $02				sta 	zTemp0
.a737	69 06		adc #$06			adc 	#6
.a739	85 13		sta $13				sta 	memVarPtr
.a73b	a5 14		lda $14				lda 	memVarPtr+1
.a73d	85 03		sta $03				sta 	zTemp0+1
.a73f	69 00		adc #$00			adc 	#0
.a741	85 14		sta $14				sta 	memVarPtr+1
.a743	c5 12		cmp $12				cmp 	allocPtr+1 					; out of memory ?
.a745	f0 46		beq $a78d			beq 	_VFCMemory
.a747	98		tya				tya 								; work out identifier address
.a748	18		clc				clc
.a749	65 00		adc $00				adc 	codePtr
.a74b	48		pha				pha
.a74c	c8		iny				iny
.a74d	a5 01		lda $01				lda 	codePtr+1
.a74f	69 00		adc #$00			adc 	#0
.a751	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.a753	b0 0b		bcs $a760			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.a755	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a758	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.a760					_VFCInProgram:
.a760	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a762	91 02		sta ($02),y			sta 	(zTemp0),y
.a764	88		dey				dey
.a765	68		pla				pla
.a766	91 02		sta ($02),y			sta 	(zTemp0),y
.a768	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a76a	a9 00		lda #$00			lda 	#0
.a76c	91 02		sta ($02),y			sta 	(zTemp0),y
.a76e	c8		iny				iny
.a76f	91 02		sta ($02),y			sta 	(zTemp0),y
.a771	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a773	b2 04		lda ($04)			lda 	(zTemp1)
.a775	92 02		sta ($02)			sta 	(zTemp0)
.a777	b1 04		lda ($04),y			lda 	(zTemp1),y
.a779	91 02		sta ($02),y			sta 	(zTemp0),y
.a77b	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a77d	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a77f	a5 03		lda $03				lda 	zTemp0+1
.a781	91 04		sta ($04),y			sta 	(zTemp1),y
.a783	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a785	a5 02		lda $02				lda 	zTemp0
.a787	85 04		sta $04				sta 	zTemp1
.a789	7a		ply				ply
.a78a	fa		plx				plx
.a78b	68		pla				pla
.a78c	60		rts				rts
.a78d					_VFCMemory:
.a78d	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a790	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a798					VFSetupHashPointer:
.a798	48		pha				pha
.a799	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a79b	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a79d	0a		asl a				asl 	a 							; double it, also clears carry
.a79e	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a7a0	85 04		sta $04				sta 	zTemp1
.a7a2	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a7a4	85 05		sta $05				sta 	zTemp1+1
.a7a6	68		pla				pla
.a7a7	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.a7a8					TokeniseInputBuffer:
.a7a8	48		pha				pha
.a7a9	da		phx				phx
.a7aa	5a		phy				phy
.a7ab	64 19		stz $19				stz 	TokenOffset					; reset index into TokenBuffer
.a7ad	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.a7b0	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.a7b2	20 1b a8	jsr $a81b			jsr 	TokWriteToken
.a7b5	20 1b a8	jsr $a81b			jsr 	TokWriteToken
.a7b8	20 1b a8	jsr $a81b			jsr 	TokWriteToken
.a7bb	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.a7bd					_TIBForward:
.a7bd	e8		inx				inx
.a7be	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a7c1	d0 fa		bne $a7bd			bne 	_TIBForward
.a7c3					_TIBBackward:
.a7c3	ca		dex				dex 								; back one.
.a7c4	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.a7c6	f0 4f		beq $a817			beq 	_TIBExit					; return empty buffer
.a7c8	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a7cb	c9 20		cmp #$20			cmp 	#" "
.a7cd	f0 f4		beq $a7c3			beq 	_TIBBackward
.a7cf	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.a7d2	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.a7d4					_TIBMainLoop:
.a7d4	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.a7d7	f0 3e		beq $a817			beq 	_TIBExit 					; done the buffer if zero.
.a7d9	e8		inx				inx
.a7da	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.a7dc	f0 f6		beq $a7d4			beq 	_TIBMainLoop
.a7de	ca		dex				dex 								; undo the last inx.
.a7df	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.a7e1	f0 08		beq $a7eb			beq 	_TIBConstant
.a7e3	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.a7e5	90 09		bcc $a7f0			bcc 	_TIBNotConstant
.a7e7	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7e9	b0 05		bcs $a7f0			bcs 	_TIBNotConstant
.a7eb					_TIBConstant:
.a7eb	20 9e a8	jsr $a89e			jsr 	TOKConvertConstant
.a7ee	80 e4		bra $a7d4			bra 	_TIBMainLoop
.a7f0					_TIBNotConstant:
.a7f0	c9 3a		cmp #$3a			cmp 	#":"						; definition
.a7f2	d0 05		bne $a7f9			bne 	_TIBNotDefinition
.a7f4	20 f0 a8	jsr $a8f0			jsr 	TOKConvertDefinition
.a7f7	80 db		bra $a7d4			bra 	_TIBMainLoop
.a7f9					_TIBNotDefinition:
.a7f9	c9 27		cmp #$27			cmp 	#"'"
.a7fb	f0 04		beq $a801			beq 	_TIBIsCommentString
.a7fd	c9 22		cmp #$22			cmp 	#'"'
.a7ff	d0 05		bne $a806			bne 	_TIBNotCommentString
.a801					_TIBIsCommentString:
.a801	20 54 a9	jsr $a954			jsr 	TOKConvertCommentString
.a804	80 ce		bra $a7d4			bra 	_TIBMainLoop
.a806					_TIBNotCommentString:
.a806	20 9b a9	jsr $a99b			jsr 	TOKCheckIsToken 			; check if a token.
.a809	b0 c9		bcs $a7d4			bcs 	_TIBMainLoop
.a80b	a5 19		lda $19				lda 	TokenOffset 				; save token offset.
.a80d	48		pha				pha
.a80e	20 2f a9	jsr $a92f			jsr 	TOKCopyIdentifier 			; copy identifier.
.a811	68		pla				pla
.a812	20 4c a8	jsr $a84c			jsr 	TOKCheckIdentifierIsCall 	; convert if call.
.a815	80 bd		bra $a7d4			bra 	_TIBMainLoop
.a817					_TIBExit:
.a817	7a		ply				ply
.a818	fa		plx				plx
.a819	68		pla				pla
.a81a	60		rts				rts
.a81b					TOKWriteToken:
.a81b	da		phx				phx
.a81c	a6 19		ldx $19				ldx 	TokenOffset
.a81e	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.a821	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.a824	e6 19		inc $19				inc 	TokenOffset
.a826	fa		plx				plx
.a827	60		rts				rts
.a828					TOKFixUpLast:
.a828	da		phx				phx
.a829	a6 19		ldx $19				ldx 	TokenOffset
.a82b	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.a82e	09 e0		ora #$e0			ora 	#$E0
.a830	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.a833	fa		plx				plx
.a834	60		rts				rts
.a835					TOKConvertIdentifier:
.a835	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.a837	f0 0f		beq $a848			beq 	_TKCIDot
.a839	38		sec				sec 								; A-Z -> 1-27
.a83a	e9 40		sbc #$40			sbc 	#64
.a83c	f0 08		beq $a846			beq 	_TKCIFail
.a83e	c9 1b		cmp #$1b			cmp 	#27
.a840	b0 04		bcs $a846			bcs 	_TKCIFail
.a842	09 c0		ora #$c0			ora 	#$C0 						; fix up
.a844	38		sec				sec
.a845	60		rts				rts
.a846					_TKCIFail:
.a846	18		clc				clc
.a847	60		rts				rts
.a848					_TKCIDot:
.a848	a9 db		lda #$db			lda 	#$C0+27
.a84a	38		sec				sec
.a84b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_check_call.asm

.a84c					TOKCheckIdentifierIsCall:
.a84c	48		pha				pha
.a84d	da		phx				phx
.a84e	5a		phy				phy
.a84f	85 04		sta $04				sta 	zTemp1
.a851	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a853	85 02		sta $02				sta 	zTemp0
.a855	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a857	85 03		sta $03				sta 	zTemp0+1
.a859					_TKCIILoop:
.a859	b2 02		lda ($02)			lda 	(zTemp0) 					; reached the end
.a85b	f0 3d		beq $a89a			beq 	_TKCIIExit
.a85d	a0 03		ldy #$03			ldy 	#3							; check if definition
.a85f	b1 02		lda ($02),y			lda 	(zTemp0),y
.a861	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a863	d0 28		bne $a88d			bne 	_TKCIINext 					; if not skip.
.a865	a6 04		ldx $04				ldx 	zTemp1 						; position of identifier.
.a867	c8		iny				iny 								; skip count
.a868					_TKCIICheck:
.a868	c8		iny				iny
.a869	bd 00 0a	lda $0a00,x			lda 	TokenBuffer,x 				; compare identifiers
.a86c	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a86e	d0 1d		bne $a88d			bne 	_TKCIINext
.a870	e8		inx				inx
.a871	c9 e0		cmp #$e0			cmp 	#$E0						; go back if not end identifier.
.a873	90 f3		bcc $a868			bcc 	_TKCIICheck
.a875	a5 04		lda $04				lda 	zTemp1 						; get identifier position
.a877	85 19		sta $19				sta 	TokenOffset 				; reset it.
.a879	a9 02		lda #$02			lda 	#KWD_SYS_CALL 				; write call
.a87b	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a87e	a0 01		ldy #$01			ldy 	#1
.a880	b1 02		lda ($02),y			lda 	(zTemp0),y
.a882	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a885	c8		iny				iny
.a886	b1 02		lda ($02),y			lda 	(zTemp0),y
.a888	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a88b	80 0d		bra $a89a			bra 	_TKCIIExit 					; and exit.
.a88d					_TKCIINext:
.a88d	18		clc				clc
.a88e	b2 02		lda ($02)			lda 	(zTemp0)
.a890	65 02		adc $02				adc 	zTemp0
.a892	85 02		sta $02				sta 	zTemp0
.a894	90 c3		bcc $a859			bcc 	_TKCIILoop
.a896	e6 03		inc $03				inc 	zTemp0+1
.a898	80 bf		bra $a859			bra 	_TKCIILoop
.a89a					_TKCIIExit:
.a89a	7a		ply				ply
.a89b	fa		plx				plx
.a89c	68		pla				pla
.a89d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.a89e					TOKConvertConstant:
.a89e	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.a8a0	da		phx				phx 								; save X position
.a8a1	20 de a5	jsr $a5de			jsr 	StringToInt 				; try to convert
.a8a4	90 40		bcc $a8e6			bcc 	_TKCCError
.a8a6	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.a8a8	86 02		stx $02				stx 	zTemp0
.a8aa	85 04		sta $04				sta 	zTemp1 						; save count
.a8ac	68		pla				pla 								; restore X position, add the count
.a8ad	18		clc				clc
.a8ae	65 04		adc $04				adc 	zTemp1
.a8b0	aa		tax				tax
.a8b1	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.a8b4	c9 2d		cmp #$2d			cmp 	#"-"
.a8b6	d0 0e		bne $a8c6			bne 	_TKCCNotNegative
.a8b8	e8		inx				inx 								; consume the -
.a8b9	38		sec				sec
.a8ba	a9 00		lda #$00			lda 	#0 							; negate the constant.
.a8bc	e5 02		sbc $02				sbc 	zTemp0
.a8be	85 02		sta $02				sta 	zTemp0
.a8c0	a9 00		lda #$00			lda 	#0
.a8c2	e5 03		sbc $03				sbc 	zTemp0+1
.a8c4	85 03		sta $03				sta 	zTemp0+1
.a8c6					_TKCCNotNegative:
.a8c6	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.a8c8	d0 0c		bne $a8d6			bne 	_TKCCLongConstant
.a8ca	a5 02		lda $02				lda 	zTemp0
.a8cc	c9 40		cmp #$40			cmp 	#$40
.a8ce	b0 06		bcs $a8d6			bcs 	_TKCCLongConstant
.a8d0	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.a8d2	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a8d5	60		rts				rts
.a8d6					_TKCCLongConstant:
.a8d6	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.a8d8	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a8db	a5 02		lda $02				lda 	zTemp0
.a8dd	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a8e0	a5 03		lda $03				lda 	zTemp0+1
.a8e2	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a8e5	60		rts				rts
.a8e6					_TKCCError:
.a8e6	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a8e9	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.a8f0					TOKConvertDefinition:
.a8f0	e8		inx				inx 								; skip over :
.a8f1	a9 05		lda #$05			lda 	#KWD_SYS_DEFINE 			; output define token
.a8f3	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a8f6					TOKConvertIdentifierOnly:
.a8f6	64 02		stz $02				stz 	zTemp0 						; count how many identifiers.
.a8f8	da		phx				phx
.a8f9					_TKCDCount:
.a8f9	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a8fc	20 35 a8	jsr $a835			jsr 	TOKConvertIdentifier
.a8ff	90 05		bcc $a906			bcc 	_TKCDCounted
.a901	e8		inx				inx
.a902	e6 02		inc $02				inc 	zTemp0
.a904	80 f3		bra $a8f9			bra 	_TKCDCount
.a906					_TKCDCounted:
.a906	a5 02		lda $02				lda 	zTemp0 						; get count
.a908	f0 16		beq $a920			beq 	_TKCDFail 					; can't be none
.a90a	20 1b a8	jsr $a81b			jsr 	TOKWriteToken 				; write count
.a90d	fa		plx				plx 								; restore X
.a90e					_TKCDLoop:
.a90e	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; output that many tokens.
.a911	e8		inx				inx
.a912	20 35 a8	jsr $a835			jsr 	TOKConvertIdentifier
.a915	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a918	c6 02		dec $02				dec 	zTemp0
.a91a	d0 f2		bne $a90e			bne 	_TKCDLoop
.a91c	20 28 a8	jsr $a828			jsr 	TOKFixUpLast 				; set bit for last character.
.a91f	60		rts				rts
.a920					_TKCDFail:
.a920	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a923	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>a92b	45 52 3f 00
.a92f					TOKCopyIdentifier:
.a92f	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a932	20 35 a8	jsr $a835			jsr 	TOKConvertIdentifier
.a935	90 13		bcc $a94a			bcc 	_TKCIError
.a937					_TKCILoop:
.a937	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get and output token till not found
.a93a	e8		inx				inx
.a93b	20 35 a8	jsr $a835			jsr 	TOKConvertIdentifier
.a93e	90 05		bcc $a945			bcc 	_TKCIEnd
.a940	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a943	80 f2		bra $a937			bra 	_TKCILoop
.a945					_TKCIEnd:
.a945	ca		dex				dex
.a946	20 28 a8	jsr $a828			jsr 	TOKFixUpLast 				; set bit for last character.
.a949	60		rts				rts
.a94a					_TKCIError:
.a94a	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a94d	50 41 52 53 45 3f 00				.text 	"PARSE?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.a954					TOKConvertCommentString:
.a954	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.a956	f0 06		beq $a95e			beq 	_TKCCSComment
.a958	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.a95a	a0 22		ldy #$22			ldy 	#'"'						; match character
.a95c	80 04		bra $a962			bra 	_TKCCSContinue
.a95e					_TKCCSComment:
.a95e	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.a960	a0 00		ldy #$00			ldy 	#0 							; match character
.a962					_TKCCSContinue:
.a962	20 1b a8	jsr $a81b			jsr 	TOKWriteToken 				; write initial token
.a965	e8		inx				inx 								; skip over ' or "
.a966	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.a968	a0 00		ldy #$00			ldy 	#0 							; count of characters
.a96a	da		phx				phx 								; save start position
.a96b					_TKCCSFindSize:
.a96b	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.a96e	c5 02		cmp $02				cmp 	zTemp0
.a970	f0 10		beq $a982			beq 	_TKCCSFoundEnd
.a972	e8		inx				inx 								; bump pos, count
.a973	c8		iny				iny
.a974	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.a976	d0 f3		bne $a96b			bne 	_TKCCSFindSize
.a978	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>a97b	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.a982					_TKCCSFoundEnd:
.a982	98		tya				tya 								; length of element in Y
.a983	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a986	fa		plx				plx 								; restore start position and copy out
.a987					_TKCCSCopyOut:
.a987	c0 00		cpy #$00			cpy 	#0 							; complete ?
.a989	f0 0a		beq $a995			beq 	_TKCCSExit
.a98b	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a98e	20 1b a8	jsr $a81b			jsr 	TOKWriteToken
.a991	e8		inx				inx
.a992	88		dey				dey
.a993	80 f2		bra $a987			bra 	_TKCCSCopyOut
.a995					_TKCCSExit:
.a995	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.a997	f0 01		beq $a99a			beq 	_TKCSSNotComment
.a999	e8		inx				inx
.a99a					_TKCSSNotComment:
.a99a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.a99b					TOKCheckIsToken:
.a99b	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.a99d	85 02		sta $02				sta 	zTemp0
.a99f	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a9a1	85 03		sta $03				sta 	zTemp0+1
.a9a3	64 04		stz $04				stz 	zTemp1 						; best match length
.a9a5	64 06		stz $06				stz 	zTemp2 						; current token.
.a9a7					_TCTLoop:
.a9a7	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.a9a9	da		phx				phx 								; save start
.a9aa					_TCTCompare:
.a9aa	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.a9ac	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.a9af	e8		inx				inx 								; bump both pointers.
.a9b0	c8		iny				iny
.a9b1	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.a9b2	d0 0e		bne $a9c2			bne 	_TCTNext 					; different, go to next.
.a9b4	90 f4		bcc $a9aa			bcc 	_TCTCompare 				; still comparing.
.a9b6	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.a9b8	c5 04		cmp $04				cmp 	zTemp1						; best so far
.a9ba	90 06		bcc $a9c2			bcc 	_TCTNext 					; if not, skip to next.
.a9bc	85 04		sta $04				sta 	zTemp1 						; new best score
.a9be	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.a9c0	85 07		sta $07				sta 	zTemp2+1
.a9c2					_TCTNext:
.a9c2	fa		plx				plx 								; restore start position.
.a9c3	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.a9c5	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.a9c7	38		sec				sec
.a9c8	65 02		adc $02				adc 	zTemp0
.a9ca	85 02		sta $02				sta 	zTemp0
.a9cc	90 02		bcc $a9d0			bcc		_TCTNoCarry
.a9ce	e6 03		inc $03				inc 	zTemp0+1
.a9d0					_TCTNoCarry:
.a9d0	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.a9d2	d0 d3		bne $a9a7			bne 	_TCTLoop 					; no, check the next keyword.
.a9d4	18		clc				clc
.a9d5	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.a9d7	f0 0b		beq $a9e4			beq 	_TCTExit
.a9d9	8a		txa				txa 								; add that length to the input index.
.a9da	18		clc				clc
.a9db	65 04		adc $04				adc 	zTemp1
.a9dd	aa		tax				tax
.a9de	a5 07		lda $07				lda 	zTemp2+1 					; token number
.a9e0	20 1b a8	jsr $a81b			jsr 	TOKWriteToken 				; write it out.
.a9e3	38		sec				sec 								; set carry and exit
.a9e4					_TCTExit:
.a9e4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a9e5					Cmd_List:
.a9e5	fa		plx				plx
.a9e6	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a9e8	64 07		stz $07				stz 	zTemp2+1
.a9ea	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.a9ec	f0 0b		beq $a9f9			beq 	_CLNoStart
.a9ee	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.a9f1	85 06		sta $06				sta 	zTemp2
.a9f3	bd 00 07	lda $0700,x			lda 	highStack,x
.a9f6	85 07		sta $07				sta 	zTemp2+1
.a9f8	ca		dex				dex
.a9f9					_CLNoStart:
.a9f9					_CLNoStartLine:
.a9f9	a9 00		lda #$00			lda 	#(programStart) & $FF
.a9fb	85 00		sta $00				sta 	codePtr
.a9fd	a9 10		lda #$10			lda 	#(programStart) >> 8
.a9ff	85 01		sta $01				sta 	codePtr+1
.aa01					_CLILoop:
.aa01	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.aa03	f0 24		beq $aa29			beq 	_CLIEnd
.aa05	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.aa07	38		sec				sec
.aa08	b1 00		lda ($00),y			lda 	(codePtr),y
.aa0a	e5 06		sbc $06				sbc 	zTemp2
.aa0c	c8		iny				iny
.aa0d	b1 00		lda ($00),y			lda 	(codePtr),y
.aa0f	e5 07		sbc $07				sbc 	zTemp2+1
.aa11	90 09		bcc $aa1c			bcc 	_CLISkip
.aa13	da		phx				phx
.aa14	20 2c aa	jsr $aa2c			jsr 	ListCurrent 				; list the line.
.aa17	fa		plx				plx
.aa18	c6 08		dec $08				dec 	zTemp3 						; done all lines
.aa1a	f0 0d		beq $aa29			beq 	_CLIEnd
.aa1c					_CLISkip:
.aa1c	18		clc				clc
.aa1d	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.aa1f	65 00		adc $00				adc 	codePtr
.aa21	85 00		sta $00				sta 	codePtr
.aa23	90 dc		bcc $aa01			bcc 	_CLILoop
.aa25	e6 01		inc $01				inc 	codePtr+1
.aa27	80 d8		bra $aa01			bra 	_CLILoop
.aa29					_CLIEnd:
.aa29	4c 1b a0	jmp $a01b			jmp 	WarmStart
.aa2c					ListCurrent:
.aa2c	a9 02		lda #$02			lda 	#COL_GREEN
.aa2e	20 63 a3	jsr $a363			jsr 	ExternColour
.aa31	a0 01		ldy #$01			ldy 	#1							; print line#
.aa33	b1 00		lda ($00),y			lda 	(codePtr),y
.aa35	aa		tax				tax
.aa36	c8		iny				iny
.aa37	b1 00		lda ($00),y			lda 	(codePtr),y
.aa39	a8		tay				tay
.aa3a	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.aa3d	a8		tay				tay
.aa3e					_LCPadOut:
.aa3e	a9 20		lda #$20			lda 	#' '
.aa40	20 59 a3	jsr $a359			jsr 	ExternPrint
.aa43	c8		iny				iny
.aa44	c0 06		cpy #$06			cpy 	#6
.aa46	d0 f6		bne $aa3e			bne 	_LCPadOut
.aa48	a0 03		ldy #$03			ldy 	#3 							; start here
.aa4a	64 17		stz $17				stz 	PrefixCharacter				; no prefix
.aa4c					_LCLoop:
.aa4c	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.aa4e	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.aa50	f0 0b		beq $aa5d			beq 	_LCNoPrefix
.aa52	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.aa54	f0 07		beq $aa5d			beq 	_LCNoPrefix
.aa56	a5 17		lda $17				lda 	PrefixCharacter 			; output prefix, reset to space
.aa58	f0 03		beq $aa5d			beq		_LCNoPrefix
.aa5a	20 64 a2	jsr $a264			jsr 	PrintCharacter
.aa5d					_LCNoPrefix:
.aa5d	a9 20		lda #$20			lda 	#32
.aa5f	85 17		sta $17				sta 	PrefixCharacter
.aa61	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.aa63	f0 13		beq $aa78			beq 	_LCExit
.aa65	10 4d		bpl $aab4			bpl 	_LCIsToken 					; +ve goto token.
.aa67	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.aa69	b0 13		bcs $aa7e			bcs 	_LCIsIdentifier
.aa6b	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.aa6d	aa		tax				tax
.aa6e	c8		iny				iny
.aa6f	5a		phy				phy 								; push pos
.aa70	a0 00		ldy #$00			ldy 	#0
.aa72	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.aa75	7a		ply				ply
.aa76	80 d4		bra $aa4c			bra 	_LCLoop
.aa78					_LCExit:
.aa78	a9 0d		lda #$0d			lda 	#13
.aa7a	20 64 a2	jsr $a264			jsr 	PrintCharacter
.aa7d	60		rts				rts
.aa7e					_LCIsIdentifier:
.aa7e					_LCIdentLoop:
.aa7e	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.aa80	20 91 ab	jsr $ab91			jsr 	ListPrintIDChar
.aa83	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.aa85	c8		iny				iny
.aa86	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.aa88	b0 c2		bcs $aa4c			bcs 	_LCLoop 					; if so, do next
.aa8a	80 f2		bra $aa7e			bra 	_LCIdentLoop				; if not loop round
.aa8c					_LCConstant:
.aa8c	c8		iny				iny
.aa8d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.aa8f	aa		tax				tax
.aa90	c8		iny				iny 								; get MSB into Y
.aa91	b1 00		lda ($00),y			lda 	(codePtr),y
.aa93	c8		iny				iny
.aa94	5a		phy				phy
.aa95	a8		tay				tay
.aa96	5a		phy				phy 								; save sign
.aa97	10 0c		bpl $aaa5			bpl 	_LCNotNegative
.aa99	98		tya				tya 								; YX = |YX|
.aa9a	49 ff		eor #$ff			eor 	#$FF
.aa9c	a8		tay				tay
.aa9d	8a		txa				txa
.aa9e	49 ff		eor #$ff			eor 	#$FF
.aaa0	aa		tax				tax
.aaa1	e8		inx				inx
.aaa2	d0 01		bne $aaa5			bne 	_LCNotNegative
.aaa4	c8		iny				iny
.aaa5					_LCNotNegative:
.aaa5					_LCPrintYX:
.aaa5	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.aaa8	68		pla				pla 								; restore sign
.aaa9	10 05		bpl $aab0			bpl 	_LCNoTrail
.aaab	a9 2d		lda #$2d			lda 	#"-"
.aaad	20 64 a2	jsr $a264			jsr 	PrintCharacter
.aab0					_LCNoTrail:
.aab0	7a		ply				ply 								; restore Y
.aab1	4c 4c aa	jmp $aa4c			jmp 	_LCLoop
.aab4					_LCIsToken:
.aab4	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.aab6	f0 d4		beq $aa8c			beq 	_LCConstant
.aab8	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.aaba	90 3e		bcc $aafa			bcc 	_LCControl
.aabc					_LCIsKeywordToken:
.aabc	85 02		sta $02				sta 	zTemp0 						; save token #
.aabe	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.aac0	85 04		sta $04				sta 	zTemp1
.aac2	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.aac4	85 05		sta $05				sta 	zTemp1+1
.aac6	5a		phy				phy 								; save code offset
.aac7					_LCForward:
.aac7	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.aac9	f0 0f		beq $aada			beq 	_LCFoundToken
.aacb	c6 02		dec $02				dec 	zTemp0						; dec count.
.aacd	38		sec				sec 								; go to next keyword.
.aace	b2 04		lda ($04)			lda 	(zTemp1)
.aad0	65 04		adc $04				adc 	zTemp1
.aad2	85 04		sta $04				sta 	zTemp1
.aad4	90 f1		bcc $aac7			bcc 	_LCForward
.aad6	e6 05		inc $05				inc 	zTemp1+1
.aad8	80 ed		bra $aac7			bra 	_LCForward
.aada					_LCFoundToken:
.aada	a0 01		ldy #$01			ldy 	#1 							; output the token.
.aadc					_LCOutToken:
.aadc	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.aade	29 7f		and #$7f			and 	#$7F
.aae0	20 64 a2	jsr $a264			jsr 	PrintCharacter
.aae3	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.aae5	c8		iny				iny
.aae6	0a		asl a				asl 	a
.aae7	90 f3		bcc $aadc			bcc 	_LCOutToken
.aae9	7a		ply				ply 								; restore code offset
.aaea	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.aaec	c8		iny				iny
.aaed	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.aaef	f0 04		beq $aaf5			beq 	_LCCancelPrefix
.aaf1	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.aaf3	d0 02		bne $aaf7			bne 	_LCGoLoop
.aaf5					_LCCancelPrefix:
.aaf5	64 17		stz $17				stz 	PrefixCharacter
.aaf7					_LCGoLoop:
.aaf7	4c 4c aa	jmp $aa4c			jmp 	_LCLoop
.aafa					_LCControl:
.aafa	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.aafc	f0 3b		beq $ab39			beq 	_LCDecodeCall
.aafe	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ab00	f0 22		beq $ab24			beq 	_LCDecodeDefine
.ab02	5a		phy				phy 								; save Y
.ab03	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.ab05	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.ab07	f0 07		beq $ab10			beq 	_LCDecodeString
.ab09	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.ab0b	a9 07		lda #$07			lda 	#COL_WHITE 					; highlight comment.
.ab0d	20 63 a3	jsr $a363			jsr 	ExternColour
.ab10					_LCDecodeString
.ab10	98		tya				tya
.ab11	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ab14	7a		ply				ply 								; restore Y pos
.ab15	48		pha				pha 								; save end character on stack.
.ab16	20 71 ab	jsr $ab71			jsr 	ListPrintCodeIdentifier
.ab19	68		pla				pla 								; last character
.ab1a	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.ab1c	f0 03		beq $ab21			beq 	_LCEDNoQuote
.ab1e	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ab21					_LCEDNoQuote:
.ab21	4c 4c aa	jmp $aa4c			jmp 	_LCLoop
.ab24					_LCDecodeDefine:
.ab24	a9 03		lda #$03			lda 	#COL_YELLOW 				; highlight definition.
.ab26	20 63 a3	jsr $a363			jsr 	ExternColour
.ab29	a9 3a		lda #$3a			lda 	#":"
.ab2b	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ab2e	20 71 ab	jsr $ab71			jsr 	ListPrintCodeIdentifier
.ab31	a9 02		lda #$02			lda 	#COL_GREEN
.ab33	20 63 a3	jsr $a363			jsr 	ExternColour
.ab36	4c 4c aa	jmp $aa4c			jmp 	_LCLoop
.ab39					_LCDecodeCall:
.ab39	a9 06		lda #$06			lda 	#COL_CYAN
.ab3b	20 63 a3	jsr $a363			jsr 	ExternColour
.ab3e	c8		iny				iny 								; get line number into XA
.ab3f	b1 00		lda ($00),y			lda 	(codePtr),y
.ab41	48		pha				pha
.ab42	c8		iny				iny
.ab43	b1 00		lda ($00),y			lda 	(codePtr),y
.ab45	c8		iny				iny
.ab46	aa		tax				tax
.ab47	68		pla				pla
.ab48	20 a3 ab	jsr $aba3			jsr 	ListFindLine 				; find that line.
.ab4b	90 19		bcc $ab66			bcc 	_LCNoDefinition
.ab4d	5a		phy				phy
.ab4e	a0 03		ldy #$03			ldy 	#3 							; look at first character
.ab50	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab52	7a		ply				ply
.ab53	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ab55	d0 0f		bne $ab66			bne 	_LCNoDefinition 			; not define
.ab57	5a		phy				phy
.ab58	a0 03		ldy #$03			ldy 	#3
.ab5a	20 7b ab	jsr $ab7b			jsr 	ListPrintIdentifier
.ab5d	7a		ply				ply
.ab5e	a9 02		lda #$02			lda 	#COL_GREEN
.ab60	20 63 a3	jsr $a363			jsr 	ExternColour
.ab63	4c 4c aa	jmp $aa4c			jmp 	_LCLoop
.ab66					_LCNoDefinition:
.ab66	a9 25		lda #$25			lda 	#"%"						; print a %
.ab68	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ab6b	88		dey				dey 								; unpick Y changes
.ab6c	88		dey				dey
.ab6d	88		dey				dey
.ab6e	4c 8c aa	jmp $aa8c			jmp 	_LCConstant 				; output # as constant
.ab71					ListPrintCodeIdentifier:
.ab71	48		pha				pha 								; copy codePtr -> zTemp0
.ab72	a5 00		lda $00				lda 	codePtr
.ab74	85 02		sta $02				sta 	zTemp0
.ab76	a5 01		lda $01				lda 	codePtr+1
.ab78	85 03		sta $03				sta 	zTemp0+1
.ab7a	68		pla				pla
.ab7b					ListPrintIdentifier:
.ab7b	48		pha				pha
.ab7c	da		phx				phx
.ab7d	c8		iny				iny 								; skip over the type
.ab7e	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.ab80	aa		tax				tax
.ab81					_LPILoop:
.ab81	c8		iny				iny
.ab82	e0 00		cpx #$00			cpx 	#0
.ab84	f0 08		beq $ab8e			beq 	_LPIExit
.ab86	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab88	20 91 ab	jsr $ab91			jsr 	ListPrintIDChar
.ab8b	ca		dex				dex
.ab8c	80 f3		bra $ab81			bra 	_LPILoop
.ab8e					_LPIExit:
.ab8e	fa		plx				plx
.ab8f	68		pla				pla
.ab90	60		rts				rts
.ab91					ListPrintIDChar:
.ab91	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.ab93	10 0a		bpl $ab9f			bpl	 	_LCNotDot
.ab95	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.ab97	09 40		ora #$40			ora 	#$40 						; ASCII except .
.ab99	c9 5b		cmp #$5b			cmp 	#$40+27
.ab9b	d0 02		bne $ab9f			bne 	_LCNotDot
.ab9d	a9 2e		lda #$2e			lda 	#"."
.ab9f					_LCNotDot:
.ab9f	20 64 a2	jsr $a264			jsr 	PrintCharacter
.aba2	60		rts				rts
.aba3					ListFindLine:
.aba3	5a		phy				phy
.aba4	86 05		stx $05				stx 	zTemp1+1
.aba6	85 04		sta $04				sta 	zTemp1
.aba8	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.abaa	85 02		sta $02				sta 	zTemp0
.abac	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.abae	85 03		sta $03				sta 	zTemp0+1
.abb0					_LFLSearch:
.abb0	18		clc				clc									; reached the end.
.abb1	b2 02		lda ($02)			lda 	(zTemp0)
.abb3	f0 1d		beq $abd2			beq 	_LFLExit 					; exit with CC
.abb5	a0 01		ldy #$01			ldy 	#1
.abb7	a5 04		lda $04				lda 	zTemp1
.abb9	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.abbb	d0 07		bne $abc4			bne 	_LFLNext
.abbd	c8		iny				iny
.abbe	a5 05		lda $05				lda 	zTemp1+1
.abc0	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.abc2	f0 0d		beq $abd1			beq 	_LFLFound
.abc4					_LFLNext:
.abc4	18		clc				clc
.abc5	b2 02		lda ($02)			lda 	(zTemp0)
.abc7	65 02		adc $02				adc 	zTemp0
.abc9	85 02		sta $02				sta 	zTemp0
.abcb	90 e3		bcc $abb0			bcc 	_LFLSearch
.abcd	e6 03		inc $03				inc 	zTemp0+1
.abcf	80 df		bra $abb0			bra 	_LFLSearch
.abd1					_LFLFound:
.abd1	38		sec				sec
.abd2					_LFLExit:
.abd2	7a		ply				ply
.abd3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.abd4					Mem_Peek:
.abd4	fa		plx				plx
.abd5	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.abd8	85 02		sta $02				sta 	zTemp0
.abda	bd 00 07	lda $0700,x			lda 	highStack,x
.abdd	85 03		sta $03				sta 	zTemp0+1
.abdf	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.abe1	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.abe4	9e 00 07	stz $0700,x			stz 	highStack,x
.abe7	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.abea					Mem_WPeek:
.abea	fa		plx				plx
.abeb	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.abee	85 02		sta $02				sta 	zTemp0
.abf0	bd 00 07	lda $0700,x			lda 	highStack,x
.abf3	85 03		sta $03				sta 	zTemp0+1
.abf5	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.abf7	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.abfa	5a		phy				phy 								; read msb
.abfb	a0 01		ldy #$01			ldy 	#1
.abfd	b1 02		lda ($02),y			lda 	(zTemp0),y
.abff	7a		ply				ply
.ac00	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.ac03	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ac06					Mem_Poke:
.ac06	fa		plx				plx
.ac07	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ac0a	85 02		sta $02				sta 	zTemp0
.ac0c	bd 00 07	lda $0700,x			lda 	highStack,x
.ac0f	85 03		sta $03				sta 	zTemp0+1
.ac11	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.ac14	92 02		sta ($02)			sta 	(zTemp0)
.ac16	ca		dex				dex
.ac17	ca		dex				dex
.ac18	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ac1b					Mem_WPoke:
.ac1b	fa		plx				plx
.ac1c	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ac1f	85 02		sta $02				sta 	zTemp0
.ac21	bd 00 07	lda $0700,x			lda 	highStack,x
.ac24	85 03		sta $03				sta 	zTemp0+1
.ac26	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.ac29	92 02		sta ($02)			sta 	(zTemp0)
.ac2b	5a		phy				phy
.ac2c	a0 01		ldy #$01			ldy 	#1
.ac2e	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.ac31	91 02		sta ($02),y			sta 	(zTemp0),y
.ac33	7a		ply				ply
.ac34	ca		dex				dex
.ac35	ca		dex				dex
.ac36	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ac39					Mem_DWPoke:
.ac39	fa		plx				plx
.ac3a	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ac3d	85 02		sta $02				sta 	zTemp0
.ac3f	bd 00 07	lda $0700,x			lda 	highStack,x
.ac42	85 03		sta $03				sta 	zTemp0+1
.ac44	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.ac47	92 02		sta ($02)			sta 	(zTemp0)
.ac49	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.ac4c	92 02		sta ($02)			sta 	(zTemp0)
.ac4e	ca		dex				dex
.ac4f	ca		dex				dex
.ac50	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ac53					Mem_Alloc:
.ac53	fa		plx				plx
.ac54	38		sec				sec 								; subtract count from alloc ptr
.ac55	a5 11		lda $11				lda 	allocPtr
.ac57	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ac5a	85 11		sta $11				sta 	allocPtr
.ac5c	48		pha				pha 								; save low.
.ac5d	a5 12		lda $12				lda 	allocPtr+1
.ac5f	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ac62	85 12		sta $12				sta 	allocPtr+1
.ac64	90 10		bcc $ac76			bcc 	_MAError 					; borrow ?
.ac66	c5 14		cmp $14				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.ac68	90 0c		bcc $ac76			bcc 	_MAError
.ac6a	f0 0a		beq $ac76			beq 	_MAError
.ac6c	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.ac6f	68		pla				pla
.ac70	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac73	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ac76					_MAError:
.ac76	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>ac79	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/saveload.asm

.ac81					System_Save:
.ac81	fa		plx				plx
.ac82	da		phx				phx
.ac83	20 78 a5	jsr $a578			jsr 	ResetVarMemory 				; make sure start/end are right
.ac86	20 ad ac	jsr $acad			jsr 	SLGetFileName 				; get filename -> zTemp0
.ac89	a5 13		lda $13				lda 	memVarPtr 					; end address
.ac8b	85 04		sta $04				sta 	zTemp1
.ac8d	a5 14		lda $14				lda 	memVarPtr+1
.ac8f	85 05		sta $05				sta 	zTemp1+1
.ac91	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.ac93	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.ac95	20 b0 a3	jsr $a3b0			jsr 	ExternSave
.ac98	7a		ply				ply
.ac99	4c 1b a0	jmp $a01b			jmp 	WarmStart
.ac9c					System_Load:
.ac9c	fa		plx				plx
.ac9d	20 ad ac	jsr $acad			jsr 	SLGetFileName 				; get filename -> zTemp0
.aca0	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.aca2	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.aca4	20 e6 a3	jsr $a3e6			jsr 	ExternLoad
.aca7	20 5a a5	jsr $a55a			jsr 	ResetMemory 				; reset everything.
.acaa	4c 1b a0	jmp $a01b			jmp 	WarmStart
.acad					SLGetFileName:
.acad	e0 ff		cpx #$ff			cpx 	#255 						; gotta be something on the stack
.acaf	f0 4a		beq $acfb			beq 	_SLFNFail
.acb1	bd 00 07	lda $0700,x			lda 	highStack,x 				; should be something in token buffer
.acb4	c9 0a		cmp #$0a			cmp 	#TokenBuffer >> 8
.acb6	d0 43		bne $acfb			bne 	_SLFNFail
.acb8	85 05		sta $05				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.acba	bd 00 06	lda $0600,x			lda 	lowStack,x
.acbd	85 04		sta $04				sta 	zTemp1
.acbf	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.acc1	85 02		sta $02				sta 	zTemp0
.acc3	a9 08		lda #$08			lda 	#InputBuffer >> 8
.acc5	85 03		sta $03				sta 	zTemp0+1
.acc7	b2 04		lda ($04)			lda 	(zTemp1) 					; copy string to input buffer
.acc9	1a		inc a				inc 	a
.acca	aa		tax				tax
.accb	a0 00		ldy #$00			ldy 	#0
.accd	b1 04		lda ($04),y	_SLCopy:lda 	(zTemp1),y
.accf	91 02		sta ($02),y			sta 	(zTemp0),y
.acd1	c8		iny				iny
.acd2	ca		dex				dex
.acd3	d0 f8		bne $accd			bne 	_SLCopy
.acd5	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.acd7					_SLCheckEnd:
.acd7	88		dey				dey
.acd8	bd 0b ad	lda $ad0b,x			lda 	_SLFNExtension,x
.acdb	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.acdd	d0 05		bne $ace4			bne 	_SLNoExtension
.acdf	ca		dex				dex
.ace0	10 f5		bpl $acd7			bpl 	_SLCheckEnd
.ace2	80 16		bra $acfa			bra 	_SLExit
.ace4					_SLNoExtension:
.ace4	a0 00		ldy #$00			ldy 	#0							; add the extension.
.ace6					_SLExtend:
.ace6	ee 00 08	inc $0800			inc 	InputBuffer
.ace9	ae 00 08	ldx $0800			ldx 	InputBuffer
.acec	b9 0b ad	lda $ad0b,y			lda 	_SLFNExtension,y
.acef	c8		iny				iny
.acf0	9d 00 08	sta $0800,x			sta 	InputBuffer,x
.acf3	c9 00		cmp #$00			cmp		#0
.acf5	d0 ef		bne $ace6			bne 	_SLExtend
.acf7	ce 00 08	dec $0800			dec 	InputBuffer 				; because wrote the $00
.acfa					_SLExit:
.acfa	60		rts				rts
.acfb					_SLFNFail:
.acfb	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>acfe	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>ad06	4e 41 4d 45 00
.ad0b					_SLFNExtension:
>ad0b	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.ad10					Stack_Empty:
.ad10	fa		plx				plx
.ad11	a2 00		ldx #$00			ldx 	#0
.ad13	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad16					Stack_Drop:
.ad16	fa		plx				plx
.ad17	ca		dex				dex
.ad18	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad1b					Stack_Dup:
.ad1b	fa		plx				plx
.ad1c	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.ad1f	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.ad22	bd 00 07	lda $0700,x			lda 	highStack,x
.ad25	9d 01 07	sta $0701,x			sta 	highStack+1,x
.ad28	e8		inx				inx 								; bump stack pointer
.ad29	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad2c					Stack_Nip:
.ad2c	fa		plx				plx
.ad2d	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.ad30	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.ad33	bd 00 07	lda $0700,x			lda 	highStack,x
.ad36	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.ad39	ca		dex				dex 								; drop tos
.ad3a	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad3d					Stack_Over:
.ad3d	fa		plx				plx
.ad3e	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.ad41	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.ad44	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.ad47	9d 01 07	sta $0701,x			sta 	highStack+1,x
.ad4a	e8		inx				inx 							; bump stack pointer
.ad4b	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad4e					Stack_Swap:
.ad4e	fa		plx				plx
.ad4f	5a		phy				phy
.ad50	bd 00 06	lda $0600,x			lda 	lowStack,x
.ad53	a8		tay				tay
.ad54	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.ad57	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad5a	98		tya				tya
.ad5b	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.ad5e	bd 00 07	lda $0700,x			lda 	highStack,x
.ad61	a8		tay				tay
.ad62	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.ad65	9d 00 07	sta $0700,x			sta 	highStack,x
.ad68	98		tya				tya
.ad69	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.ad6c	7a		ply				ply
.ad6d	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.ad70					Command_Store:
.ad70	fa		plx				plx
.ad71	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.ad73	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.ad75	90 1f		bcc $ad96			bcc 	_CSLongVariable
.ad77	c8		iny				iny 								; get the next
.ad78	b1 00		lda ($00),y			lda 	(codePtr),y
.ad7a	88		dey				dey
.ad7b	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.ad7d	f0 17		beq $ad96			beq 	_CSLongVariable
.ad7f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.ad81	c8		iny				iny 								; skip over it and push on stack
.ad82	5a		phy				phy
.ad83	0a		asl a				asl 	a 							; double it, now C0-FE
.ad84	a8		tay				tay 								; put in Y
.ad85	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.ad88	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.ad8b	bd 00 07	lda $0700,x			lda 	highStack,x
.ad8e	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.ad91	ca		dex				dex 								; pop off stack
.ad92	7a		ply				ply 								; restore position and do next
.ad93	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ad96					_CSLongVariable:
.ad96	38		sec				sec 								; create variable if not found.
.ad97	20 ae a6	jsr $a6ae			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.ad9a	20 21 a4	jsr $a421			jsr 	IndexCheck 					; check indexing.
.ad9d	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.ada0	92 02		sta ($02)			sta 	(zTemp0)
.ada2	5a		phy				phy
.ada3	a0 01		ldy #$01			ldy 	#1
.ada5	bd 00 07	lda $0700,x			lda 	highStack,x
.ada8	91 02		sta ($02),y			sta 	(zTemp0),y
.adaa	7a		ply				ply
.adab	ca		dex				dex 								; pop off stack
.adac	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.adaf					Command_New:
.adaf	fa		plx				plx
.adb0	9c 00 10	stz $1000			stz 	ProgramStart
.adb3	4c 1b a0	jmp $a01b			jmp 	WarmStart
.adb6					Command_Old:
.adb6	fa		plx				plx
.adb7	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.adb9	85 00		sta $00				sta 	codePtr
.adbb	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.adbd	85 01		sta $01				sta 	codePtr+1
.adbf	a0 03		ldy #$03			ldy 	#3
.adc1					_COAdvance:
.adc1	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.adc3	b0 0e		bcs $add3			bcs		_COFail
.adc5	20 e7 b1	jsr $b1e7			jsr 	AdvanceInCode
.adc8	b1 00		lda ($00),y			lda 	(codePtr),y
.adca	d0 f5		bne $adc1			bne 	_COAdvance
.adcc	c8		iny				iny 								; byte after end of line
.adcd	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.add0					_CONotDeleted:
.add0	4c 1b a0	jmp $a01b			jmp 	WarmStart
.add3					_COFail:
.add3	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>add6	43 41 4e 54 3f 00				.text 	"CANT?",0
.addc					Command_End:
.addc	fa		plx				plx
.addd	4c 1b a0	jmp $a01b			jmp 	WarmStart
.ade0					Command_Stop:
>ade0	ff						.byte 	$FF
.ade1	fa		plx				plx
.ade2	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>ade5	53 54 4f 50 00					.text 	"STOP",0
.adea					Command_Assert:
.adea	fa		plx				plx
.adeb	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.adee	1d 00 07	ora $0700,x			ora 	highStack,x
.adf1	f0 04		beq $adf7			beq 	_CAFail
.adf3	ca		dex				dex 								; throw if not.
.adf4	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.adf7					_CAFail:
.adf7	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>adfa	41 53 53 45 52 54 00				.text 	"ASSERT",0
.ae01					Command_Sys:
.ae01	fa		plx				plx
.ae02	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.ae05	85 02		sta $02				sta 	zTemp0
.ae07	bd 00 07	lda $0700,x			lda 	highStack,x
.ae0a	85 03		sta $03				sta 	zTemp0+1
.ae0c	ca		dex				dex 								; pop tos
.ae0d	da		phx				phx 								; save XY
.ae0e	5a		phy				phy
.ae0f	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.ae12	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.ae15	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.ae18	20 20 ae	jsr $ae20			jsr 	_CSCallInd
.ae1b	7a		ply				ply 								; restore XY
.ae1c	fa		plx				plx
.ae1d	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ae20					_CSCallInd:
.ae20	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.ae23					Command_DumpStack:
.ae23	fa		plx				plx
.ae24	da		phx				phx 								; save pos and sp
.ae25	5a		phy				phy
.ae26	86 10		stx $10				stx 	SignCount
.ae28	a2 ff		ldx #$ff			ldx 	#$FF
.ae2a					_CDSLoop:
.ae2a	e4 10		cpx $10				cpx 	SignCount 					; done all ?
.ae2c	f0 2a		beq $ae58			beq 	_CDSExit
.ae2e	e8		inx				inx
.ae2f	da		phx				phx 								; save SP
.ae30	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.ae33	a8		tay				tay
.ae34	bd 00 06	lda $0600,x			lda 	lowStack,x
.ae37	aa		tax				tax
.ae38	c0 00		cpy #$00			cpy 	#0
.ae3a	10 11		bpl $ae4d			bpl 	_CDSPositive
.ae3c	a9 2d		lda #$2d			lda 	#"-" 						; minus
.ae3e	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ae41	98		tya				tya 								; negate YX
.ae42	49 ff		eor #$ff			eor 	#$FF
.ae44	a8		tay				tay
.ae45	8a		txa				txa
.ae46	49 ff		eor #$ff			eor 	#$FF
.ae48	aa		tax				tax
.ae49	e8		inx				inx
.ae4a	d0 01		bne $ae4d			bne 	_CDSPositive
.ae4c	c8		iny				iny
.ae4d					_CDSPositive:
.ae4d	20 47 a2	jsr $a247			jsr 	PrintIntegerUnsigned
.ae50	a9 20		lda #$20			lda 	#" " 						; space
.ae52	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ae55	fa		plx				plx
.ae56	80 d2		bra $ae2a			bra 	_CDSLoop
.ae58					_CDSExit:
.ae58	a9 3c		lda #$3c			lda 	#"<"
.ae5a	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ae5d	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ae60	a9 0d		lda #$0d			lda 	#13 						; CR
.ae62	20 64 a2	jsr $a264			jsr 	PrintCharacter
.ae65	7a		ply				ply
.ae66	fa		plx				plx
.ae67	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.ae6a					Stack_Add:
.ae6a	fa		plx				plx
.ae6b	ca		dex				dex
.ae6c	18		clc				clc
.ae6d	bd 00 06	lda $0600,x			lda		lowStack,x
.ae70	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ae73	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae76	bd 00 07	lda $0700,x			lda		highStack,x
.ae79	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ae7c	9d 00 07	sta $0700,x			sta 	highStack,x
.ae7f	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ae82					Stack_Sub:
.ae82	fa		plx				plx
.ae83	ca		dex				dex
.ae84	38		sec				sec
.ae85	bd 00 06	lda $0600,x			lda		lowStack,x
.ae88	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ae8b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae8e	bd 00 07	lda $0700,x			lda		highStack,x
.ae91	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ae94	9d 00 07	sta $0700,x			sta 	highStack,x
.ae97	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.ae9a					Stack_And:
.ae9a	fa		plx				plx
.ae9b	ca		dex				dex
.ae9c	bd 00 06	lda $0600,x			lda		lowStack,x
.ae9f	3d 01 06	and $0601,x			and		lowStack+1,x
.aea2	9d 00 06	sta $0600,x			sta 	lowStack,x
.aea5	bd 00 07	lda $0700,x			lda		highStack,x
.aea8	3d 01 07	and $0701,x			and 	highStack+1,x
.aeab	9d 00 07	sta $0700,x			sta 	highStack,x
.aeae	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.aeb1					Stack_Xor:
.aeb1	fa		plx				plx
.aeb2	ca		dex				dex
.aeb3	bd 00 06	lda $0600,x			lda		lowStack,x
.aeb6	5d 01 06	eor $0601,x			eor		lowStack+1,x
.aeb9	9d 00 06	sta $0600,x			sta 	lowStack,x
.aebc	bd 00 07	lda $0700,x			lda		highStack,x
.aebf	5d 01 07	eor $0701,x			eor 	highStack+1,x
.aec2	9d 00 07	sta $0700,x			sta 	highStack,x
.aec5	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.aec8					Stack_Or:
.aec8	fa		plx				plx
.aec9	ca		dex				dex
.aeca	bd 00 06	lda $0600,x			lda		lowStack,x
.aecd	1d 01 06	ora $0601,x			ora		lowStack+1,x
.aed0	9d 00 06	sta $0600,x			sta 	lowStack,x
.aed3	bd 00 07	lda $0700,x			lda		highStack,x
.aed6	1d 01 07	ora $0701,x			ora 	highStack+1,x
.aed9	9d 00 07	sta $0700,x			sta 	highStack,x
.aedc	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.aedf					Stack_Shl:
.aedf	fa		plx				plx
.aee0	38		sec				sec
.aee1	80 02		bra $aee5			bra 	StackShift
.aee3					Stack_Shr:
.aee3	fa		plx				plx
.aee4	18		clc				clc
.aee5					StackShift:
.aee5	08		php				php
.aee6	ca		dex				dex
.aee7	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.aeea	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.aeec	1d 01 07	ora $0701,x			ora 	highStack+1,x
.aeef	d0 19		bne $af0a			bne 	_SSZero
.aef1					_SSLoop:
.aef1	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.aef4	30 1a		bmi $af10			bmi 	_SSDone 					; completed ?
.aef6	28		plp				plp 								; restore flag
.aef7	08		php				php
.aef8	b0 08		bcs $af02			bcs 	_SSLeft 					; do either shift.
.aefa	5e 00 07	lsr $0700,x			lsr 	highStack,x
.aefd	7e 00 06	ror $0600,x			ror 	lowStack,x
.af00	80 ef		bra $aef1			bra 	_SSLoop
.af02					_SSLeft:
.af02	1e 00 06	asl $0600,x			asl 	lowStack,x
.af05	3e 00 07	rol $0700,x			rol 	highStack,x
.af08	80 e7		bra $aef1			bra 	_SSLoop
.af0a					_SSZero:
.af0a	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.af0d	9e 00 07	stz $0700,x			stz 	highStack,x
.af10					_SSDone:
.af10	28		plp				plp 								; throw flag.
.af11	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.af14					Comp_Equal:
.af14	fa		plx				plx
.af15	38		sec				sec
.af16	80 02		bra $af1a			bra 	Comp_CheckEqual
.af18					Comp_NotEqual:
.af18	fa		plx				plx
.af19	18		clc				clc
.af1a					Comp_CheckEqual:
.af1a	08		php				php
.af1b	ca		dex				dex
.af1c	bd 00 06	lda $0600,x			lda		lowStack,x
.af1f	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.af22	d0 06		bne $af2a			bne 	_CCENonZero
.af24	bd 00 07	lda $0700,x			lda		highStack,x
.af27	5d 01 07	eor $0701,x			eor 	highStack+1,x
.af2a					_CCENonZero:
.af2a	f0 02		beq $af2e			beq 	_CCENotSet
.af2c	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.af2e					_CCENotSet:
.af2e					CompCheckFlip:
.af2e	28		plp				plp 								; if carry set, we want $FF if equal
.af2f	90 02		bcc $af33			bcc 	CompReturn
.af31	49 ff		eor #$ff			eor 	#$FF
.af33					CompReturn:
.af33	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.af36	9d 00 07	sta $0700,x			sta 	highStack,x
.af39	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.af3c					Comp_Less:
.af3c	fa		plx				plx
.af3d	18		clc				clc
.af3e	80 02		bra $af42			bra 	Comp_LessCont
.af40					Comp_GreaterEqual:
.af40	fa		plx				plx
.af41	38		sec				sec
.af42					Comp_LessCont:
.af42	08		php				php
.af43	ca		dex				dex
.af44	38		sec				sec
.af45	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.af48	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.af4b	bd 00 07	lda $0700,x			lda 	highStack,x
.af4e	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.af51	50 02		bvc $af55			bvc 	_CLNoFlip 					; unsigned -> signed
.af53	49 80		eor #$80			eor 	#$80
.af55					_CLNoFlip:
.af55	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.af57	f0 d5		beq $af2e			beq 	CompCheckFlip
.af59	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.af5b	80 d1		bra $af2e			bra 	CompCheckFlip
.af5d					Comp_LessEqual:
.af5d	fa		plx				plx
.af5e	38		sec				sec
.af5f	80 02		bra $af63			bra 	Comp_LessEqualCont
.af61					Comp_Greater:
.af61	fa		plx				plx
.af62	18		clc				clc
.af63					Comp_LessEqualCont:
.af63	08		php				php
.af64	ca		dex				dex
.af65	38		sec				sec
.af66	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.af69	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.af6c	bd 01 07	lda $0701,x			lda 	highStack+1,x
.af6f	fd 00 07	sbc $0700,x			sbc 	highStack,x
.af72	50 02		bvc $af76			bvc 	_CLENoFlip 					; unsigned -> signed
.af74	49 80		eor #$80			eor 	#$80
.af76					_CLENoFlip:
.af76	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.af78	f0 b4		beq $af2e			beq 	CompCheckFlip
.af7a	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.af7c	80 b0		bra $af2e			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.af7e					DivInteger16:
.af7e	fa		plx				plx
.af7f	20 85 af	jsr $af85			jsr 	IntegerDivide
.af82	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.af85					IntegerDivide:
.af85	ca		dex				dex
.af86	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.af89	1d 01 07	ora $0701,x			ora 	highStack+1,x
.af8c	d0 14		bne $afa2			bne 	_BFDOkay
.af8e	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>af91	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>af99	20 42 59 20 5a 45 52 4f 00
.afa2					_BFDOkay:
.afa2	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.afa4	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.afa6	64 10		stz $10				stz 	SignCount 					; Count of signs.
.afa8	20 e4 af	jsr $afe4			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.afab	e8		inx				inx
.afac	20 e4 af	jsr $afe4			jsr 	CheckIntegerNegate
.afaf	ca		dex				dex
.afb0	5a		phy				phy 								; Y is the counter
.afb1	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.afb3					_BFDLoop:
.afb3	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.afb6	3e 00 07	rol $0700,x			rol 	highStack,x
.afb9	26 04		rol $04				rol 	zTemp1
.afbb	26 05		rol $05				rol 	zTemp1+1
.afbd	38		sec				sec
.afbe	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.afc0	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.afc3	48		pha				pha
.afc4	a5 05		lda $05				lda 	zTemp1+1
.afc6	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.afc9	90 0f		bcc $afda			bcc 	_BFDNoAdd
.afcb	85 05		sta $05				sta 	zTemp1+1
.afcd	68		pla				pla
.afce	85 04		sta $04				sta 	zTemp1+0
.afd0	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.afd3	09 01		ora #$01			ora 	#1
.afd5	9d 00 06	sta $0600,x			sta 	lowStack,x
.afd8	80 01		bra $afdb			bra 	_BFDNext
.afda					_BFDNoAdd:
.afda	68		pla				pla 								; Throw away the intermediate calculations
.afdb					_BFDNext:
.afdb	88		dey				dey
.afdc	d0 d5		bne $afb3			bne 	_BFDLoop
.afde	7a		ply				ply 								; restore Y
.afdf	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.afe1	b0 07		bcs $afea			bcs		IntegerNegateAlways 		; negate the result
.afe3	60		rts				rts
.afe4					CheckIntegerNegate:
.afe4	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.afe7	30 01		bmi $afea			bmi 	IntegerNegateAlways 		; if so negate it
.afe9	60		rts				rts
.afea					IntegerNegateAlways:
.afea	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.afec	4c 47 b0	jmp $b047			jmp 	Unary_Negate
.afef					ModInteger16:
.afef	fa		plx				plx
.aff0	20 85 af	jsr $af85			jsr 	IntegerDivide
.aff3	a5 04		lda $04				lda 	zTemp1
.aff5	9d 00 06	sta $0600,x			sta 	lowStack,x
.aff8	a5 05		lda $05				lda 	zTemp1+1
.affa	9d 00 07	sta $0700,x			sta 	highStack,x
.affd	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.b000					MulInteger16:
.b000	fa		plx				plx
.b001	ca		dex				dex
.b002	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.b005	85 04		sta $04				sta 	zTemp1
.b007	bd 00 07	lda $0700,x			lda 	highStack,x
.b00a	85 05		sta $05				sta 	zTemp1+1
.b00c	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.b00f	9e 00 07	stz $0700,x			stz 	highStack,x
.b012					_BFMMultiply:
.b012	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.b014	29 01		and #$01			and 	#1
.b016	f0 13		beq $b02b			beq 	_BFMNoAdd
.b018	18		clc				clc 								; add old tos to current tos.
.b019	bd 00 06	lda $0600,x			lda		lowStack,x
.b01c	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.b01f	9d 00 06	sta $0600,x			sta 	lowStack,x
.b022	bd 00 07	lda $0700,x			lda		highStack,x
.b025	7d 01 07	adc $0701,x			adc 	highStack+1,x
.b028	9d 00 07	sta $0700,x			sta 	highStack,x
.b02b					_BFMNoAdd:
.b02b	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.b02e	3e 01 07	rol $0701,x			rol 	highStack+1,x
.b031	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.b033	66 04		ror $04				ror 	zTemp1+0
.b035	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.b037	05 05		ora $05				ora 	zTemp1+1
.b039	d0 d7		bne $b012			bne 	_BFMMultiply
.b03b	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.b03e					Unary_Absolute:
.b03e	fa		plx				plx
.b03f	bd 00 07	lda $0700,x			lda 	highStack,x
.b042	30 04		bmi $b048			bmi 	Unary_Negate_Code
.b044	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b047					Unary_Negate:
.b047	fa		plx				plx
.b048					Unary_Negate_Code:
.b048	38		sec				sec
.b049	a9 00		lda #$00			lda		#0
.b04b	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.b04e	9d 00 06	sta $0600,x			sta 	lowStack,x
.b051	a9 00		lda #$00			lda		#0
.b053	fd 00 07	sbc $0700,x			sbc 	highStack,x
.b056	9d 00 07	sta $0700,x			sta 	highStack,x
.b059	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b05c					Unary_Not:
.b05c	fa		plx				plx
.b05d	bd 00 06	lda $0600,x			lda 	lowStack,x
.b060	49 ff		eor #$ff			eor 	#$FF
.b062	9d 00 06	sta $0600,x			sta 	lowStack,x
.b065	bd 00 07	lda $0700,x			lda 	highStack,x
.b068	49 ff		eor #$ff			eor 	#$FF
.b06a	9d 00 07	sta $0700,x			sta 	highStack,x
.b06d	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b070					Unary_Increment:
.b070	fa		plx				plx
.b071	fe 00 06	inc $0600,x			inc 	lowStack,x
.b074	d0 03		bne $b079			bne 	_UIExit
.b076	fe 00 07	inc $0700,x			inc 	highStack,x
.b079					_UIExit:
.b079	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b07c					Unary_Decrement:
.b07c	fa		plx				plx
.b07d	bd 00 06	lda $0600,x			lda 	lowStack,x
.b080	d0 03		bne $b085			bne 	_UDNoBorrow
.b082	de 00 07	dec $0700,x			dec 	highStack,x
.b085					_UDNoBorrow:
.b085	de 00 06	dec $0600,x			dec 	lowStack,x
.b088	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b08b					Unary_BSwap:
.b08b	fa		plx				plx
.b08c	bd 00 06	lda $0600,x			lda 	lowStack,x
.b08f	48		pha				pha
.b090	bd 00 07	lda $0700,x			lda 	highStack,x
.b093	9d 00 06	sta $0600,x			sta 	lowStack,x
.b096	68		pla				pla
.b097	9d 00 07	sta $0700,x			sta 	highStack,x
.b09a	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b09d					Unary_Shl:
.b09d	fa		plx				plx
.b09e	1e 00 06	asl $0600,x			asl 	lowStack,x
.b0a1	3e 00 07	rol $0700,x			rol 	highStack,x
.b0a4	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b0a7					Unary_Shr:
.b0a7	fa		plx				plx
.b0a8	5e 00 07	lsr $0700,x			lsr 	highStack,x
.b0ab	7e 00 06	ror $0600,x			ror 	lowStack,x
.b0ae	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b0b1					Unary_Sgn:
.b0b1	fa		plx				plx
.b0b2	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.b0b5	10 0a		bpl $b0c1			bpl 	_USNotNeg
.b0b7	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.b0b9	9d 00 06	sta $0600,x			sta 	lowStack,x
.b0bc	9d 00 07	sta $0700,x			sta 	highStack,x
.b0bf	80 10		bra $b0d1			bra 	_USExit
.b0c1					_USNotNeg:
.b0c1	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.b0c4	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.b0c7	9e 00 07	stz $0700,x			stz 	highStack,x
.b0ca	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.b0cc	f0 03		beq $b0d1			beq 	_USExit
.b0ce	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.b0d1					_USExit:
.b0d1	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b0d4					Random_Handler:
.b0d4	fa		plx				plx
.b0d5	a5 15		lda $15				lda 	randomSeed
.b0d7	05 16		ora $16				ora 	randomSeed+1
.b0d9	d0 08		bne $b0e3			bne 	_RH_NoInit
.b0db	a9 7c		lda #$7c			lda 	#$7C
.b0dd	85 15		sta $15				sta 	randomSeed
.b0df	a9 a1		lda #$a1			lda 	#$A1
.b0e1	85 16		sta $16				sta 	randomSeed+1
.b0e3					_RH_NoInit:
.b0e3	a5 15		lda $15				lda 	randomSeed
.b0e5	4a		lsr a		        lsr		a
.b0e6	26 16		rol $16		        rol 	randomSeed+1
.b0e8	90 02		bcc $b0ec	        bcc 	_RH_NoEor
.b0ea	49 b4		eor #$b4	        eor 	#$B4
.b0ec					_RH_NoEor:
.b0ec	85 15		sta $15		        sta 	randomSeed
.b0ee	45 16		eor $16		        eor 	randomSeed+1
.b0f0	e8		inx		        inx
.b0f1	9d 00 07	sta $0700,x	        sta 	highStack,x
.b0f4	a5 15		lda $15		        lda 	randomSeed
.b0f6	9d 00 06	sta $0600,x	        sta 	lowStack,x
.b0f9	4c 86 a2	jmp $a286			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.b0fc					Command_Call:
.b0fc	fa		plx				plx
.b0fd	20 b3 a5	jsr $a5b3			jsr 	StackPushPosition 				; save stack position
.b100	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.b102	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b105	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.b107	85 02		sta $02				sta 	zTemp0
.b109	c8		iny				iny
.b10a	b1 00		lda ($00),y			lda 	(codePtr),y
.b10c	85 03		sta $03				sta 	zTemp0+1
.b10e	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.b110	85 00		sta $00				sta 	codePtr
.b112	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.b114	85 01		sta $01				sta 	codePtr+1
.b116	a0 01		ldy #$01			ldy 	#1
.b118					_CCSearch:
.b118	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.b11a	f0 2d		beq $b149			beq		_CCFail
.b11c	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.b11e	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.b120	f0 0d		beq $b12f			beq 	_CCCheckMSB
.b122	18		clc				clc 									; forward to next line.
.b123	b2 00		lda ($00)			lda 	(codePtr)
.b125	65 00		adc $00				adc 	codePtr
.b127	85 00		sta $00				sta 	codePtr
.b129	90 ed		bcc $b118			bcc 	_CCSearch
.b12b	e6 01		inc $01				inc 	codePtr+1
.b12d	80 e9		bra $b118			bra 	_CCSearch
.b12f					_CCCheckMSB:
.b12f	c8		iny				iny 									; get MSB, keeping Y as 1
.b130	b1 00		lda ($00),y			lda 	(codePtr),y
.b132	88		dey				dey
.b133	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.b135	d0 e1		bne $b118			bne 	_CCSearch
.b137	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.b139	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.b13b	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.b13d	d0 0a		bne $b149			bne 	_CCFail
.b13f	c8		iny				iny 									; get the length of this.
.b140	b1 00		lda ($00),y			lda 	(codePtr),y
.b142	18		clc				clc
.b143	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.b145	a8		tay				tay
.b146	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b149					_CCFail:
.b149	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b14c	43 41 4c 4c 3f 00				.text 	"CALL?",0
.b152					Command_Return:
.b152	fa		plx				plx
.b153	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.b155	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b158	90 0f		bcc $b169			bcc 	_CRFail
.b15a	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.b15c	20 d0 a5	jsr $a5d0			jsr 	StackRestorePosition
.b15f	c8		iny				iny
.b160	c8		iny				iny
.b161	a9 04		lda #$04			lda 	#4 								; pop off stack
.b163	20 ca a5	jsr $a5ca			jsr 	StackPop
.b166	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b169					_CRFail:
.b169	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b16c	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.b172					Structure_If:
.b172	fa		plx				plx
.b173	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.b175	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b178	18		clc				clc
.b179	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.b17c	1d 00 07	ora $0700,x			ora 	highStack,x
.b17f	ca		dex				dex 									; drop TOS
.b180	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.b182	d0 0e		bne $b192			bne 	_SIFNoSkip 						; at this level.
.b184	da		phx				phx
.b185	a9 37		lda #$37			lda 	#KWD_ELSE
.b187	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.b189	20 bf b1	jsr $b1bf			jsr 	StructSkipForward
.b18c	fa		plx				plx 									; restore X
.b18d	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.b18f	d0 01		bne $b192			bne 	_SIFNoSkip 						; clause.
.b191	c8		iny				iny
.b192					_SIFNoSkip:
.b192	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b195					Structure_Else:
.b195	fa		plx				plx
.b196	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b198	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b19b	90 0b		bcc $b1a8			bcc 	SIFail
.b19d	da		phx				phx 									; got here by executing IF clause so skip
.b19e	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.b1a0	aa		tax				tax
.b1a1	20 bf b1	jsr $b1bf			jsr 	StructSkipForward
.b1a4	fa		plx				plx
.b1a5	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b1a8					SIFail:
.b1a8	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b1ab	49 46 3f 00					.text 	"IF?",0
.b1af					Structure_Endif:
.b1af	fa		plx				plx
.b1b0	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b1b2	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b1b5	90 f1		bcc $b1a8			bcc 	SIFail
.b1b7	a9 01		lda #$01			lda 	#1 								; throw it.
.b1b9	20 ca a5	jsr $a5ca			jsr 	StackPop
.b1bc	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b1bf					StructSkipForward:
.b1bf	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.b1c1	86 03		stx $03				stx 	zTemp0+1
.b1c3	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.b1c5					_SSFLoop:
.b1c5	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.b1c7	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.b1c9	d0 08		bne $b1d3			bne		_SSFFail
.b1cb	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.b1cd	f0 17		beq $b1e6			beq 	_SSFEnd
.b1cf	c5 03		cmp $03				cmp 	zTemp0+1
.b1d1	f0 13		beq $b1e6			beq 	_SSFEnd
.b1d3					_SSFFail:
.b1d3	20 e7 b1	jsr $b1e7			jsr 	AdvanceInCode 					; skip over in code.
.b1d6	b0 ed		bcs $b1c5			bcs 	_SSFLoop 						; if not end of program, keep going.
.b1d8	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b1db	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>b1e3	45 3f 00
.b1e6					_SSFEnd:
.b1e6	60		rts				rts
.b1e7					AdvanceInCode:
.b1e7	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.b1e9	f0 28		beq $b213			beq 	_AICEndOfLine 					; end of line.
.b1eb	c8		iny				iny 									; advance one.
.b1ec	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.b1ee	90 10		bcc $b200			bcc 	_AICControl
.b1f0	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.b1f2	b0 0a		bcs $b1fe			bcs 	_AICExit
.b1f4	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.b1f6	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.b1f8	90 04		bcc $b1fe			bcc 	_AICExit
.b1fa	c6 04		dec $04				dec 	zTemp1
.b1fc	c6 04		dec $04				dec 	zTemp1
.b1fe					_AICExit:
.b1fe	38		sec				sec
.b1ff	60		rts				rts
.b200					_AICControl:
.b200	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.b202	f0 0b		beq $b20f			beq 	_AICThree
.b204	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.b206	f0 07		beq $b20f			beq 	_AICThree
.b208	98		tya				tya										; skip over a string/comment/define.
.b209	38		sec				sec
.b20a	71 00		adc ($00),y			adc 	(codePtr),y
.b20c	a8		tay				tay
.b20d	38		sec				sec
.b20e	60		rts				rts
.b20f					_AICThree:
.b20f	c8		iny				iny
.b210	c8		iny				iny
.b211	38		sec				sec
.b212	60		rts				rts
.b213					_AICEndOfLine:
.b213	18		clc				clc 									; forward to next line.
.b214	b2 00		lda ($00)			lda 	(codePtr)
.b216	65 00		adc $00				adc 	codePtr
.b218	85 00		sta $00				sta 	codePtr
.b21a	90 02		bcc $b21e			bcc 	_AICNoCarry
.b21c	e6 01		inc $01				inc 	codePtr+1
.b21e					_AICNoCarry:
.b21e	a0 03		ldy #$03			ldy 	#3 								; start of new line
.b220	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.b222	d0 da		bne $b1fe			bne 	_AICExit
.b224	18		clc				clc 									; program end.
.b225	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.b226					Struct_Repeat:
.b226	fa		plx				plx
.b227	20 b3 a5	jsr $a5b3			jsr 	StackPushPosition 				; save stack position
.b22a	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.b22c	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b22f	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b232					Struct_Until:
.b232	fa		plx				plx
.b233	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.b235	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b238	90 1b		bcc $b255			bcc 	_SUFail
.b23a	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.b23d	1d 00 07	ora $0700,x			ora 	highStack,x
.b240	ca		dex				dex
.b241	09 00		ora #$00			ora 	#0
.b243	f0 08		beq $b24d			beq 	_SULoopBack 					; if so keep going.
.b245	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.b247	20 ca a5	jsr $a5ca			jsr 	StackPop
.b24a	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b24d					_SULoopBack:
.b24d	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b24f	20 d0 a5	jsr $a5d0			jsr 	StackRestorePosition
.b252	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b255					_SUFail:
.b255	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b258	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>b260	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.b262					Struct_For:
.b262	fa		plx				plx
.b263	18		clc				clc
.b264	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.b267	49 ff		eor #$ff			eor 	#$FF
.b269	69 01		adc #$01			adc 	#1
.b26b	08		php				php
.b26c	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b26f	bd 00 07	lda $0700,x			lda 	highStack,x
.b272	49 ff		eor #$ff			eor 	#$FF
.b274	28		plp				plp
.b275	69 00		adc #$00			adc 	#0
.b277	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b27a	ca		dex				dex 									; throw TOS
.b27b	20 b3 a5	jsr $a5b3			jsr 	StackPushPosition 				; save stack position
.b27e	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.b280	20 a3 a5	jsr $a5a3			jsr 	StackPushByte
.b283	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b286					Struct_Index:
.b286	fa		plx				plx
.b287	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b289	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b28c	90 43		bcc $b2d1			bcc 	SNFail
.b28e	e8		inx				inx 									; new stack entry
.b28f	5a		phy				phy
.b290	a0 04		ldy #$04			ldy 	#4 								; access index value
.b292	b1 0e		lda ($0e),y			lda 	(iStack),y
.b294	49 ff		eor #$ff			eor 	#$FF
.b296	9d 00 07	sta $0700,x			sta 	highStack,x
.b299	c8		iny				iny
.b29a	b1 0e		lda ($0e),y			lda 	(iStack),y
.b29c	49 ff		eor #$ff			eor 	#$FF
.b29e	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2a1	7a		ply				ply 									; restore code pointer
.b2a2	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b2a5					Struct_Next:
.b2a5	fa		plx				plx
.b2a6	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b2a8	20 c2 a5	jsr $a5c2			jsr 	StackCheckTop
.b2ab	90 24		bcc $b2d1			bcc 	SNFail
.b2ad	5a		phy				phy 									; save code position
.b2ae	a0 05		ldy #$05			ldy 	#5 								; bump the count
.b2b0	b1 0e		lda ($0e),y			lda 	(iStack),y
.b2b2	1a		inc a				inc 	a
.b2b3	91 0e		sta ($0e),y			sta 	(iStack),y
.b2b5	d0 11		bne $b2c8			bne 	_SNLoopBack
.b2b7	88		dey				dey
.b2b8	b1 0e		lda ($0e),y			lda 	(iStack),y
.b2ba	1a		inc a				inc 	a
.b2bb	91 0e		sta ($0e),y			sta 	(iStack),y
.b2bd	d0 09		bne $b2c8			bne 	_SNLoopBack  					; non-zero loop back.
.b2bf	7a		ply				ply 									; restore code position.
.b2c0	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.b2c2	20 ca a5	jsr $a5ca			jsr 	StackPop
.b2c5	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b2c8					_SNLoopBack:
.b2c8	7a		ply				ply 									; restore code position, being junked anyway.
.b2c9	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b2cb	20 d0 a5	jsr $a5d0			jsr 	StackRestorePosition
.b2ce	4c 86 a2	jmp $a286			jmp 	ExecuteLoop
.b2d1					SNFail:
.b2d1	20 1a a2	jsr $a21a			jsr 	ErrorHandler
>b2d4	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
