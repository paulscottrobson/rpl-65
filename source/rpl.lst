
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Sat Nov 16 07:46:23 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					iStack:			.word ?						; stack pointer
>000c					signCount:		.byte ? 					; divide sign count.
>000d					allocPtr:		.word ? 					; memory allocation pointer (down)
>000f					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0011					randomSeed:		.word ? 					; random number seed
>0013					prefixCharacter:.byte ?						; char to print before listed element.
>0014					breakCount:		.byte ? 					; counter avoids repeated break checks
>0015					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	0f e8 03 01 00 60 22 c2			.byte	$0f,$e8,$03,$01,$00,$60,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$f2,$03,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$fc,$03,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$06,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$42,$04,$0b,$00,$08,$10,$04,$01,$50,$00,$08,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$88,$04,$0b,$00,$05,$24,$04,$0b,$00,$05,$2e,$04,$40,$00,$1e,$38,$04,$05,$06,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$42,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$4c,$04,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$60,$04,$39,$00,$15,$56,$04,$05,$04,$d2,$d3,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$60,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$6a,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$74,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$7e,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$88,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$92,$04,$a0,$02,$60,$04,$00,$1c,$9c,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$a6,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ba,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$c4,$04,$01,$51,$00,$02,$60,$04,$00,$05,$ce,$04,$39,$00
>1008	c1 cc cc cd c5 ed 00 0b f2 03 a0 22 c3 cf d5 ce
>1018	f4 00 0d fc 03 01 8e 00 22 e1 01 d2 ff 25 00 12
>1028	06 04 c3 cf d5 ce f4 08 38 02 38 04 02 42 04 0b
>1038	00 08 10 04 01 50 00 08 00 12 1a 04 c3 cf d5 ce
>1048	f4 08 38 02 38 04 02 88 04 0b 00 05 24 04 0b 00
>1058	05 2e 04 40 00 1e 38 04 05 06 d3 c5 cc c5 c3 f4
>1068	2d 2d 2d 2d c2 c1 cc cc cd c5 ed 0f 22 c2 c1 cc
>1078	ec 39 00 29 42 04 05 09 c2 c1 cc cc db c9 ce c9
>1088	f4 30 27 01 50 00 0e 22 c2 c1 cc ec 23 80 24 30
>1098	27 bc 0e 22 c2 c1 cc ec 23 81 24 00 2d 4c 04 02
>10a8	56 04 22 c2 c1 cc ec 23 82 24 02 56 04 22 c2 c1
>10b8	cc ec 23 83 24 30 87 11 2a 22 c2 c1 cc ec 23 84
>10c8	24 01 51 00 02 60 04 39 00 15 56 04 05 04 d2 d3
>10d8	c7 ee 30 81 11 06 81 37 01 ff ff 09 39 00 0f 60
>10e8	04 05 09 c2 c1 cc cc db c4 d2 c1 f7 00 10 6a 04
>10f8	c2 c1 cc ec 23 80 24 2d 01 20 9f 1d 00 0f 74 04
>1108	c2 c1 cc ec 23 81 24 01 21 9f 1d 00 19 7e 04 90
>1118	01 22 9f 1d 01 23 9f 1d c2 c1 cc ec 23 84 24 01
>1128	23 9f 1d 39 00 0f 88 04 05 09 c2 c1 cc cc db cd
>1138	cf d6 e5 00 08 92 04 a0 02 60 04 00 1c 9c 04 c2
>1148	c1 cc ec 23 80 24 c2 c1 cc ec 23 82 24 0f 33 22
>1158	c2 c1 cc ec 23 80 24 00 1f a6 04 33 01 50 00 1a
>1168	36 80 19 12 06 c2 c1 cc ec 23 82 24 28 22 c2 c1
>1178	cc ec 23 82 24 09 00 1c b0 04 c2 c1 cc ec 23 81
>1188	24 c2 c1 cc ec 23 83 24 0f 33 22 c2 c1 cc ec 23
>1198	81 24 00 1d ba 04 33 bc 1a 36 80 19 12 06 c2 c1
>11a8	cc ec 23 83 24 28 22 c2 c1 cc ec 23 83 24 09 00
>11b8	0a c4 04 01 51 00 02 60 04 00 05 ce 04 39 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 30 a3	jsr $a330			jsr 	ExternInitialise			; set up external stuff.
.a006	a2 61		ldx #$61			ldx 	#BootPrompt & $FF 			; print start up.
.a008	a0 a0		ldy #$a0			ldy 	#BootPrompt >> 8
.a00a	20 51 a2	jsr $a251			jsr 	PrintStringXY
.a00d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.a00f	a0 8f		ldy #$8f			ldy 	#(HighMemory-ProgramStart) >> 8
.a011	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.a014	a2 7e		ldx #$7e			ldx 	#BootPrompt2 & $FF
.a016	a0 a0		ldy #$a0			ldy 	#BootPrompt2 >> 8
.a018	20 51 a2	jsr $a251			jsr 	PrintStringXY
.a01b					WarmStart:
.a01b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a01d	9a		txs				txs
.a01e	20 85 a3	jsr $a385			jsr 	ExternInput					; input a line.
.a021	ad 00 08	lda $0800			lda 	InputBuffer 				; get the first character.
.a024	48		pha				pha
.a025	20 c4 a6	jsr $a6c4			jsr 	TokeniseInputBuffer 		; tokenise it
.a028	68		pla				pla
.a029	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.a02b	f0 0d		beq $a03a			beq 	ExecuteLine
.a02d	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.a030	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.a032	f0 0d		beq $a041			beq 	LineNumber
.a034	29 c0		and #$c0			and 	#$C0
.a036	c9 80		cmp #$80			cmp 	#$80
.a038	f0 07		beq $a041			beq 	LineNumber
.a03a					ExecuteLine:
.a03a	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.a03c	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.a03e	4c 70 a2	jmp $a270			jmp 	ExecuteFromXY
.a041					LineNumber:
.a041	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.a044	a2 00		ldx #$00			ldx 	#0
.a046	a0 04		ldy #$04			ldy 	#4
.a048	38		sec				sec
.a049	e9 80		sbc #$80			sbc 	#$80
.a04b	c9 40		cmp #$40			cmp 	#$40
.a04d	90 08		bcc $a057			bcc 	_HaveLineNumber
.a04f	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.a052	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.a055	a0 06		ldy #$06			ldy 	#6
.a057					_HaveLineNumber:
.a057	48		pha				pha 								; a fudge. Because you use
.a058	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.a05b	c9 3b		cmp #$3b			cmp 	#KWD_LIST 					; this to be executed and not
.a05d	f0 db		beq $a03a			beq 	ExecuteLine 				; to be code.
.a05f	68		pla				pla
>a060	ff						.byte 	$FF
.a061					BootPrompt:
>a061	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (16-NOV-19) ***",13,13
>a069	36 35 20 28 31 36 2d 4e 4f 56 2d 31 39 29 20 2a
>a079	2a 2a 0d 0d
>a07d	00						.byte 	0
.a07e					BootPrompt2:
>a07e	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>a086	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a092					KeywordText:
>a092	01 ff					.text $01,$ff                          ; $0000 %eol
>a094	01 ff					.text $01,$ff                          ; $0001 %const
>a096	01 ff					.text $01,$ff                          ; $0002 %call
>a098	01 ff					.text $01,$ff                          ; $0003 %comment
>a09a	01 ff					.text $01,$ff                          ; $0004 %qstring
>a09c	01 ff					.text $01,$ff                          ; $0005 %define
>a09e	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a0a1	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a0a8	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a0ac	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a0b2	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a0b8	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a0bd	01 aa					.text $01,$aa                          ; $000c *
>a0bf	01 af					.text $01,$af                          ; $000d /
>a0c1	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a0c5	01 ab					.text $01,$ab                          ; $000f +
>a0c7	01 ad					.text $01,$ad                          ; $0010 -
>a0c9	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a0cd	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a0d0	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a0d4	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a0d8	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a0dc	01 bd					.text $01,$bd                          ; $0016 =
>a0de	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a0e1	01 be					.text $01,$be                          ; $0018 >
>a0e3	01 bc					.text $01,$bc                          ; $0019 <
>a0e5	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a0e8	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a0eb	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a0ee	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a0f1	01 c0					.text $01,$c0                          ; $001e @
>a0f3	01 a1					.text $01,$a1                          ; $001f !
>a0f5	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a0f8	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a0fe	01 de					.text $01,$de                          ; $0022 ^
>a100	01 db					.text $01,$db                          ; $0023 [
>a102	01 dd					.text $01,$dd                          ; $0024 ]
>a104	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a108	01 bf					.text $01,$bf                          ; $0026 ?
>a10a	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a10e	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a115	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a119	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a11c	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a11f	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a125	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a128	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a12b	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a12f	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a133	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a137	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a13c	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a140	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a144	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a149	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a14e	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a153	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a159	01 bb					.text $01,$bb                          ; $0039 ;
>a15b	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a162	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a167	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a16b	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a16f	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a174	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a178	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a17c	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a181	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a186	00					.byte 0
>a187						.align 2
.a188					DispatchHandler:
>a188	f1 a2					.word ExecuteNextLine          ; $0000 %eol
>a18a	07 a3					.word LongConstant             ; $0001 %const
>a18c	cd ae					.word Command_Call             ; $0002 %call
>a18e	f1 a2					.word ExecuteComment           ; $0003 %comment
>a190	18 a3					.word StringConstant           ; $0004 %qstring
>a192	0e a2					.word SyntaxError              ; $0005 %define
>a194	43 af					.word Structure_If             ; $0006 if
>a196	f7 af					.word Struct_Repeat            ; $0007 repeat
>a198	33 b0					.word Struct_For               ; $0008 for
>a19a	80 af					.word Structure_Endif          ; $0009 endif
>a19c	03 b0					.word Struct_Until             ; $000a until
>a19e	76 b0					.word Struct_Next              ; $000b next
>a1a0	d1 ad					.word MulInteger16             ; $000c *
>a1a2	4f ad					.word DivInteger16             ; $000d /
>a1a4	c0 ad					.word ModInteger16             ; $000e mod
>a1a6	3b ac					.word Stack_Add                ; $000f +
>a1a8	53 ac					.word Stack_Sub                ; $0010 -
>a1aa	6b ac					.word Stack_And                ; $0011 and
>a1ac	99 ac					.word Stack_Or                 ; $0012 or
>a1ae	82 ac					.word Stack_Xor                ; $0013 xor
>a1b0	b0 ac					.word Stack_Shl                ; $0014 shl
>a1b2	b4 ac					.word Stack_Shr                ; $0015 shr
>a1b4	e5 ac					.word Comp_Equal               ; $0016 =
>a1b6	e9 ac					.word Comp_NotEqual            ; $0017 <>
>a1b8	32 ad					.word Comp_Greater             ; $0018 >
>a1ba	0d ad					.word Comp_Less                ; $0019 <
>a1bc	11 ad					.word Comp_GreaterEqual        ; $001a >=
>a1be	2e ad					.word Comp_LessEqual           ; $001b <=
>a1c0	34 aa					.word Mem_Peek                 ; $001c c@
>a1c2	66 aa					.word Mem_Poke                 ; $001d c!
>a1c4	4a aa					.word Mem_WPeek                ; $001e @
>a1c6	7b aa					.word Mem_WPoke                ; $001f !
>a1c8	99 aa					.word Mem_DWPoke               ; $0020 d!
>a1ca	b3 aa					.word Mem_Alloc                ; $0021 alloc
>a1cc	41 ab					.word Command_Store            ; $0022 ^
>a1ce	0e a2					.word SyntaxError              ; $0023 [
>a1d0	0e a2					.word SyntaxError              ; $0024 ]
>a1d2	d2 ab					.word Command_Sys              ; $0025 sys
>a1d4	f4 ab					.word Command_DumpStack        ; $0026 ?
>a1d6	0f ae					.word Unary_Absolute           ; $0027 abs
>a1d8	18 ae					.word Unary_Negate             ; $0028 negate
>a1da	2d ae					.word Unary_Not                ; $0029 not
>a1dc	41 ae					.word Unary_Increment          ; $002a ++
>a1de	4d ae					.word Unary_Decrement          ; $002b --
>a1e0	5c ae					.word Unary_BSwap              ; $002c bswap
>a1e2	6e ae					.word Unary_Shl                ; $002d <<
>a1e4	78 ae					.word Unary_Shr                ; $002e >>
>a1e6	82 ae					.word Unary_Sgn                ; $002f sgn
>a1e8	a5 ae					.word Random_Handler           ; $0030 rnd
>a1ea	e1 aa					.word Stack_Empty              ; $0031 clr
>a1ec	e7 aa					.word Stack_Drop               ; $0032 drop
>a1ee	ec aa					.word Stack_Dup                ; $0033 dup
>a1f0	fd aa					.word Stack_Nip                ; $0034 nip
>a1f2	0e ab					.word Stack_Over               ; $0035 over
>a1f4	1f ab					.word Stack_Swap               ; $0036 swap
>a1f6	66 af					.word Structure_Else           ; $0037 else
>a1f8	57 b0					.word Struct_Index             ; $0038 index
>a1fa	23 af					.word Command_Return           ; $0039 ;
>a1fc	bb ab					.word Command_Assert           ; $003a assert
>a1fe	6c a8					.word Cmd_List                 ; $003b list
>a200	80 ab					.word Command_New              ; $003c new
>a202	87 ab					.word Command_Old              ; $003d old
>a204	b1 ab					.word Command_Stop             ; $003e stop
>a206	6c a2					.word ExecuteProgram           ; $003f run
>a208	ad ab					.word Command_End              ; $0040 end
>a20a	0e a2					.word SyntaxError              ; $0041 save
>a20c	0e a2					.word SyntaxError              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a20e					SyntaxError:
.a20e	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a211	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a218					ErrorHandler:
.a218	fa		plx				plx 								; pull address off.
.a219	7a		ply				ply
.a21a	e8		inx				inx 								; point to message
.a21b	d0 01		bne $a21e			bne 	_EHNoCarry
.a21d	c8		iny				iny
.a21e					_EHNoCarry:
.a21e	20 51 a2	jsr $a251			jsr 	PrintStringXY 				; print string at XY
.a221	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a223	f0 13		beq $a238			beq 	_EHNoLine
.a225	a2 40		ldx #$40			ldx 	#_EHMessage & $FF 			; print " AT "
.a227	a0 a2		ldy #$a2			ldy 	#_EHMessage >> 8
.a229	20 51 a2	jsr $a251			jsr 	PrintStringXY
.a22c	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a22e	b1 00		lda ($00),y			lda 	(codePtr),y
.a230	aa		tax				tax
.a231	c8		iny				iny
.a232	b1 00		lda ($00),y			lda 	(codePtr),y
.a234	a8		tay				tay
.a235	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.a238					_EHNoLine:
.a238	a9 0d		lda #$0d			lda 	#13
.a23a	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a23d	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a240					_EHMessage:
>a240	20 41 54 20 00					.text	" AT ",0
.a245					PrintIntegerUnsigned:
.a245	20 7f a5	jsr $a57f			jsr 	IntToString
.a248	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a24a	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a24c	20 51 a2	jsr $a251			jsr 	PrintStringXY
.a24f	98		tya				tya
.a250	60		rts				rts
.a251					PrintStringXY:
.a251	86 02		stx $02				stx 	zTemp0
.a253	84 03		sty $03				sty 	zTemp0+1
.a255	a0 00		ldy #$00			ldy 	#0
.a257	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a259	f0 06		beq $a261			beq 	_PSExit
.a25b	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a25e	c8		iny				iny
.a25f	80 f6		bra $a257			bra 	_PSLoop
.a261	60		rts		_PSExit:rts
.a262					PrintCharacter:
.a262	48		pha				pha
.a263	da		phx				phx
.a264	5a		phy				phy
.a265	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a268	7a		ply				ply
.a269	fa		plx				plx
.a26a	68		pla				pla
.a26b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a26c					ExecuteProgram:
.a26c	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.a26e	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.a270					ExecuteFromXY:
.a270	20 7a a4	jsr $a47a			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a273	20 b2 a4	jsr $a4b2			jsr 	StackReset 					; reset the CPU stack.
.a276	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a278	80 0a		bra $a284			bra 	ExecuteLoop
.a27a					ShortConstant:
.a27a	c8		iny				iny 								; skip short const
.a27b	e8		inx				inx 								; space on stack
.a27c	29 3f		and #$3f			and 	#$3F 						; the value
.a27e	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a281	9e 00 07	stz $0700,x			stz 	highStack,x
.a284					ExecuteLoop:
.a284	e6 14		inc $14				inc 	breakCount 					; check break sometimes.
.a286	d0 03		bne $a28b			bne 	_EXNoBreak
.a288	20 3f a3	jsr $a33f			jsr 	ExternCheckBreak
.a28b					_EXNoBreak:
.a28b	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a28d	f0 58		beq $a2e7			beq 	_ELUnderflow
.a28f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a291	30 07		bmi $a29a			bmi 	_ELNotToken
.a293	c8		iny				iny 								; skip the token
.a294	da		phx				phx 								; save X on the stack
.a295	0a		asl a				asl 	a 							; double the token, put into X
.a296	aa		tax				tax
.a297	7c 88 a1	jmp ($a188,x)			jmp 	(DispatchHandler,x)
.a29a					_ELNotToken:
.a29a	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a29c	90 dc		bcc $a27a			bcc 	ShortConstant 				; yes, it's a short constant
.a29e	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a2a0	90 1e		bcc $a2c0			bcc 	_ELNotFastVariable
.a2a2	c8		iny				iny 								; get the next token.
.a2a3	b1 00		lda ($00),y			lda 	(codePtr),y
.a2a5	88		dey				dey
.a2a6	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a2a8	f0 16		beq $a2c0			beq 	_ELNotFastVariable 			; which we can optimise.
.a2aa	5a		phy				phy 								; save Y
.a2ab	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a2ad	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a2ae	a8		tay				tay 								; access via Y
.a2af	e8		inx				inx 								; make space on the stack.
.a2b0	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a2b3	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2b6	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a2b9	9d 00 07	sta $0700,x			sta 	highStack,x
.a2bc	7a		ply				ply 								; restore code pointer
.a2bd	c8		iny				iny 								; skip variable.
.a2be	80 c4		bra $a284			bra 	ExecuteLoop
.a2c0					_ELNotFastVariable:
.a2c0	18		clc				clc									; do not autocreate if not found.
.a2c1	20 ca a5	jsr $a5ca			jsr 	VariableFind				; find the variable.
.a2c4	90 14		bcc $a2da			bcc 	_ELUnknown
.a2c6	20 20 a4	jsr $a420			jsr 	IndexCheck
.a2c9	5a		phy				phy 								; copy to stack
.a2ca	e8		inx				inx
.a2cb	b2 02		lda ($02)			lda 	(zTemp0)
.a2cd	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2d0	a0 01		ldy #$01			ldy 	#1
.a2d2	b1 02		lda ($02),y			lda 	(zTemp0),y
.a2d4	9d 00 07	sta $0700,x			sta 	highStack,x
.a2d7	7a		ply				ply
.a2d8	80 aa		bra $a284			bra 	ExecuteLoop
.a2da					_ELUnknown:
>a2da	ff						.byte 	$FF
.a2db	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a2de	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a2e6	00
.a2e7					_ELUnderflow:
.a2e7	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a2ea	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a2f1					ExecuteNextLine:
.a2f1					ExecuteComment:
.a2f1	fa		plx				plx
.a2f2	18		clc				clc 								; skip forward
.a2f3	b2 00		lda ($00)			lda 	(codePtr)
.a2f5	18		clc				clc
.a2f6	65 00		adc $00				adc 	codePtr
.a2f8	85 00		sta $00				sta 	codePtr
.a2fa	90 02		bcc $a2fe			bcc 	_ENLNoCarry
.a2fc	e6 01		inc $01				inc 	codePtr+1
.a2fe					_ENLNoCarry:
.a2fe	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a300	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a302	d0 80		bne $a284			bne 	ExecuteLoop
.a304	4c ad ab	jmp $abad			jmp	 	Command_End 				; if zero end program.
.a307					LongConstant:
.a307	fa		plx				plx
.a308	e8		inx				inx 								; space for constant
.a309	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a30b	9d 00 06	sta $0600,x			sta 	lowStack,x
.a30e	c8		iny				iny
.a30f	b1 00		lda ($00),y			lda 	(codePtr),y
.a311	9d 00 07	sta $0700,x			sta 	highStack,x
.a314	c8		iny				iny
.a315	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.a318					StringConstant:
.a318	fa		plx				plx
.a319	e8		inx				inx
.a31a	18		clc				clc 								; copy Y + codePtr in.
.a31b	98		tya				tya
.a31c	65 00		adc $00				adc 	codePtr
.a31e	9d 00 06	sta $0600,x			sta 	lowStack,x
.a321	a5 01		lda $01				lda 	codePtr+1
.a323	69 00		adc #$00			adc 	#0
.a325	9d 00 07	sta $0700,x			sta 	highStack,x
.a328	98		tya				tya 								; add 1 + length to Y
.a329	38		sec				sec
.a32a	71 00		adc ($00),y			adc 	(codePtr),y
.a32c	a8		tay				tay
.a32d	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a330					ExternInitialise:
.a330	a9 02		lda #$02			lda 	#$02 						; set colour
.a332	8d 86 02	sta $0286			sta 	646
.a335	a9 93		lda #$93			lda 	#147 						; clear screen
.a337	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a33a	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a33c	4c 5d a3	jmp $a35d			jmp 	ExternColour
.a33f					ExternCheckBreak:
.a33f	da		phx				phx 								; make sure we keep XY
.a340	5a		phy				phy
.a341	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a344	f0 03		beq $a349			beq		_ECBExit 					; stopped
.a346	7a		ply				ply 								; restore and exit.
.a347	fa		plx				plx
.a348	60		rts				rts
.a349					_ECBExit:
.a349	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a34c	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a353					ExternPrint:
.a353	48		pha				pha
.a354	da		phx				phx
.a355	5a		phy				phy
.a356	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a359	7a		ply				ply
.a35a	fa		plx				plx
.a35b	68		pla				pla
.a35c	60		rts				rts
.a35d					ExternColour:
.a35d	48		pha				pha
.a35e	da		phx				phx
.a35f	48		pha				pha
.a360	29 08		and #$08			and 	#8
.a362	0a		asl a				asl 	a
.a363	0a		asl a				asl 	a
.a364	0a		asl a				asl 	a
.a365	0a		asl a				asl 	a
.a366	49 92		eor #$92			eor 	#$92
.a368	20 53 a3	jsr $a353			jsr 	ExternPrint
.a36b	a9 0e		lda #$0e			lda 	#14							; lower case
.a36d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a370	68		pla				pla
.a371	29 07		and #$07			and 	#7
.a373	aa		tax				tax
.a374	bd 7d a3	lda $a37d,x			lda 	_ECTable,x
.a377	20 53 a3	jsr $a353			jsr 	ExternPrint
.a37a	fa		plx				plx
.a37b	68		pla				pla
.a37c	60		rts				rts
.a37d					_ECTable:
>a37d	90						.byte 	144
>a37e	1c						.byte 	28
>a37f	1e						.byte 	30
>a380	9e						.byte 	158
>a381	1f						.byte 	31
>a382	9c						.byte 	156
>a383	9f						.byte 	159
>a384	05						.byte 	5
.a385					ExternInput:
.a385	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a387	85 02		sta $02				sta 	zTemp0
.a389	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a38b	85 03		sta $03				sta 	zTemp0+1
.a38d	a9 07		lda #$07			lda 	#COL_WHITE
.a38f	20 5d a3	jsr $a35d			jsr 	ExternColour
.a392	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a395	29 7f		and #$7f			and 	#$7F
.a397	c9 0d		cmp #$0d			cmp 	#13
.a399	f0 0a		beq $a3a5			beq 	_EIExit
.a39b	92 02		sta ($02)			sta 	(zTemp0)
.a39d	e6 02		inc $02				inc 	zTemp0
.a39f	d0 f1		bne $a392			bne 	_EIRead
.a3a1	e6 03		inc $03				inc 	zTemp0+1
.a3a3	80 ed		bra $a392			bra 	_EIRead
.a3a5	a9 00		lda #$00	_EIExit:lda 	#0
.a3a7	92 02		sta ($02)			sta 	(zTemp0)
.a3a9	a9 0d		lda #$0d			lda 	#13
.a3ab	20 53 a3	jsr $a353			jsr 	ExternPrint
.a3ae	60		rts				rts
.a3af					ExternSave:
.a3af	da		phx				phx
.a3b0	5a		phy				phy
.a3b1	85 06		sta $06				sta 	zTemp2 						; save start
.a3b3	84 07		sty $07				sty 	zTemp2+1
.a3b5	20 17 a4	jsr $a417			jsr 	EXGetLength 				; get length of file into A
.a3b8	a6 02		ldx $02				ldx 	zTemp0
.a3ba	a4 03		ldy $03				ldy 	zTemp0+1
.a3bc	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a3bf	a9 01		lda #$01			lda 	#1
.a3c1	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a3c3	a0 00		ldy #$00			ldy 	#0
.a3c5	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a3c8	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a3ca	a4 05		ldy $05				ldy 	zTemp1+1
.a3cc	a9 06		lda #$06			lda 	#zTemp2
.a3ce	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a3d1	b0 03		bcs $a3d6			bcs 	_ESSave
.a3d3	7a		ply				ply
.a3d4	fa		plx				plx
.a3d5	60		rts				rts
.a3d6					_ESSave:
.a3d6	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a3d9	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a3e1	4c 45 44 00
.a3e5					ExternLoad:
.a3e5	da		phx				phx 								; save XY
.a3e6	5a		phy				phy
.a3e7	48		pha				pha 								; save target
.a3e8	5a		phy				phy
.a3e9	20 17 a4	jsr $a417			jsr 	EXGetLength 				; get length of file into A
.a3ec	a6 02		ldx $02				ldx 	zTemp0
.a3ee	a4 03		ldy $03				ldy 	zTemp0+1
.a3f0	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a3f3	a9 01		lda #$01			lda 	#1
.a3f5	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a3f7	a0 00		ldy #$00			ldy 	#0
.a3f9	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a3fc	7a		ply				ply 								; restore target to YX and call load
.a3fd	fa		plx				plx
.a3fe	a9 00		lda #$00			lda 	#0 							; load command
.a400	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a403	b0 03		bcs $a408			bcs 	_ESLoad
.a405	7a		ply				ply
.a406	fa		plx				plx
.a407	60		rts				rts
.a408					_ESLoad:
.a408	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a40b	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a413	4c 45 44 00
.a417					EXGetLength:
.a417	a0 ff		ldy #$ff			ldy 	#255
.a419	c8		iny		_EXGL:	iny
.a41a	b1 02		lda ($02),y			lda 	(zTemp0),y
.a41c	d0 fb		bne $a419			bne 	_EXGL
.a41e	98		tya				tya
.a41f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a420					IndexCheck:
.a420	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a422	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a424	f0 01		beq $a427			beq 	_ICFound
.a426	60		rts				rts
.a427					_ICFound:
.a427	c8		iny				iny 							; get next
.a428	b1 00		lda ($00),y			lda 	(codePtr),y
.a42a	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a42c	f0 2b		beq $a459			beq 	_ICStackIndex
.a42e	38		sec				sec
.a42f	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a431	c9 40		cmp #$40			cmp 	#$40
.a433	b0 1a		bcs $a44f			bcs 	_ICError
.a435	0a		asl a				asl 	a 						; double index clear carry
.a436	5a		phy				phy 							; put into Y
.a437	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a439	48		pha				pha
.a43a	a0 01		ldy #$01			ldy 	#1
.a43c	b1 02		lda ($02),y			lda 	(zTemp0),y
.a43e	69 00		adc #$00			adc 	#0
.a440	85 03		sta $03				sta 	zTemp0+1
.a442	68		pla				pla
.a443	85 02		sta $02				sta 	zTemp0
.a445	7a		ply				ply 							; restore position.
.a446	c8		iny				iny								; skip index
.a447	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a449	c8		iny				iny
.a44a	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a44c	d0 01		bne $a44f			bne 	_ICError
.a44e	60		rts				rts
.a44f					_ICError:
.a44f	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a452	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a459					_ICStackIndex:
.a459	c8		iny				iny 							; skip the ]
.a45a	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a45d	0a		asl a				asl 	a
.a45e	85 04		sta $04				sta 	zTemp1
.a460	bd 00 07	lda $0700,x			lda 	highStack,x
.a463	2a		rol a				rol 	a
.a464	85 05		sta $05				sta 	zTemp1+1
.a466	ca		dex				dex 							; throw TOS.
.a467	5a		phy				phy
.a468	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a46a	b2 02		lda ($02)			lda 	(zTemp0)
.a46c	65 04		adc $04				adc 	zTemp1
.a46e	48		pha				pha
.a46f	b1 02		lda ($02),y			lda 	(zTemp0),y
.a471	65 05		adc $05				adc 	zTemp1+1
.a473	85 03		sta $03				sta 	zTemp0+1
.a475	68		pla				pla
.a476	85 02		sta $02				sta 	zTemp0
.a478	7a		ply				ply 							; restore pos and exit.
.a479	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a47a					ResetMemory:
.a47a	da		phx				phx									; save run address
.a47b	5a		phy				phy
.a47c	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a47e	85 0d		sta $0d				sta 	allocPtr
.a480	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a482	85 0e		sta $0e				sta 	allocPtr+1
.a484	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a486	85 0f		sta $0f				sta 	memVarPtr
.a488	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a48a	85 10		sta $10				sta 	memVarPtr+1
.a48c					_RMFindEnd:
.a48c	b2 0f		lda ($0f)			lda 	(memVarPtr)					; offset 0, found end.
.a48e	f0 0b		beq $a49b			beq 	_RMFoundEnd 				; advance to next.
.a490	18		clc				clc
.a491	65 0f		adc $0f				adc 	memVarPtr
.a493	85 0f		sta $0f				sta 	memVarPtr
.a495	90 f5		bcc $a48c			bcc 	_RMFindEnd
.a497	e6 10		inc $10				inc 	memVarPtr+1
.a499	80 f1		bra $a48c			bra 	_RMFindEnd
.a49b					_RMFoundEnd:
.a49b	e6 0f		inc $0f				inc 	memVarPtr 					; advance past last offset $00
.a49d	d0 02		bne $a4a1			bne 	_RMNoCarry
.a49f	e6 10		inc $10				inc 	memVarPtr+1
.a4a1					_RMNoCarry:
.a4a1	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a4a3					_RMEraseHash:
.a4a3	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a4a6	ca		dex				dex
.a4a7	10 fa		bpl $a4a3			bpl 	_RMEraseHash
.a4a9	7a		ply				ply 								; restore and set run address
.a4aa	fa		plx				plx
.a4ab	84 01		sty $01				sty 	codePtr+1
.a4ad	86 00		stx $00				stx 	codePtr
.a4af	a0 03		ldy #$03			ldy 	#3
.a4b1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a4b2					StackReset:
.a4b2	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a4b4	85 0a		sta $0a				sta 	iStack
.a4b6	a9 09		lda #$09			lda 	#IntStack >> 8
.a4b8	85 0b		sta $0b				sta 	iStack+1
.a4ba	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a4bc	92 0a		sta ($0a)			sta 	(iStack)
.a4be	60		rts				rts
.a4bf					StackPushByte:
.a4bf	c6 0a		dec $0a				dec 	iStack
.a4c1	92 0a		sta ($0a)			sta 	(iStack)
.a4c3	f0 01		beq $a4c6			beq 	_SPBUnderflow
.a4c5	60		rts				rts
.a4c6					_SPBUnderflow:
.a4c6	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a4c9	53 54 41 43 4b 00				.text 	"STACK",0
.a4cf					StackPushPosition:
.a4cf	98		tya				tya
.a4d0	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.a4d3	a5 01		lda $01				lda 	codePtr+1
.a4d5	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.a4d8	a5 00		lda $00				lda 	codePtr
.a4da	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.a4dd	60		rts				rts
.a4de					StackCheckTop:
.a4de	d2 0a		cmp ($0a)			cmp 	(iStack)
.a4e0	f0 02		beq $a4e4			beq 	_SCTOk
.a4e2	18		clc				clc
.a4e3	60		rts				rts
.a4e4	38		sec		_SCTOk:	sec
.a4e5	60		rts				rts
.a4e6					StackPop:
.a4e6	18		clc				clc
.a4e7	65 0a		adc $0a				adc 	iStack
.a4e9	85 0a		sta $0a				sta 	iStack
.a4eb	60		rts				rts
.a4ec					StackRestorePosition:
.a4ec	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4ee	85 00		sta $00				sta 	codePtr
.a4f0	c8		iny				iny
.a4f1	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4f3	85 01		sta $01				sta 	codePtr+1
.a4f5	c8		iny				iny
.a4f6	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4f8	a8		tay				tay
.a4f9	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a4fa					StringToInt:
.a4fa	86 08		stx $08				stx 	zTemp3 						; save string
.a4fc	84 09		sty $09				sty 	zTemp3+1
.a4fe	64 0c		stz $0c				stz 	signCount 					; signcount is the number of chars copied.
.a500	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a502	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a504	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a506	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a508	f0 03		beq $a50d			beq 	_STIConvert 				; convert from character 1, base 16.
.a50a	88		dey				dey 								; from character 0
.a50b	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a50d					_STIConvert:
.a50d	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a50f	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a511	f0 5f		beq $a572			beq 	_STIFail 					; if zero, then it has failed anyway.
.a513	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a515	64 03		stz $03				stz 	zTemp0+1
.a517					_STILoop:
.a517	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a519	c9 30		cmp #$30			cmp 	#"0"
.a51b	90 55		bcc $a572			bcc 	_STIFail
.a51d	c9 3a		cmp #$3a			cmp 	#"9"+1
.a51f	90 08		bcc $a529			bcc 	_STIOkay
.a521	c9 41		cmp #$41			cmp 	#"A"
.a523	90 4d		bcc $a572			bcc 	_STIFail
.a525	c9 47		cmp #$47			cmp 	#"F"+1
.a527	b0 49		bcs $a572			bcs 	_STIFail
.a529					_STIOkay:
.a529	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a52b	85 06		sta $06				sta 	zTemp2
.a52d	a5 03		lda $03				lda 	zTemp0+1
.a52f	85 07		sta $07				sta 	zTemp2+1
.a531	64 02		stz $02				stz 	zTemp0 						; clear result
.a533	64 03		stz $03				stz 	zTemp0+1
.a535	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a537					_STIMultiply:
.a537	8a		txa				txa 								; shift Y right into carry.
.a538	4a		lsr a				lsr 	a
.a539	aa		tax				tax
.a53a	90 0d		bcc $a549			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a53c	18		clc				clc
.a53d	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a53f	65 02		adc $02				adc 	zTemp0
.a541	85 02		sta $02				sta 	zTemp0
.a543	a5 07		lda $07				lda 	zTemp2+1
.a545	65 03		adc $03				adc 	zTemp0+1
.a547	85 03		sta $03				sta 	zTemp0+1
.a549					_STINoAdd:
.a549	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a54b	26 07		rol $07				rol 	zTemp2+1
.a54d	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a54f	d0 e6		bne $a537			bne 	_STIMultiply
.a551	38		sec				sec 								; hex adjust
.a552	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a554	c9 3a		cmp #$3a			cmp 	#58
.a556	90 03		bcc $a55b			bcc 	_STIDecimal
.a558	38		sec				sec
.a559	e9 07		sbc #$07			sbc 	#7
.a55b					_STIDecimal:
.a55b	38		sec				sec
.a55c	e9 30		sbc #$30			sbc 	#48
.a55e	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a560	b0 10		bcs $a572			bcs 	_STIFail
.a562	d8		cld				cld
.a563	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a565	85 02		sta $02				sta 	zTemp0
.a567	90 02		bcc $a56b			bcc 	_STINoCarry
.a569	e6 03		inc $03				inc 	zTemp0+1
.a56b					_STINoCarry:
.a56b	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a56d	c8		iny				iny 								; point to next
.a56e	e6 0c		inc $0c				inc 	SignCount
.a570	80 a5		bra $a517			bra 	_STILoop 					; and go round again.
.a572					_STIFail:
.a572	a5 0c		lda $0c				lda 	SignCount 					; if converted 0 charactes, fail.
.a574	f0 07		beq $a57d			beq 	_STINoConvert
.a576	98		tya				tya 								; convert count in A.
.a577	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a579	a4 03		ldy $03				ldy 	zTemp0+1
.a57b	38		sec				sec
.a57c	60		rts				rts
.a57d					_STINoConvert:
.a57d	18		clc				clc
.a57e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a57f					IntToString:
.a57f	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a581	84 03		sty $03				sty 	zTemp0+1
.a583	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a585	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a587					_ITSLoop:
.a587	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a589					_ITSSubtractLoop:
.a589	38		sec				sec
.a58a	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a58c	fd c2 a5	sbc $a5c2,x			sbc 	_ITSWords,x
.a58f	48		pha				pha
.a590	a5 03		lda $03				lda 	zTemp0+1
.a592	fd c3 a5	sbc $a5c3,x			sbc 	_ITSWords+1,x
.a595	90 09		bcc $a5a0			bcc 	_ITSEndSub 					; can't subtract any more.
.a597	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a599	68		pla				pla
.a59a	85 02		sta $02				sta 	zTemp0
.a59c	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a59e	80 e9		bra $a589			bra 	_ITSSubtractLoop
.a5a0					_ITSEndSub:
.a5a0	68		pla				pla 								; throw away the interim result
.a5a1	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a5a3	d0 04		bne $a5a9			bne 	_ITSWriteOut 				; always write it out
.a5a5	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a5a7	f0 06		beq $a5af			beq 	_ITSNext 					; suppressing leading zeros.
.a5a9					_ITSWriteOut:
.a5a9	09 30		ora #$30			ora 	#48 						; output digit.
.a5ab	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a5ae	c8		iny				iny
.a5af					_ITSNext:
.a5af	e8		inx				inx
.a5b0	e8		inx				inx
.a5b1	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a5b3	d0 d2		bne $a587			bne 	_ITSLoop 					; do the new digits
.a5b5	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a5b7	09 30		ora #$30			ora 	#48
.a5b9	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a5bc	a9 00		lda #$00			lda 	#0
.a5be	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a5c1	60		rts				rts
.a5c2					_ITSWords:
>a5c2	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a5ca					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a5ca					VariableFind:
.a5ca	da		phx				phx 								; save the stack position
.a5cb	08		php				php 								; save the create flag
.a5cc	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a5ce	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a5d0	90 10		bcc $a5e2			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a5d2	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a5d4	0a		asl a				asl 	a 							; double clear carry
.a5d5	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a5d7	85 02		sta $02				sta 	zTemp0
.a5d9	a9 0f		lda #$0f			lda		#FastVariables >>8
.a5db	85 03		sta $03				sta 	zTemp0+1
.a5dd	28		plp				plp 								; create flag is irrelevant.
.a5de	fa		plx				plx									; restore the old stack position
.a5df	c8		iny				iny 								; skip over the single identifier character
.a5e0	38		sec				sec 								; return with CS
.a5e1	60		rts				rts
.a5e2					_VFIsNotFastVariable:
.a5e2	20 b4 a6	jsr $a6b4			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a5e5	20 0f a6	jsr $a60f			jsr 	VFSearch 					; try to find the variable.
.a5e8	b0 0d		bcs $a5f7			bcs 	_VFEndSearch 				; found it, so exit
.a5ea	28		plp				plp 								; do we want autocreate
.a5eb	b0 03		bcs $a5f0			bcs 	_VFCreate
.a5ed	fa		plx				plx 								; restore stack position and return CC
.a5ee	18		clc				clc
.a5ef	60		rts				rts
.a5f0					_VFCreate:
.a5f0	20 b4 a6	jsr $a6b4			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a5f3	20 4b a6	jsr $a64b			jsr 	VFCreate 					; create a new record and link it in.
.a5f6	08		php				php 								; save a dummy P to be popped.
.a5f7					_VFEndSearch:
.a5f7	18		clc				clc 								; the data is at offset + 4
.a5f8	a5 04		lda $04				lda 	zTemp1
.a5fa	69 04		adc #$04			adc 	#4
.a5fc	85 02		sta $02				sta 	zTemp0
.a5fe	a5 05		lda $05				lda 	zTemp1+1
.a600	69 00		adc #$00			adc 	#0
.a602	85 03		sta $03				sta 	zTemp0+1
.a604	28		plp				plp 								; dump the create flag
.a605					_VFSkipExit:
.a605	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a607	c8		iny				iny
.a608	c9 e0		cmp #$e0			cmp 	#$E0
.a60a	90 f9		bcc $a605			bcc 	_VFSkipExit
.a60c	fa		plx				plx 								; restore X
.a60d	38		sec				sec
.a60e	60		rts				rts
.a60f					VFSearch:
.a60f	48		pha				pha 								; save AXY.
.a610	da		phx				phx
.a611	5a		phy				phy
.a612	98		tya				tya									; add Y to codePtr, put in zTemp2
.a613	18		clc				clc 								; so it points to the identifier.
.a614	65 00		adc $00				adc 	codePtr
.a616	85 06		sta $06				sta 	zTemp2
.a618	a5 01		lda $01				lda 	codePtr+1
.a61a	69 00		adc #$00			adc 	#0
.a61c	85 07		sta $07				sta 	zTemp2+1
.a61e					_VFSLoop:
.a61e	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a620	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a622	f0 22		beq $a646			beq 	_VFSFailed 					; failed.
.a624	aa		tax				tax 								; MSB in X
.a625	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a627	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a629	86 05		stx $05				stx 	zTemp1+1
.a62b	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a62d	b1 04		lda ($04),y			lda 	(zTemp1),y
.a62f	85 08		sta $08				sta 	zTemp3
.a631	c8		iny				iny
.a632	b1 04		lda ($04),y			lda 	(zTemp1),y
.a634	85 09		sta $09				sta 	zTemp3+1
.a636	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a638					_VFSCheckName:
.a638	c8		iny				iny
.a639	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a63b	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a63d	d0 df		bne $a61e			bne 	_VFSLoop
.a63f	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a641	90 f5		bcc $a638			bcc 	_VFSCheckName
.a643	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a644	80 01		bra $a647			bra		_VFSExit
.a646					_VFSFailed:
.a646	18		clc				clc
.a647					_VFSExit:
.a647	7a		ply				ply 								; restore registers and exit.
.a648	fa		plx				plx
.a649	68		pla				pla
.a64a	60		rts				rts
.a64b					VFCreate:
.a64b	48		pha				pha 								; save registers
.a64c	da		phx				phx
.a64d	5a		phy				phy
.a64e	18		clc				clc 								; add 6 to memVarPtr, saving its
.a64f	a5 0f		lda $0f				lda 	memVarPtr 					; address in zTemp0 as we go.
.a651	85 02		sta $02				sta 	zTemp0
.a653	69 06		adc #$06			adc 	#6
.a655	85 0f		sta $0f				sta 	memVarPtr
.a657	a5 10		lda $10				lda 	memVarPtr+1
.a659	85 03		sta $03				sta 	zTemp0+1
.a65b	69 00		adc #$00			adc 	#0
.a65d	85 10		sta $10				sta 	memVarPtr+1
.a65f	c5 0e		cmp $0e				cmp 	allocPtr+1 					; out of memory ?
.a661	f0 46		beq $a6a9			beq 	_VFCMemory
.a663	98		tya				tya 								; work out identifier address
.a664	18		clc				clc
.a665	65 00		adc $00				adc 	codePtr
.a667	48		pha				pha
.a668	c8		iny				iny
.a669	a5 01		lda $01				lda 	codePtr+1
.a66b	69 00		adc #$00			adc 	#0
.a66d	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.a66f	b0 0b		bcs $a67c			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.a671	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a674	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.a67c					_VFCInProgram:
.a67c	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a67e	91 02		sta ($02),y			sta 	(zTemp0),y
.a680	88		dey				dey
.a681	68		pla				pla
.a682	91 02		sta ($02),y			sta 	(zTemp0),y
.a684	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a686	a9 00		lda #$00			lda 	#0
.a688	91 02		sta ($02),y			sta 	(zTemp0),y
.a68a	c8		iny				iny
.a68b	91 02		sta ($02),y			sta 	(zTemp0),y
.a68d	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a68f	b2 04		lda ($04)			lda 	(zTemp1)
.a691	92 02		sta ($02)			sta 	(zTemp0)
.a693	b1 04		lda ($04),y			lda 	(zTemp1),y
.a695	91 02		sta ($02),y			sta 	(zTemp0),y
.a697	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a699	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a69b	a5 03		lda $03				lda 	zTemp0+1
.a69d	91 04		sta ($04),y			sta 	(zTemp1),y
.a69f	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a6a1	a5 02		lda $02				lda 	zTemp0
.a6a3	85 04		sta $04				sta 	zTemp1
.a6a5	7a		ply				ply
.a6a6	fa		plx				plx
.a6a7	68		pla				pla
.a6a8	60		rts				rts
.a6a9					_VFCMemory:
.a6a9	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a6ac	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a6b4					VFSetupHashPointer:
.a6b4	48		pha				pha
.a6b5	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a6b7	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a6b9	0a		asl a				asl 	a 							; double it, also clears carry
.a6ba	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a6bc	85 04		sta $04				sta 	zTemp1
.a6be	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a6c0	85 05		sta $05				sta 	zTemp1+1
.a6c2	68		pla				pla
.a6c3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.a6c4					TokeniseInputBuffer:
.a6c4	48		pha				pha
.a6c5	da		phx				phx
.a6c6	5a		phy				phy
.a6c7	64 15		stz $15				stz 	TokenOffset					; reset index into TokenBuffer
.a6c9	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.a6cc	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.a6ce	20 30 a7	jsr $a730			jsr 	TokWriteToken
.a6d1	20 30 a7	jsr $a730			jsr 	TokWriteToken
.a6d4	20 30 a7	jsr $a730			jsr 	TokWriteToken
.a6d7	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.a6d9					_TIBForward:
.a6d9	e8		inx				inx
.a6da	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a6dd	d0 fa		bne $a6d9			bne 	_TIBForward
.a6df					_TIBBackward:
.a6df	ca		dex				dex 								; back one.
.a6e0	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.a6e2	f0 48		beq $a72c			beq 	_TIBExit					; return empty buffer
.a6e4	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a6e7	c9 20		cmp #$20			cmp 	#" "
.a6e9	f0 f4		beq $a6df			beq 	_TIBBackward
.a6eb	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.a6ee	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.a6f0					_TIBMainLoop:
.a6f0	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.a6f3	f0 37		beq $a72c			beq 	_TIBExit 					; done the buffer if zero.
.a6f5	e8		inx				inx
.a6f6	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.a6f8	f0 f6		beq $a6f0			beq 	_TIBMainLoop
.a6fa	ca		dex				dex 								; undo the last inx.
.a6fb	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.a6fd	f0 08		beq $a707			beq 	_TIBConstant
.a6ff	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.a701	90 09		bcc $a70c			bcc 	_TIBNotConstant
.a703	c9 3a		cmp #$3a			cmp 	#"9"+1
.a705	b0 05		bcs $a70c			bcs 	_TIBNotConstant
.a707					_TIBConstant:
.a707	20 61 a7	jsr $a761			jsr 	TOKConvertConstant
.a70a	80 e4		bra $a6f0			bra 	_TIBMainLoop
.a70c					_TIBNotConstant:
.a70c	c9 3a		cmp #$3a			cmp 	#":"						; definition
.a70e	d0 05		bne $a715			bne 	_TIBNotDefinition
.a710	20 b3 a7	jsr $a7b3			jsr 	TOKConvertDefinition
.a713	80 db		bra $a6f0			bra 	_TIBMainLoop
.a715					_TIBNotDefinition:
.a715	c9 27		cmp #$27			cmp 	#"'"
.a717	f0 04		beq $a71d			beq 	_TIBIsCommentString
.a719	c9 22		cmp #$22			cmp 	#'"'
.a71b	d0 05		bne $a722			bne 	_TIBNotCommentString
.a71d					_TIBIsCommentString:
.a71d	20 db a7	jsr $a7db			jsr 	TOKConvertCommentString
.a720	80 ce		bra $a6f0			bra 	_TIBMainLoop
.a722					_TIBNotCommentString:
.a722	20 22 a8	jsr $a822			jsr 	TOKCheckIsToken 			; check if a token.
.a725	b0 c9		bcs $a6f0			bcs 	_TIBMainLoop
.a727	20 b4 a7	jsr $a7b4			jsr 	TOKConvertIdentifierOnly
.a72a	80 c4		bra $a6f0			bra 	_TIBMainLoop
.a72c					_TIBExit:
.a72c	7a		ply				ply
.a72d	fa		plx				plx
.a72e	68		pla				pla
.a72f	60		rts				rts
.a730					TOKWriteToken:
.a730	da		phx				phx
.a731	a6 15		ldx $15				ldx 	TokenOffset
.a733	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.a736	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.a739	e6 15		inc $15				inc 	TokenOffset
.a73b	fa		plx				plx
.a73c	60		rts				rts
.a73d					TOKFixUpLast:
.a73d	da		phx				phx
.a73e	a6 15		ldx $15				ldx 	TokenOffset
.a740	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.a743	09 e0		ora #$e0			ora 	#$E0
.a745	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.a748	fa		plx				plx
.a749	60		rts				rts
.a74a					TOKConvertIdentifier:
.a74a	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.a74c	f0 0f		beq $a75d			beq 	_TKCIDot
.a74e	38		sec				sec 								; A-Z -> 1-27
.a74f	e9 40		sbc #$40			sbc 	#64
.a751	f0 08		beq $a75b			beq 	_TKCIFail
.a753	c9 1b		cmp #$1b			cmp 	#27
.a755	b0 04		bcs $a75b			bcs 	_TKCIFail
.a757	09 c0		ora #$c0			ora 	#$C0 						; fix up
.a759	38		sec				sec
.a75a	60		rts				rts
.a75b					_TKCIFail:
.a75b	18		clc				clc
.a75c	60		rts				rts
.a75d					_TKCIDot:
.a75d	a9 db		lda #$db			lda 	#$C0+27
.a75f	38		sec				sec
.a760	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.a761					TOKConvertConstant:
.a761	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.a763	da		phx				phx 								; save X position
.a764	20 fa a4	jsr $a4fa			jsr 	StringToInt 				; try to convert
.a767	90 40		bcc $a7a9			bcc 	_TKCCError
.a769	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.a76b	86 02		stx $02				stx 	zTemp0
.a76d	85 04		sta $04				sta 	zTemp1 						; save count
.a76f	68		pla				pla 								; restore X position, add the count
.a770	18		clc				clc
.a771	65 04		adc $04				adc 	zTemp1
.a773	aa		tax				tax
.a774	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.a777	c9 2d		cmp #$2d			cmp 	#"-"
.a779	d0 0e		bne $a789			bne 	_TKCCNotNegative
.a77b	e8		inx				inx 								; consume the -
.a77c	38		sec				sec
.a77d	a9 00		lda #$00			lda 	#0 							; negate the constant.
.a77f	e5 02		sbc $02				sbc 	zTemp0
.a781	85 02		sta $02				sta 	zTemp0
.a783	a9 00		lda #$00			lda 	#0
.a785	e5 03		sbc $03				sbc 	zTemp0+1
.a787	85 03		sta $03				sta 	zTemp0+1
.a789					_TKCCNotNegative:
.a789	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.a78b	d0 0c		bne $a799			bne 	_TKCCLongConstant
.a78d	a5 02		lda $02				lda 	zTemp0
.a78f	c9 40		cmp #$40			cmp 	#$40
.a791	b0 06		bcs $a799			bcs 	_TKCCLongConstant
.a793	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.a795	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a798	60		rts				rts
.a799					_TKCCLongConstant:
.a799	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.a79b	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a79e	a5 02		lda $02				lda 	zTemp0
.a7a0	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a7a3	a5 03		lda $03				lda 	zTemp0+1
.a7a5	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a7a8	60		rts				rts
.a7a9					_TKCCError:
.a7a9	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a7ac	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.a7b3					TOKConvertDefinition:
.a7b3	e8		inx				inx 								; skip over :
.a7b4					TOKConvertIdentifierOnly:
.a7b4	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get first and check there's at least one.
.a7b7	20 4a a7	jsr $a74a			jsr 	TOKConvertIdentifier
.a7ba	90 10		bcc $a7cc			bcc 	_TKCDFail
.a7bc					_TKCDLoop:
.a7bc	20 30 a7	jsr $a730			jsr 	TOKWriteToken 				; write last one out
.a7bf	e8		inx				inx									; skip over it, get next and check
.a7c0	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a7c3	20 4a a7	jsr $a74a			jsr 	TOKConvertIdentifier
.a7c6	b0 f4		bcs $a7bc			bcs 	_TKCDLoop 					; keep going while identifier present.
.a7c8	20 3d a7	jsr $a73d			jsr 	TOKFixUpLast 				; set bit for last character.
.a7cb	60		rts				rts
.a7cc					_TKCDFail:
.a7cc	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a7cf	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>a7d7	45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.a7db					TOKConvertCommentString:
.a7db	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.a7dd	f0 06		beq $a7e5			beq 	_TKCCSComment
.a7df	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.a7e1	a0 22		ldy #$22			ldy 	#'"'						; match character
.a7e3	80 04		bra $a7e9			bra 	_TKCCSContinue
.a7e5					_TKCCSComment:
.a7e5	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.a7e7	a0 00		ldy #$00			ldy 	#0 							; match character
.a7e9					_TKCCSContinue:
.a7e9	20 30 a7	jsr $a730			jsr 	TOKWriteToken 				; write initial token
.a7ec	e8		inx				inx 								; skip over ' or "
.a7ed	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.a7ef	a0 00		ldy #$00			ldy 	#0 							; count of characters
.a7f1	da		phx				phx 								; save start position
.a7f2					_TKCCSFindSize:
.a7f2	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.a7f5	c5 02		cmp $02				cmp 	zTemp0
.a7f7	f0 10		beq $a809			beq 	_TKCCSFoundEnd
.a7f9	e8		inx				inx 								; bump pos, count
.a7fa	c8		iny				iny
.a7fb	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.a7fd	d0 f3		bne $a7f2			bne 	_TKCCSFindSize
.a7ff	20 18 a2	jsr $a218			jsr 	ErrorHandler
>a802	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.a809					_TKCCSFoundEnd:
.a809	98		tya				tya 								; length of element in Y
.a80a	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a80d	fa		plx				plx 								; restore start position and copy out
.a80e					_TKCCSCopyOut:
.a80e	c0 00		cpy #$00			cpy 	#0 							; complete ?
.a810	f0 0a		beq $a81c			beq 	_TKCCSExit
.a812	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a815	20 30 a7	jsr $a730			jsr 	TOKWriteToken
.a818	e8		inx				inx
.a819	88		dey				dey
.a81a	80 f2		bra $a80e			bra 	_TKCCSCopyOut
.a81c					_TKCCSExit:
.a81c	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.a81e	f0 01		beq $a821			beq 	_TKCSSNotComment
.a820	e8		inx				inx
.a821					_TKCSSNotComment:
.a821	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.a822					TOKCheckIsToken:
.a822	a9 92		lda #$92			lda 	#(KeywordText) & $FF
.a824	85 02		sta $02				sta 	zTemp0
.a826	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a828	85 03		sta $03				sta 	zTemp0+1
.a82a	64 04		stz $04				stz 	zTemp1 						; best match length
.a82c	64 06		stz $06				stz 	zTemp2 						; current token.
.a82e					_TCTLoop:
.a82e	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.a830	da		phx				phx 								; save start
.a831					_TCTCompare:
.a831	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.a833	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.a836	e8		inx				inx 								; bump both pointers.
.a837	c8		iny				iny
.a838	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.a839	d0 0e		bne $a849			bne 	_TCTNext 					; different, go to next.
.a83b	90 f4		bcc $a831			bcc 	_TCTCompare 				; still comparing.
.a83d	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.a83f	c5 04		cmp $04				cmp 	zTemp1						; best so far
.a841	90 06		bcc $a849			bcc 	_TCTNext 					; if not, skip to next.
.a843	85 04		sta $04				sta 	zTemp1 						; new best score
.a845	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.a847	85 07		sta $07				sta 	zTemp2+1
.a849					_TCTNext:
.a849	fa		plx				plx 								; restore start position.
.a84a	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.a84c	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.a84e	38		sec				sec
.a84f	65 02		adc $02				adc 	zTemp0
.a851	85 02		sta $02				sta 	zTemp0
.a853	90 02		bcc $a857			bcc		_TCTNoCarry
.a855	e6 03		inc $03				inc 	zTemp0+1
.a857					_TCTNoCarry:
.a857	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.a859	d0 d3		bne $a82e			bne 	_TCTLoop 					; no, check the next keyword.
.a85b	18		clc				clc
.a85c	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.a85e	f0 0b		beq $a86b			beq 	_TCTExit
.a860	8a		txa				txa 								; add that length to the input index.
.a861	18		clc				clc
.a862	65 04		adc $04				adc 	zTemp1
.a864	aa		tax				tax
.a865	a5 07		lda $07				lda 	zTemp2+1 					; token number
.a867	20 30 a7	jsr $a730			jsr 	TOKWriteToken 				; write it out.
.a86a	38		sec				sec 								; set carry and exit
.a86b					_TCTExit:
.a86b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a86c					Cmd_List:
.a86c	fa		plx				plx
.a86d	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a86f	64 07		stz $07				stz 	zTemp2+1
.a871	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.a873	f0 0b		beq $a880			beq 	_CLNoStart
.a875	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.a878	85 06		sta $06				sta 	zTemp2
.a87a	bd 00 07	lda $0700,x			lda 	highStack,x
.a87d	85 07		sta $07				sta 	zTemp2+1
.a87f	ca		dex				dex
.a880					_CLNoStart:
.a880	a9 02		lda #$02			lda 	#COL_GREEN
.a882	20 5d a3	jsr $a35d			jsr 	ExternColour
.a885					_CLNoStartLine:
.a885	a9 00		lda #$00			lda 	#(programStart) & $FF
.a887	85 00		sta $00				sta 	codePtr
.a889	a9 10		lda #$10			lda 	#(programStart) >> 8
.a88b	85 01		sta $01				sta 	codePtr+1
.a88d					_CLILoop:
.a88d	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a88f	f0 24		beq $a8b5			beq 	_CLIEnd
.a891	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a893	38		sec				sec
.a894	b1 00		lda ($00),y			lda 	(codePtr),y
.a896	e5 06		sbc $06				sbc 	zTemp2
.a898	c8		iny				iny
.a899	b1 00		lda ($00),y			lda 	(codePtr),y
.a89b	e5 07		sbc $07				sbc 	zTemp2+1
.a89d	90 09		bcc $a8a8			bcc 	_CLISkip
.a89f	da		phx				phx
.a8a0	20 b8 a8	jsr $a8b8			jsr 	ListCurrent 				; list the line.
.a8a3	fa		plx				plx
.a8a4	c6 08		dec $08				dec 	zTemp3 						; done all lines
.a8a6	f0 0d		beq $a8b5			beq 	_CLIEnd
.a8a8					_CLISkip:
.a8a8	18		clc				clc
.a8a9	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a8ab	65 00		adc $00				adc 	codePtr
.a8ad	85 00		sta $00				sta 	codePtr
.a8af	90 dc		bcc $a88d			bcc 	_CLILoop
.a8b1	e6 01		inc $01				inc 	codePtr+1
.a8b3	80 d8		bra $a88d			bra 	_CLILoop
.a8b5					_CLIEnd:
.a8b5	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a8b8					ListCurrent:
.a8b8	a0 01		ldy #$01			ldy 	#1							; print line#
.a8ba	b1 00		lda ($00),y			lda 	(codePtr),y
.a8bc	aa		tax				tax
.a8bd	c8		iny				iny
.a8be	b1 00		lda ($00),y			lda 	(codePtr),y
.a8c0	a8		tay				tay
.a8c1	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.a8c4	a8		tay				tay
.a8c5					_LCPadOut:
.a8c5	a9 20		lda #$20			lda 	#' '
.a8c7	20 53 a3	jsr $a353			jsr 	ExternPrint
.a8ca	c8		iny				iny
.a8cb	c0 06		cpy #$06			cpy 	#6
.a8cd	d0 f6		bne $a8c5			bne 	_LCPadOut
.a8cf	a0 03		ldy #$03			ldy 	#3 							; start here
.a8d1	64 13		stz $13				stz 	PrefixCharacter				; no prefix
.a8d3					_LCLoop:
.a8d3	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.a8d5	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a8d7	f0 0b		beq $a8e4			beq 	_LCNoPrefix
.a8d9	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.a8db	f0 07		beq $a8e4			beq 	_LCNoPrefix
.a8dd	a5 13		lda $13				lda 	PrefixCharacter 			; output prefix, reset to space
.a8df	f0 03		beq $a8e4			beq		_LCNoPrefix
.a8e1	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a8e4					_LCNoPrefix:
.a8e4	a9 20		lda #$20			lda 	#32
.a8e6	85 13		sta $13				sta 	PrefixCharacter
.a8e8	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.a8ea	f0 13		beq $a8ff			beq 	_LCExit
.a8ec	10 4d		bpl $a93b			bpl 	_LCIsToken 					; +ve goto token.
.a8ee	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.a8f0	b0 13		bcs $a905			bcs 	_LCIsIdentifier
.a8f2	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.a8f4	aa		tax				tax
.a8f5	c8		iny				iny
.a8f6	5a		phy				phy 								; push pos
.a8f7	a0 00		ldy #$00			ldy 	#0
.a8f9	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.a8fc	7a		ply				ply
.a8fd	80 d4		bra $a8d3			bra 	_LCLoop
.a8ff					_LCExit:
.a8ff	a9 0d		lda #$0d			lda 	#13
.a901	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a904	60		rts				rts
.a905					_LCIsIdentifier:
.a905					_LCIdentLoop:
.a905	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.a907	20 f1 a9	jsr $a9f1			jsr 	ListPrintIDChar
.a90a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.a90c	c8		iny				iny
.a90d	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.a90f	b0 c2		bcs $a8d3			bcs 	_LCLoop 					; if so, do next
.a911	80 f2		bra $a905			bra 	_LCIdentLoop				; if not loop round
.a913					_LCConstant:
.a913	c8		iny				iny
.a914	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.a916	aa		tax				tax
.a917	c8		iny				iny 								; get MSB into Y
.a918	b1 00		lda ($00),y			lda 	(codePtr),y
.a91a	c8		iny				iny
.a91b	5a		phy				phy
.a91c	a8		tay				tay
.a91d	5a		phy				phy 								; save sign
.a91e	10 0c		bpl $a92c			bpl 	_LCNotNegative
.a920	98		tya				tya 								; YX = |YX|
.a921	49 ff		eor #$ff			eor 	#$FF
.a923	a8		tay				tay
.a924	8a		txa				txa
.a925	49 ff		eor #$ff			eor 	#$FF
.a927	aa		tax				tax
.a928	e8		inx				inx
.a929	d0 01		bne $a92c			bne 	_LCNotNegative
.a92b	c8		iny				iny
.a92c					_LCNotNegative:
.a92c					_LCPrintYX:
.a92c	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.a92f	68		pla				pla 								; restore sign
.a930	10 05		bpl $a937			bpl 	_LCNoTrail
.a932	a9 2d		lda #$2d			lda 	#"-"
.a934	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a937					_LCNoTrail:
.a937	7a		ply				ply 								; restore Y
.a938	4c d3 a8	jmp $a8d3			jmp 	_LCLoop
.a93b					_LCIsToken:
.a93b	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.a93d	f0 d4		beq $a913			beq 	_LCConstant
.a93f	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.a941	90 3e		bcc $a981			bcc 	_LCControl
.a943					_LCIsKeywordToken:
.a943	85 02		sta $02				sta 	zTemp0 						; save token #
.a945	a9 92		lda #$92			lda 	#(KeywordText) & $FF
.a947	85 04		sta $04				sta 	zTemp1
.a949	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a94b	85 05		sta $05				sta 	zTemp1+1
.a94d	5a		phy				phy 								; save code offset
.a94e					_LCForward:
.a94e	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.a950	f0 0f		beq $a961			beq 	_LCFoundToken
.a952	c6 02		dec $02				dec 	zTemp0						; dec count.
.a954	38		sec				sec 								; go to next keyword.
.a955	b2 04		lda ($04)			lda 	(zTemp1)
.a957	65 04		adc $04				adc 	zTemp1
.a959	85 04		sta $04				sta 	zTemp1
.a95b	90 f1		bcc $a94e			bcc 	_LCForward
.a95d	e6 05		inc $05				inc 	zTemp1+1
.a95f	80 ed		bra $a94e			bra 	_LCForward
.a961					_LCFoundToken:
.a961	a0 01		ldy #$01			ldy 	#1 							; output the token.
.a963					_LCOutToken:
.a963	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.a965	29 7f		and #$7f			and 	#$7F
.a967	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a96a	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.a96c	c8		iny				iny
.a96d	0a		asl a				asl 	a
.a96e	90 f3		bcc $a963			bcc 	_LCOutToken
.a970	7a		ply				ply 								; restore code offset
.a971	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.a973	c8		iny				iny
.a974	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.a976	f0 04		beq $a97c			beq 	_LCCancelPrefix
.a978	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a97a	d0 02		bne $a97e			bne 	_LCGoLoop
.a97c					_LCCancelPrefix:
.a97c	64 13		stz $13				stz 	PrefixCharacter
.a97e					_LCGoLoop:
.a97e	4c d3 a8	jmp $a8d3			jmp 	_LCLoop
.a981					_LCControl:
.a981	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.a983	f0 2c		beq $a9b1			beq 	_LCDecodeCall
.a985	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a987	f0 1d		beq $a9a6			beq 	_LCDecodeDefine
.a989	5a		phy				phy 								; save Y
.a98a	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.a98c	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.a98e	f0 02		beq $a992			beq 	_LCDecodeString
.a990	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.a992					_LCDecodeString
.a992	98		tya				tya
.a993	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a996	7a		ply				ply 								; restore Y pos
.a997	48		pha				pha 								; save end character on stack.
.a998	20 d1 a9	jsr $a9d1			jsr 	ListPrintCodeIdentifier
.a99b	68		pla				pla 								; last character
.a99c	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.a99e	f0 03		beq $a9a3			beq 	_LCEDNoQuote
.a9a0	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a9a3					_LCEDNoQuote:
.a9a3	4c d3 a8	jmp $a8d3			jmp 	_LCLoop
.a9a6					_LCDecodeDefine:
.a9a6	a9 3a		lda #$3a			lda 	#":"
.a9a8	20 62 a2	jsr $a262			jsr 	PrintCharacter
.a9ab	20 d1 a9	jsr $a9d1			jsr 	ListPrintCodeIdentifier
.a9ae	4c d3 a8	jmp $a8d3			jmp 	_LCLoop
.a9b1					_LCDecodeCall:
.a9b1	c8		iny				iny 								; get line number into XA
.a9b2	b1 00		lda ($00),y			lda 	(codePtr),y
.a9b4	48		pha				pha
.a9b5	c8		iny				iny
.a9b6	b1 00		lda ($00),y			lda 	(codePtr),y
.a9b8	c8		iny				iny
.a9b9	aa		tax				tax
.a9ba	68		pla				pla
.a9bb	20 03 aa	jsr $aa03			jsr 	ListFindLine 				; find that line.
.a9be	90 10		bcc $a9d0			bcc 	_LCNoDefinition
.a9c0	5a		phy				phy
.a9c1	a0 03		ldy #$03			ldy 	#3 							; look at first character
.a9c3	b1 02		lda ($02),y			lda 	(zTemp0),y
.a9c5	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a9c7	d0 07		bne $a9d0			bne 	_LCNoDefinition 			; not define
.a9c9	20 db a9	jsr $a9db			jsr 	ListPrintIdentifier
.a9cc	7a		ply				ply
.a9cd	4c d3 a8	jmp $a8d3			jmp 	_LCLoop
.a9d0					_LCNoDefinition:
>a9d0	ff						.byte 	$FF 						; definition is missing.
.a9d1					ListPrintCodeIdentifier:
.a9d1	48		pha				pha 								; copy codePtr -> zTemp0
.a9d2	a5 00		lda $00				lda 	codePtr
.a9d4	85 02		sta $02				sta 	zTemp0
.a9d6	a5 01		lda $01				lda 	codePtr+1
.a9d8	85 03		sta $03				sta 	zTemp0+1
.a9da	68		pla				pla
.a9db					ListPrintIdentifier:
.a9db	48		pha				pha
.a9dc	da		phx				phx
.a9dd	c8		iny				iny 								; skip over the type
.a9de	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.a9e0	aa		tax				tax
.a9e1					_LPILoop:
.a9e1	c8		iny				iny
.a9e2	e0 00		cpx #$00			cpx 	#0
.a9e4	f0 08		beq $a9ee			beq 	_LPIExit
.a9e6	b1 02		lda ($02),y			lda 	(zTemp0),y
.a9e8	20 f1 a9	jsr $a9f1			jsr 	ListPrintIDChar
.a9eb	ca		dex				dex
.a9ec	80 f3		bra $a9e1			bra 	_LPILoop
.a9ee					_LPIExit:
.a9ee	fa		plx				plx
.a9ef	68		pla				pla
.a9f0	60		rts				rts
.a9f1					ListPrintIDChar:
.a9f1	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.a9f3	10 0a		bpl $a9ff			bpl	 	_LCNotDot
.a9f5	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.a9f7	09 40		ora #$40			ora 	#$40 						; ASCII except .
.a9f9	c9 5b		cmp #$5b			cmp 	#$40+27
.a9fb	d0 02		bne $a9ff			bne 	_LCNotDot
.a9fd	a9 2e		lda #$2e			lda 	#"."
.a9ff					_LCNotDot:
.a9ff	20 62 a2	jsr $a262			jsr 	PrintCharacter
.aa02	60		rts				rts
.aa03					ListFindLine:
.aa03	5a		phy				phy
.aa04	86 05		stx $05				stx 	zTemp1+1
.aa06	85 04		sta $04				sta 	zTemp1
.aa08	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.aa0a	85 02		sta $02				sta 	zTemp0
.aa0c	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aa0e	85 03		sta $03				sta 	zTemp0+1
.aa10					_LFLSearch:
.aa10	18		clc				clc									; reached the end.
.aa11	b2 02		lda ($02)			lda 	(zTemp0)
.aa13	f0 1d		beq $aa32			beq 	_LFLExit 					; exit with CC
.aa15	a0 01		ldy #$01			ldy 	#1
.aa17	a5 04		lda $04				lda 	zTemp1
.aa19	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.aa1b	d0 07		bne $aa24			bne 	_LFLNext
.aa1d	c8		iny				iny
.aa1e	a5 05		lda $05				lda 	zTemp1+1
.aa20	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.aa22	f0 0d		beq $aa31			beq 	_LFLFound
.aa24					_LFLNext:
.aa24	18		clc				clc
.aa25	b2 02		lda ($02)			lda 	(zTemp0)
.aa27	65 02		adc $02				adc 	zTemp0
.aa29	85 02		sta $02				sta 	zTemp0
.aa2b	90 e3		bcc $aa10			bcc 	_LFLSearch
.aa2d	e6 03		inc $03				inc 	zTemp0+1
.aa2f	80 df		bra $aa10			bra 	_LFLSearch
.aa31					_LFLFound:
.aa31	38		sec				sec
.aa32					_LFLExit:
.aa32	7a		ply				ply
.aa33	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.aa34					Mem_Peek:
.aa34	fa		plx				plx
.aa35	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa38	85 02		sta $02				sta 	zTemp0
.aa3a	bd 00 07	lda $0700,x			lda 	highStack,x
.aa3d	85 03		sta $03				sta 	zTemp0+1
.aa3f	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.aa41	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.aa44	9e 00 07	stz $0700,x			stz 	highStack,x
.aa47	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aa4a					Mem_WPeek:
.aa4a	fa		plx				plx
.aa4b	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa4e	85 02		sta $02				sta 	zTemp0
.aa50	bd 00 07	lda $0700,x			lda 	highStack,x
.aa53	85 03		sta $03				sta 	zTemp0+1
.aa55	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.aa57	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.aa5a	5a		phy				phy 								; read msb
.aa5b	a0 01		ldy #$01			ldy 	#1
.aa5d	b1 02		lda ($02),y			lda 	(zTemp0),y
.aa5f	7a		ply				ply
.aa60	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.aa63	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aa66					Mem_Poke:
.aa66	fa		plx				plx
.aa67	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa6a	85 02		sta $02				sta 	zTemp0
.aa6c	bd 00 07	lda $0700,x			lda 	highStack,x
.aa6f	85 03		sta $03				sta 	zTemp0+1
.aa71	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aa74	92 02		sta ($02)			sta 	(zTemp0)
.aa76	ca		dex				dex
.aa77	ca		dex				dex
.aa78	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aa7b					Mem_WPoke:
.aa7b	fa		plx				plx
.aa7c	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa7f	85 02		sta $02				sta 	zTemp0
.aa81	bd 00 07	lda $0700,x			lda 	highStack,x
.aa84	85 03		sta $03				sta 	zTemp0+1
.aa86	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aa89	92 02		sta ($02)			sta 	(zTemp0)
.aa8b	5a		phy				phy
.aa8c	a0 01		ldy #$01			ldy 	#1
.aa8e	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aa91	91 02		sta ($02),y			sta 	(zTemp0),y
.aa93	7a		ply				ply
.aa94	ca		dex				dex
.aa95	ca		dex				dex
.aa96	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aa99					Mem_DWPoke:
.aa99	fa		plx				plx
.aa9a	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa9d	85 02		sta $02				sta 	zTemp0
.aa9f	bd 00 07	lda $0700,x			lda 	highStack,x
.aaa2	85 03		sta $03				sta 	zTemp0+1
.aaa4	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aaa7	92 02		sta ($02)			sta 	(zTemp0)
.aaa9	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aaac	92 02		sta ($02)			sta 	(zTemp0)
.aaae	ca		dex				dex
.aaaf	ca		dex				dex
.aab0	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aab3					Mem_Alloc:
.aab3	fa		plx				plx
.aab4	38		sec				sec 								; subtract count from alloc ptr
.aab5	a5 0d		lda $0d				lda 	allocPtr
.aab7	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.aaba	85 0d		sta $0d				sta 	allocPtr
.aabc	48		pha				pha 								; save low.
.aabd	a5 0e		lda $0e				lda 	allocPtr+1
.aabf	fd 00 07	sbc $0700,x			sbc 	highStack,x
.aac2	85 0e		sta $0e				sta 	allocPtr+1
.aac4	90 10		bcc $aad6			bcc 	_MAError 					; borrow ?
.aac6	c5 10		cmp $10				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.aac8	90 0c		bcc $aad6			bcc 	_MAError
.aaca	f0 0a		beq $aad6			beq 	_MAError
.aacc	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.aacf	68		pla				pla
.aad0	9d 00 06	sta $0600,x			sta 	lowStack,x
.aad3	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aad6					_MAError:
.aad6	20 18 a2	jsr $a218			jsr 	ErrorHandler
>aad9	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.aae1					Stack_Empty:
.aae1	fa		plx				plx
.aae2	a2 00		ldx #$00			ldx 	#0
.aae4	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aae7					Stack_Drop:
.aae7	fa		plx				plx
.aae8	ca		dex				dex
.aae9	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aaec					Stack_Dup:
.aaec	fa		plx				plx
.aaed	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.aaf0	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.aaf3	bd 00 07	lda $0700,x			lda 	highStack,x
.aaf6	9d 01 07	sta $0701,x			sta 	highStack+1,x
.aaf9	e8		inx				inx 								; bump stack pointer
.aafa	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aafd					Stack_Nip:
.aafd	fa		plx				plx
.aafe	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.ab01	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.ab04	bd 00 07	lda $0700,x			lda 	highStack,x
.ab07	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.ab0a	ca		dex				dex 								; drop tos
.ab0b	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ab0e					Stack_Over:
.ab0e	fa		plx				plx
.ab0f	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.ab12	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.ab15	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.ab18	9d 01 07	sta $0701,x			sta 	highStack+1,x
.ab1b	e8		inx				inx 							; bump stack pointer
.ab1c	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ab1f					Stack_Swap:
.ab1f	fa		plx				plx
.ab20	5a		phy				phy
.ab21	bd 00 06	lda $0600,x			lda 	lowStack,x
.ab24	a8		tay				tay
.ab25	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.ab28	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab2b	98		tya				tya
.ab2c	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.ab2f	bd 00 07	lda $0700,x			lda 	highStack,x
.ab32	a8		tay				tay
.ab33	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.ab36	9d 00 07	sta $0700,x			sta 	highStack,x
.ab39	98		tya				tya
.ab3a	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.ab3d	7a		ply				ply
.ab3e	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.ab41					Command_Store:
.ab41	fa		plx				plx
.ab42	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.ab44	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.ab46	90 1f		bcc $ab67			bcc 	_CSLongVariable
.ab48	c8		iny				iny 								; get the next
.ab49	b1 00		lda ($00),y			lda 	(codePtr),y
.ab4b	88		dey				dey
.ab4c	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.ab4e	f0 17		beq $ab67			beq 	_CSLongVariable
.ab50	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.ab52	c8		iny				iny 								; skip over it and push on stack
.ab53	5a		phy				phy
.ab54	0a		asl a				asl 	a 							; double it, now C0-FE
.ab55	a8		tay				tay 								; put in Y
.ab56	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.ab59	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.ab5c	bd 00 07	lda $0700,x			lda 	highStack,x
.ab5f	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.ab62	ca		dex				dex 								; pop off stack
.ab63	7a		ply				ply 								; restore position and do next
.ab64	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ab67					_CSLongVariable:
.ab67	38		sec				sec 								; create variable if not found.
.ab68	20 ca a5	jsr $a5ca			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.ab6b	20 20 a4	jsr $a420			jsr 	IndexCheck 					; check indexing.
.ab6e	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.ab71	92 02		sta ($02)			sta 	(zTemp0)
.ab73	5a		phy				phy
.ab74	a0 01		ldy #$01			ldy 	#1
.ab76	bd 00 07	lda $0700,x			lda 	highStack,x
.ab79	91 02		sta ($02),y			sta 	(zTemp0),y
.ab7b	7a		ply				ply
.ab7c	ca		dex				dex 								; pop off stack
.ab7d	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.ab80					Command_New:
.ab80	fa		plx				plx
.ab81	9c 00 10	stz $1000			stz 	ProgramStart
.ab84	4c 1b a0	jmp $a01b			jmp 	WarmStart
.ab87					Command_Old:
.ab87	fa		plx				plx
.ab88	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ab8a	85 00		sta $00				sta 	codePtr
.ab8c	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ab8e	85 01		sta $01				sta 	codePtr+1
.ab90	a0 03		ldy #$03			ldy 	#3
.ab92					_COAdvance:
.ab92	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.ab94	b0 0e		bcs $aba4			bcs		_COFail
.ab96	20 b8 af	jsr $afb8			jsr 	AdvanceInCode
.ab99	b1 00		lda ($00),y			lda 	(codePtr),y
.ab9b	d0 f5		bne $ab92			bne 	_COAdvance
.ab9d	c8		iny				iny 								; byte after end of line
.ab9e	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.aba1					_CONotDeleted:
.aba1	4c 1b a0	jmp $a01b			jmp 	WarmStart
.aba4					_COFail:
.aba4	20 18 a2	jsr $a218			jsr 	ErrorHandler
>aba7	43 41 4e 54 3f 00				.text 	"CANT?",0
.abad					Command_End:
.abad	fa		plx				plx
.abae	4c 1b a0	jmp $a01b			jmp 	WarmStart
.abb1					Command_Stop:
>abb1	ff						.byte 	$FF
.abb2	fa		plx				plx
.abb3	20 18 a2	jsr $a218			jsr 	ErrorHandler
>abb6	53 54 4f 50 00					.text 	"STOP",0
.abbb					Command_Assert:
.abbb	fa		plx				plx
.abbc	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.abbf	1d 00 07	ora $0700,x			ora 	highStack,x
.abc2	f0 04		beq $abc8			beq 	_CAFail
.abc4	ca		dex				dex 								; throw if not.
.abc5	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.abc8					_CAFail:
.abc8	20 18 a2	jsr $a218			jsr 	ErrorHandler
>abcb	41 53 53 45 52 54 00				.text 	"ASSERT",0
.abd2					Command_Sys:
.abd2	fa		plx				plx
.abd3	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.abd6	85 02		sta $02				sta 	zTemp0
.abd8	bd 00 07	lda $0700,x			lda 	highStack,x
.abdb	85 03		sta $03				sta 	zTemp0+1
.abdd	ca		dex				dex 								; pop tos
.abde	da		phx				phx 								; save XY
.abdf	5a		phy				phy
.abe0	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.abe3	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.abe6	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.abe9	20 f1 ab	jsr $abf1			jsr 	_CSCallInd
.abec	7a		ply				ply 								; restore XY
.abed	fa		plx				plx
.abee	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.abf1					_CSCallInd:
.abf1	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.abf4					Command_DumpStack:
.abf4	fa		plx				plx
.abf5	da		phx				phx 								; save pos and sp
.abf6	5a		phy				phy
.abf7	86 0c		stx $0c				stx 	SignCount
.abf9	a2 ff		ldx #$ff			ldx 	#$FF
.abfb					_CDSLoop:
.abfb	e4 0c		cpx $0c				cpx 	SignCount 					; done all ?
.abfd	f0 2a		beq $ac29			beq 	_CDSExit
.abff	e8		inx				inx
.ac00	da		phx				phx 								; save SP
.ac01	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.ac04	a8		tay				tay
.ac05	bd 00 06	lda $0600,x			lda 	lowStack,x
.ac08	aa		tax				tax
.ac09	c0 00		cpy #$00			cpy 	#0
.ac0b	10 11		bpl $ac1e			bpl 	_CDSPositive
.ac0d	a9 2d		lda #$2d			lda 	#"-" 						; minus
.ac0f	20 62 a2	jsr $a262			jsr 	PrintCharacter
.ac12	98		tya				tya 								; negate YX
.ac13	49 ff		eor #$ff			eor 	#$FF
.ac15	a8		tay				tay
.ac16	8a		txa				txa
.ac17	49 ff		eor #$ff			eor 	#$FF
.ac19	aa		tax				tax
.ac1a	e8		inx				inx
.ac1b	d0 01		bne $ac1e			bne 	_CDSPositive
.ac1d	c8		iny				iny
.ac1e					_CDSPositive:
.ac1e	20 45 a2	jsr $a245			jsr 	PrintIntegerUnsigned
.ac21	a9 20		lda #$20			lda 	#" " 						; space
.ac23	20 62 a2	jsr $a262			jsr 	PrintCharacter
.ac26	fa		plx				plx
.ac27	80 d2		bra $abfb			bra 	_CDSLoop
.ac29					_CDSExit:
.ac29	a9 3c		lda #$3c			lda 	#"<"
.ac2b	20 62 a2	jsr $a262			jsr 	PrintCharacter
.ac2e	20 62 a2	jsr $a262			jsr 	PrintCharacter
.ac31	a9 0d		lda #$0d			lda 	#13 						; CR
.ac33	20 62 a2	jsr $a262			jsr 	PrintCharacter
.ac36	7a		ply				ply
.ac37	fa		plx				plx
.ac38	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.ac3b					Stack_Add:
.ac3b	fa		plx				plx
.ac3c	ca		dex				dex
.ac3d	18		clc				clc
.ac3e	bd 00 06	lda $0600,x			lda		lowStack,x
.ac41	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ac44	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac47	bd 00 07	lda $0700,x			lda		highStack,x
.ac4a	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ac4d	9d 00 07	sta $0700,x			sta 	highStack,x
.ac50	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ac53					Stack_Sub:
.ac53	fa		plx				plx
.ac54	ca		dex				dex
.ac55	38		sec				sec
.ac56	bd 00 06	lda $0600,x			lda		lowStack,x
.ac59	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ac5c	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac5f	bd 00 07	lda $0700,x			lda		highStack,x
.ac62	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ac65	9d 00 07	sta $0700,x			sta 	highStack,x
.ac68	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ac6b					Stack_And:
.ac6b	fa		plx				plx
.ac6c	ca		dex				dex
.ac6d	bd 00 06	lda $0600,x			lda		lowStack,x
.ac70	3d 01 06	and $0601,x			and		lowStack+1,x
.ac73	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac76	bd 00 07	lda $0700,x			lda		highStack,x
.ac79	3d 01 07	and $0701,x			and 	highStack+1,x
.ac7c	9d 00 07	sta $0700,x			sta 	highStack,x
.ac7f	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ac82					Stack_Xor:
.ac82	fa		plx				plx
.ac83	ca		dex				dex
.ac84	bd 00 06	lda $0600,x			lda		lowStack,x
.ac87	5d 01 06	eor $0601,x			eor		lowStack+1,x
.ac8a	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac8d	bd 00 07	lda $0700,x			lda		highStack,x
.ac90	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ac93	9d 00 07	sta $0700,x			sta 	highStack,x
.ac96	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ac99					Stack_Or:
.ac99	fa		plx				plx
.ac9a	ca		dex				dex
.ac9b	bd 00 06	lda $0600,x			lda		lowStack,x
.ac9e	1d 01 06	ora $0601,x			ora		lowStack+1,x
.aca1	9d 00 06	sta $0600,x			sta 	lowStack,x
.aca4	bd 00 07	lda $0700,x			lda		highStack,x
.aca7	1d 01 07	ora $0701,x			ora 	highStack+1,x
.acaa	9d 00 07	sta $0700,x			sta 	highStack,x
.acad	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.acb0					Stack_Shl:
.acb0	fa		plx				plx
.acb1	38		sec				sec
.acb2	80 02		bra $acb6			bra 	StackShift
.acb4					Stack_Shr:
.acb4	fa		plx				plx
.acb5	18		clc				clc
.acb6					StackShift:
.acb6	08		php				php
.acb7	ca		dex				dex
.acb8	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.acbb	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.acbd	1d 01 07	ora $0701,x			ora 	highStack+1,x
.acc0	d0 19		bne $acdb			bne 	_SSZero
.acc2					_SSLoop:
.acc2	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.acc5	30 1a		bmi $ace1			bmi 	_SSDone 					; completed ?
.acc7	28		plp				plp 								; restore flag
.acc8	08		php				php
.acc9	b0 08		bcs $acd3			bcs 	_SSLeft 					; do either shift.
.accb	5e 00 07	lsr $0700,x			lsr 	highStack,x
.acce	7e 00 06	ror $0600,x			ror 	lowStack,x
.acd1	80 ef		bra $acc2			bra 	_SSLoop
.acd3					_SSLeft:
.acd3	1e 00 06	asl $0600,x			asl 	lowStack,x
.acd6	3e 00 07	rol $0700,x			rol 	highStack,x
.acd9	80 e7		bra $acc2			bra 	_SSLoop
.acdb					_SSZero:
.acdb	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.acde	9e 00 07	stz $0700,x			stz 	highStack,x
.ace1					_SSDone:
.ace1	28		plp				plp 								; throw flag.
.ace2	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.ace5					Comp_Equal:
.ace5	fa		plx				plx
.ace6	38		sec				sec
.ace7	80 02		bra $aceb			bra 	Comp_CheckEqual
.ace9					Comp_NotEqual:
.ace9	fa		plx				plx
.acea	18		clc				clc
.aceb					Comp_CheckEqual:
.aceb	08		php				php
.acec	ca		dex				dex
.aced	bd 00 06	lda $0600,x			lda		lowStack,x
.acf0	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.acf3	d0 06		bne $acfb			bne 	_CCENonZero
.acf5	bd 00 07	lda $0700,x			lda		highStack,x
.acf8	5d 01 07	eor $0701,x			eor 	highStack+1,x
.acfb					_CCENonZero:
.acfb	f0 02		beq $acff			beq 	_CCENotSet
.acfd	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.acff					_CCENotSet:
.acff					CompCheckFlip:
.acff	28		plp				plp 								; if carry set, we want $FF if equal
.ad00	90 02		bcc $ad04			bcc 	CompReturn
.ad02	49 ff		eor #$ff			eor 	#$FF
.ad04					CompReturn:
.ad04	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.ad07	9d 00 07	sta $0700,x			sta 	highStack,x
.ad0a	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ad0d					Comp_Less:
.ad0d	fa		plx				plx
.ad0e	18		clc				clc
.ad0f	80 02		bra $ad13			bra 	Comp_LessCont
.ad11					Comp_GreaterEqual:
.ad11	fa		plx				plx
.ad12	38		sec				sec
.ad13					Comp_LessCont:
.ad13	08		php				php
.ad14	ca		dex				dex
.ad15	38		sec				sec
.ad16	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.ad19	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ad1c	bd 00 07	lda $0700,x			lda 	highStack,x
.ad1f	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ad22	50 02		bvc $ad26			bvc 	_CLNoFlip 					; unsigned -> signed
.ad24	49 80		eor #$80			eor 	#$80
.ad26					_CLNoFlip:
.ad26	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ad28	f0 d5		beq $acff			beq 	CompCheckFlip
.ad2a	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ad2c	80 d1		bra $acff			bra 	CompCheckFlip
.ad2e					Comp_LessEqual:
.ad2e	fa		plx				plx
.ad2f	38		sec				sec
.ad30	80 02		bra $ad34			bra 	Comp_LessEqualCont
.ad32					Comp_Greater:
.ad32	fa		plx				plx
.ad33	18		clc				clc
.ad34					Comp_LessEqualCont:
.ad34	08		php				php
.ad35	ca		dex				dex
.ad36	38		sec				sec
.ad37	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.ad3a	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ad3d	bd 01 07	lda $0701,x			lda 	highStack+1,x
.ad40	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ad43	50 02		bvc $ad47			bvc 	_CLENoFlip 					; unsigned -> signed
.ad45	49 80		eor #$80			eor 	#$80
.ad47					_CLENoFlip:
.ad47	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ad49	f0 b4		beq $acff			beq 	CompCheckFlip
.ad4b	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ad4d	80 b0		bra $acff			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.ad4f					DivInteger16:
.ad4f	fa		plx				plx
.ad50	20 56 ad	jsr $ad56			jsr 	IntegerDivide
.ad53	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ad56					IntegerDivide:
.ad56	ca		dex				dex
.ad57	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.ad5a	1d 01 07	ora $0701,x			ora 	highStack+1,x
.ad5d	d0 14		bne $ad73			bne 	_BFDOkay
.ad5f	20 18 a2	jsr $a218			jsr 	ErrorHandler
>ad62	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ad6a	20 42 59 20 5a 45 52 4f 00
.ad73					_BFDOkay:
.ad73	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.ad75	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.ad77	64 0c		stz $0c				stz 	SignCount 					; Count of signs.
.ad79	20 b5 ad	jsr $adb5			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ad7c	e8		inx				inx
.ad7d	20 b5 ad	jsr $adb5			jsr 	CheckIntegerNegate
.ad80	ca		dex				dex
.ad81	5a		phy				phy 								; Y is the counter
.ad82	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.ad84					_BFDLoop:
.ad84	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.ad87	3e 00 07	rol $0700,x			rol 	highStack,x
.ad8a	26 04		rol $04				rol 	zTemp1
.ad8c	26 05		rol $05				rol 	zTemp1+1
.ad8e	38		sec				sec
.ad8f	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.ad91	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ad94	48		pha				pha
.ad95	a5 05		lda $05				lda 	zTemp1+1
.ad97	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ad9a	90 0f		bcc $adab			bcc 	_BFDNoAdd
.ad9c	85 05		sta $05				sta 	zTemp1+1
.ad9e	68		pla				pla
.ad9f	85 04		sta $04				sta 	zTemp1+0
.ada1	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.ada4	09 01		ora #$01			ora 	#1
.ada6	9d 00 06	sta $0600,x			sta 	lowStack,x
.ada9	80 01		bra $adac			bra 	_BFDNext
.adab					_BFDNoAdd:
.adab	68		pla				pla 								; Throw away the intermediate calculations
.adac					_BFDNext:
.adac	88		dey				dey
.adad	d0 d5		bne $ad84			bne 	_BFDLoop
.adaf	7a		ply				ply 								; restore Y
.adb0	46 0c		lsr $0c				lsr 	SignCount 					; if sign count odd,
.adb2	b0 07		bcs $adbb			bcs		IntegerNegateAlways 		; negate the result
.adb4	60		rts				rts
.adb5					CheckIntegerNegate:
.adb5	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.adb8	30 01		bmi $adbb			bmi 	IntegerNegateAlways 		; if so negate it
.adba	60		rts				rts
.adbb					IntegerNegateAlways:
.adbb	e6 0c		inc $0c				inc 	SignCount 					; bump the count of signs
.adbd	4c 18 ae	jmp $ae18			jmp 	Unary_Negate
.adc0					ModInteger16:
.adc0	fa		plx				plx
.adc1	20 56 ad	jsr $ad56			jsr 	IntegerDivide
.adc4	a5 04		lda $04				lda 	zTemp1
.adc6	9d 00 06	sta $0600,x			sta 	lowStack,x
.adc9	a5 05		lda $05				lda 	zTemp1+1
.adcb	9d 00 07	sta $0700,x			sta 	highStack,x
.adce	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.add1					MulInteger16:
.add1	fa		plx				plx
.add2	ca		dex				dex
.add3	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.add6	85 04		sta $04				sta 	zTemp1
.add8	bd 00 07	lda $0700,x			lda 	highStack,x
.addb	85 05		sta $05				sta 	zTemp1+1
.addd	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.ade0	9e 00 07	stz $0700,x			stz 	highStack,x
.ade3					_BFMMultiply:
.ade3	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.ade5	29 01		and #$01			and 	#1
.ade7	f0 13		beq $adfc			beq 	_BFMNoAdd
.ade9	18		clc				clc 								; add old tos to current tos.
.adea	bd 00 06	lda $0600,x			lda		lowStack,x
.aded	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.adf0	9d 00 06	sta $0600,x			sta 	lowStack,x
.adf3	bd 00 07	lda $0700,x			lda		highStack,x
.adf6	7d 01 07	adc $0701,x			adc 	highStack+1,x
.adf9	9d 00 07	sta $0700,x			sta 	highStack,x
.adfc					_BFMNoAdd:
.adfc	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.adff	3e 01 07	rol $0701,x			rol 	highStack+1,x
.ae02	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.ae04	66 04		ror $04				ror 	zTemp1+0
.ae06	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.ae08	05 05		ora $05				ora 	zTemp1+1
.ae0a	d0 d7		bne $ade3			bne 	_BFMMultiply
.ae0c	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.ae0f					Unary_Absolute:
.ae0f	fa		plx				plx
.ae10	bd 00 07	lda $0700,x			lda 	highStack,x
.ae13	30 04		bmi $ae19			bmi 	Unary_Negate_Code
.ae15	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae18					Unary_Negate:
.ae18	fa		plx				plx
.ae19					Unary_Negate_Code:
.ae19	38		sec				sec
.ae1a	a9 00		lda #$00			lda		#0
.ae1c	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ae1f	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae22	a9 00		lda #$00			lda		#0
.ae24	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ae27	9d 00 07	sta $0700,x			sta 	highStack,x
.ae2a	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae2d					Unary_Not:
.ae2d	fa		plx				plx
.ae2e	bd 00 06	lda $0600,x			lda 	lowStack,x
.ae31	49 ff		eor #$ff			eor 	#$FF
.ae33	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae36	bd 00 07	lda $0700,x			lda 	highStack,x
.ae39	49 ff		eor #$ff			eor 	#$FF
.ae3b	9d 00 07	sta $0700,x			sta 	highStack,x
.ae3e	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae41					Unary_Increment:
.ae41	fa		plx				plx
.ae42	fe 00 06	inc $0600,x			inc 	lowStack,x
.ae45	d0 03		bne $ae4a			bne 	_UIExit
.ae47	fe 00 07	inc $0700,x			inc 	highStack,x
.ae4a					_UIExit:
.ae4a	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae4d					Unary_Decrement:
.ae4d	fa		plx				plx
.ae4e	bd 00 06	lda $0600,x			lda 	lowStack,x
.ae51	d0 03		bne $ae56			bne 	_UDNoBorrow
.ae53	de 00 07	dec $0700,x			dec 	highStack,x
.ae56					_UDNoBorrow:
.ae56	de 00 06	dec $0600,x			dec 	lowStack,x
.ae59	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae5c					Unary_BSwap:
.ae5c	fa		plx				plx
.ae5d	bd 00 06	lda $0600,x			lda 	lowStack,x
.ae60	48		pha				pha
.ae61	bd 00 07	lda $0700,x			lda 	highStack,x
.ae64	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae67	68		pla				pla
.ae68	9d 00 07	sta $0700,x			sta 	highStack,x
.ae6b	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae6e					Unary_Shl:
.ae6e	fa		plx				plx
.ae6f	1e 00 06	asl $0600,x			asl 	lowStack,x
.ae72	3e 00 07	rol $0700,x			rol 	highStack,x
.ae75	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae78					Unary_Shr:
.ae78	fa		plx				plx
.ae79	5e 00 07	lsr $0700,x			lsr 	highStack,x
.ae7c	7e 00 06	ror $0600,x			ror 	lowStack,x
.ae7f	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.ae82					Unary_Sgn:
.ae82	fa		plx				plx
.ae83	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.ae86	10 0a		bpl $ae92			bpl 	_USNotNeg
.ae88	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.ae8a	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae8d	9d 00 07	sta $0700,x			sta 	highStack,x
.ae90	80 10		bra $aea2			bra 	_USExit
.ae92					_USNotNeg:
.ae92	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.ae95	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.ae98	9e 00 07	stz $0700,x			stz 	highStack,x
.ae9b	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.ae9d	f0 03		beq $aea2			beq 	_USExit
.ae9f	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.aea2					_USExit:
.aea2	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.aea5					Random_Handler:
.aea5	fa		plx				plx
.aea6	a5 11		lda $11				lda 	randomSeed
.aea8	05 12		ora $12				ora 	randomSeed+1
.aeaa	d0 08		bne $aeb4			bne 	_RH_NoInit
.aeac	a9 7c		lda #$7c			lda 	#$7C
.aeae	85 11		sta $11				sta 	randomSeed
.aeb0	a9 a1		lda #$a1			lda 	#$A1
.aeb2	85 12		sta $12				sta 	randomSeed+1
.aeb4					_RH_NoInit:
.aeb4	a5 11		lda $11				lda 	randomSeed
.aeb6	4a		lsr a		        lsr		a
.aeb7	26 12		rol $12		        rol 	randomSeed+1
.aeb9	90 02		bcc $aebd	        bcc 	_RH_NoEor
.aebb	49 b4		eor #$b4	        eor 	#$B4
.aebd					_RH_NoEor:
.aebd	85 11		sta $11		        sta 	randomSeed
.aebf	45 12		eor $12		        eor 	randomSeed+1
.aec1	e8		inx		        inx
.aec2	9d 00 07	sta $0700,x	        sta 	highStack,x
.aec5	a5 11		lda $11		        lda 	randomSeed
.aec7	9d 00 06	sta $0600,x	        sta 	lowStack,x
.aeca	4c 84 a2	jmp $a284			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.aecd					Command_Call:
.aecd	fa		plx				plx
.aece	20 cf a4	jsr $a4cf			jsr 	StackPushPosition 				; save stack position
.aed1	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.aed3	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.aed6	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.aed8	85 02		sta $02				sta 	zTemp0
.aeda	c8		iny				iny
.aedb	b1 00		lda ($00),y			lda 	(codePtr),y
.aedd	85 03		sta $03				sta 	zTemp0+1
.aedf	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.aee1	85 00		sta $00				sta 	codePtr
.aee3	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aee5	85 01		sta $01				sta 	codePtr+1
.aee7	a0 01		ldy #$01			ldy 	#1
.aee9					_CCSearch:
.aee9	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.aeeb	f0 2d		beq $af1a			beq		_CCFail
.aeed	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.aeef	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.aef1	f0 0d		beq $af00			beq 	_CCCheckMSB
.aef3	18		clc				clc 									; forward to next line.
.aef4	b2 00		lda ($00)			lda 	(codePtr)
.aef6	65 00		adc $00				adc 	codePtr
.aef8	85 00		sta $00				sta 	codePtr
.aefa	90 ed		bcc $aee9			bcc 	_CCSearch
.aefc	e6 01		inc $01				inc 	codePtr+1
.aefe	80 e9		bra $aee9			bra 	_CCSearch
.af00					_CCCheckMSB:
.af00	c8		iny				iny 									; get MSB, keeping Y as 1
.af01	b1 00		lda ($00),y			lda 	(codePtr),y
.af03	88		dey				dey
.af04	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.af06	d0 e1		bne $aee9			bne 	_CCSearch
.af08	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.af0a	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.af0c	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.af0e	d0 0a		bne $af1a			bne 	_CCFail
.af10	c8		iny				iny 									; get the length of this.
.af11	b1 00		lda ($00),y			lda 	(codePtr),y
.af13	18		clc				clc
.af14	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.af16	a8		tay				tay
.af17	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.af1a					_CCFail:
.af1a	20 18 a2	jsr $a218			jsr 	ErrorHandler
>af1d	43 41 4c 4c 3f 00				.text 	"CALL?",0
.af23					Command_Return:
.af23	fa		plx				plx
.af24	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.af26	20 de a4	jsr $a4de			jsr 	StackCheckTop
.af29	90 0f		bcc $af3a			bcc 	_CRFail
.af2b	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.af2d	20 ec a4	jsr $a4ec			jsr 	StackRestorePosition
.af30	c8		iny				iny
.af31	c8		iny				iny
.af32	a9 04		lda #$04			lda 	#4 								; pop off stack
.af34	20 e6 a4	jsr $a4e6			jsr 	StackPop
.af37	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.af3a					_CRFail:
.af3a	20 18 a2	jsr $a218			jsr 	ErrorHandler
>af3d	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.af43					Structure_If:
.af43	fa		plx				plx
.af44	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.af46	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.af49	18		clc				clc
.af4a	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.af4d	1d 00 07	ora $0700,x			ora 	highStack,x
.af50	ca		dex				dex 									; drop TOS
.af51	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.af53	d0 0e		bne $af63			bne 	_SIFNoSkip 						; at this level.
.af55	da		phx				phx
.af56	a9 37		lda #$37			lda 	#KWD_ELSE
.af58	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.af5a	20 90 af	jsr $af90			jsr 	StructSkipForward
.af5d	fa		plx				plx 									; restore X
.af5e	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.af60	d0 01		bne $af63			bne 	_SIFNoSkip 						; clause.
.af62	c8		iny				iny
.af63					_SIFNoSkip:
.af63	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.af66					Structure_Else:
.af66	fa		plx				plx
.af67	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.af69	20 de a4	jsr $a4de			jsr 	StackCheckTop
.af6c	90 0b		bcc $af79			bcc 	SIFail
.af6e	da		phx				phx 									; got here by executing IF clause so skip
.af6f	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.af71	aa		tax				tax
.af72	20 90 af	jsr $af90			jsr 	StructSkipForward
.af75	fa		plx				plx
.af76	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.af79					SIFail:
.af79	20 18 a2	jsr $a218			jsr 	ErrorHandler
>af7c	49 46 3f 00					.text 	"IF?",0
.af80					Structure_Endif:
.af80	fa		plx				plx
.af81	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.af83	20 de a4	jsr $a4de			jsr 	StackCheckTop
.af86	90 f1		bcc $af79			bcc 	SIFail
.af88	a9 01		lda #$01			lda 	#1 								; throw it.
.af8a	20 e6 a4	jsr $a4e6			jsr 	StackPop
.af8d	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.af90					StructSkipForward:
.af90	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.af92	86 03		stx $03				stx 	zTemp0+1
.af94	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.af96					_SSFLoop:
.af96	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.af98	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.af9a	d0 08		bne $afa4			bne		_SSFFail
.af9c	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.af9e	f0 17		beq $afb7			beq 	_SSFEnd
.afa0	c5 03		cmp $03				cmp 	zTemp0+1
.afa2	f0 13		beq $afb7			beq 	_SSFEnd
.afa4					_SSFFail:
.afa4	20 b8 af	jsr $afb8			jsr 	AdvanceInCode 					; skip over in code.
.afa7	b0 ed		bcs $af96			bcs 	_SSFLoop 						; if not end of program, keep going.
.afa9	20 18 a2	jsr $a218			jsr 	ErrorHandler
>afac	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>afb4	45 3f 00
.afb7					_SSFEnd:
.afb7	60		rts				rts
.afb8					AdvanceInCode:
.afb8	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.afba	f0 28		beq $afe4			beq 	_AICEndOfLine 					; end of line.
.afbc	c8		iny				iny 									; advance one.
.afbd	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.afbf	90 10		bcc $afd1			bcc 	_AICControl
.afc1	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.afc3	b0 0a		bcs $afcf			bcs 	_AICExit
.afc5	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.afc7	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.afc9	90 04		bcc $afcf			bcc 	_AICExit
.afcb	c6 04		dec $04				dec 	zTemp1
.afcd	c6 04		dec $04				dec 	zTemp1
.afcf					_AICExit:
.afcf	38		sec				sec
.afd0	60		rts				rts
.afd1					_AICControl:
.afd1	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.afd3	f0 0b		beq $afe0			beq 	_AICThree
.afd5	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.afd7	f0 07		beq $afe0			beq 	_AICThree
.afd9	98		tya				tya										; skip over a string/comment/define.
.afda	38		sec				sec
.afdb	71 00		adc ($00),y			adc 	(codePtr),y
.afdd	a8		tay				tay
.afde	38		sec				sec
.afdf	60		rts				rts
.afe0					_AICThree:
.afe0	c8		iny				iny
.afe1	c8		iny				iny
.afe2	38		sec				sec
.afe3	60		rts				rts
.afe4					_AICEndOfLine:
.afe4	18		clc				clc 									; forward to next line.
.afe5	b2 00		lda ($00)			lda 	(codePtr)
.afe7	65 00		adc $00				adc 	codePtr
.afe9	85 00		sta $00				sta 	codePtr
.afeb	90 02		bcc $afef			bcc 	_AICNoCarry
.afed	e6 01		inc $01				inc 	codePtr+1
.afef					_AICNoCarry:
.afef	a0 03		ldy #$03			ldy 	#3 								; start of new line
.aff1	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.aff3	d0 da		bne $afcf			bne 	_AICExit
.aff5	18		clc				clc 									; program end.
.aff6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.aff7					Struct_Repeat:
.aff7	fa		plx				plx
.aff8	20 cf a4	jsr $a4cf			jsr 	StackPushPosition 				; save stack position
.affb	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.affd	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.b000	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b003					Struct_Until:
.b003	fa		plx				plx
.b004	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.b006	20 de a4	jsr $a4de			jsr 	StackCheckTop
.b009	90 1b		bcc $b026			bcc 	_SUFail
.b00b	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.b00e	1d 00 07	ora $0700,x			ora 	highStack,x
.b011	ca		dex				dex
.b012	09 00		ora #$00			ora 	#0
.b014	f0 08		beq $b01e			beq 	_SULoopBack 					; if so keep going.
.b016	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.b018	20 e6 a4	jsr $a4e6			jsr 	StackPop
.b01b	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b01e					_SULoopBack:
.b01e	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b020	20 ec a4	jsr $a4ec			jsr 	StackRestorePosition
.b023	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b026					_SUFail:
.b026	20 18 a2	jsr $a218			jsr 	ErrorHandler
>b029	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>b031	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.b033					Struct_For:
.b033	fa		plx				plx
.b034	18		clc				clc
.b035	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.b038	49 ff		eor #$ff			eor 	#$FF
.b03a	69 01		adc #$01			adc 	#1
.b03c	08		php				php
.b03d	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.b040	bd 00 07	lda $0700,x			lda 	highStack,x
.b043	49 ff		eor #$ff			eor 	#$FF
.b045	28		plp				plp
.b046	69 00		adc #$00			adc 	#0
.b048	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.b04b	ca		dex				dex 									; throw TOS
.b04c	20 cf a4	jsr $a4cf			jsr 	StackPushPosition 				; save stack position
.b04f	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.b051	20 bf a4	jsr $a4bf			jsr 	StackPushByte
.b054	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b057					Struct_Index:
.b057	fa		plx				plx
.b058	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b05a	20 de a4	jsr $a4de			jsr 	StackCheckTop
.b05d	90 43		bcc $b0a2			bcc 	SNFail
.b05f	e8		inx				inx 									; new stack entry
.b060	5a		phy				phy
.b061	a0 04		ldy #$04			ldy 	#4 								; access index value
.b063	b1 0a		lda ($0a),y			lda 	(iStack),y
.b065	49 ff		eor #$ff			eor 	#$FF
.b067	9d 00 07	sta $0700,x			sta 	highStack,x
.b06a	c8		iny				iny
.b06b	b1 0a		lda ($0a),y			lda 	(iStack),y
.b06d	49 ff		eor #$ff			eor 	#$FF
.b06f	9d 00 06	sta $0600,x			sta 	lowStack,x
.b072	7a		ply				ply 									; restore code pointer
.b073	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b076					Struct_Next:
.b076	fa		plx				plx
.b077	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b079	20 de a4	jsr $a4de			jsr 	StackCheckTop
.b07c	90 24		bcc $b0a2			bcc 	SNFail
.b07e	5a		phy				phy 									; save code position
.b07f	a0 05		ldy #$05			ldy 	#5 								; bump the count
.b081	b1 0a		lda ($0a),y			lda 	(iStack),y
.b083	1a		inc a				inc 	a
.b084	91 0a		sta ($0a),y			sta 	(iStack),y
.b086	d0 11		bne $b099			bne 	_SNLoopBack
.b088	88		dey				dey
.b089	b1 0a		lda ($0a),y			lda 	(iStack),y
.b08b	1a		inc a				inc 	a
.b08c	91 0a		sta ($0a),y			sta 	(iStack),y
.b08e	d0 09		bne $b099			bne 	_SNLoopBack  					; non-zero loop back.
.b090	7a		ply				ply 									; restore code position.
.b091	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.b093	20 e6 a4	jsr $a4e6			jsr 	StackPop
.b096	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b099					_SNLoopBack:
.b099	7a		ply				ply 									; restore code position, being junked anyway.
.b09a	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b09c	20 ec a4	jsr $a4ec			jsr 	StackRestorePosition
.b09f	4c 84 a2	jmp $a284			jmp 	ExecuteLoop
.b0a2					SNFail:
.b0a2	20 18 a2	jsr $a218			jsr 	ErrorHandler
>b0a5	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
