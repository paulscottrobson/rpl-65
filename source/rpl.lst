
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Fri Nov 15 10:41:18 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					iStack:			.word ?						; stack pointer
>000c					signCount:		.byte ? 					; divide sign count.
>000d					allocPtr:		.word ? 					; memory allocation pointer (down)
>000f					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0011					randomSeed:		.word ? 					; random number seed
>0013					prefixCharacter:.byte ?						; char to print before listed element.
>0014					breakCount:		.byte ? 					; counter avoids repeated break checks
>0015					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	0f e8 03 01 00 60 22 c2			.byte	$0f,$e8,$03,$01,$00,$60,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$f2,$03,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$fc,$03,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$06,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$42,$04,$0b,$00,$08,$10,$04,$01,$50,$00,$08,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$88,$04,$0b,$00,$05,$24,$04,$0b,$00,$05,$2e,$04,$40,$00,$1e,$38,$04,$05,$06,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$42,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$4c,$04,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$60,$04,$39,$00,$15,$56,$04,$05,$04,$d2,$d3,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$60,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$6a,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$74,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$7e,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$88,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$92,$04,$a0,$02,$60,$04,$00,$1c,$9c,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$a6,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ba,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$c4,$04,$01,$51,$00,$02,$60,$04,$00,$05,$ce,$04,$39,$00
>1008	c1 cc cc cd c5 ed 00 0b f2 03 a0 22 c3 cf d5 ce
>1018	f4 00 0d fc 03 01 8e 00 22 e1 01 d2 ff 25 00 12
>1028	06 04 c3 cf d5 ce f4 08 38 02 38 04 02 42 04 0b
>1038	00 08 10 04 01 50 00 08 00 12 1a 04 c3 cf d5 ce
>1048	f4 08 38 02 38 04 02 88 04 0b 00 05 24 04 0b 00
>1058	05 2e 04 40 00 1e 38 04 05 06 d3 c5 cc c5 c3 f4
>1068	2d 2d 2d 2d c2 c1 cc cc cd c5 ed 0f 22 c2 c1 cc
>1078	ec 39 00 29 42 04 05 09 c2 c1 cc cc db c9 ce c9
>1088	f4 30 27 01 50 00 0e 22 c2 c1 cc ec 23 80 24 30
>1098	27 bc 0e 22 c2 c1 cc ec 23 81 24 00 2d 4c 04 02
>10a8	56 04 22 c2 c1 cc ec 23 82 24 02 56 04 22 c2 c1
>10b8	cc ec 23 83 24 30 87 11 2a 22 c2 c1 cc ec 23 84
>10c8	24 01 51 00 02 60 04 39 00 15 56 04 05 04 d2 d3
>10d8	c7 ee 30 81 11 06 81 37 01 ff ff 09 39 00 0f 60
>10e8	04 05 09 c2 c1 cc cc db c4 d2 c1 f7 00 10 6a 04
>10f8	c2 c1 cc ec 23 80 24 2d 01 20 9f 1d 00 0f 74 04
>1108	c2 c1 cc ec 23 81 24 01 21 9f 1d 00 19 7e 04 90
>1118	01 22 9f 1d 01 23 9f 1d c2 c1 cc ec 23 84 24 01
>1128	23 9f 1d 39 00 0f 88 04 05 09 c2 c1 cc cc db cd
>1138	cf d6 e5 00 08 92 04 a0 02 60 04 00 1c 9c 04 c2
>1148	c1 cc ec 23 80 24 c2 c1 cc ec 23 82 24 0f 33 22
>1158	c2 c1 cc ec 23 80 24 00 1f a6 04 33 01 50 00 1a
>1168	36 80 19 12 06 c2 c1 cc ec 23 82 24 28 22 c2 c1
>1178	cc ec 23 82 24 09 00 1c b0 04 c2 c1 cc ec 23 81
>1188	24 c2 c1 cc ec 23 83 24 0f 33 22 c2 c1 cc ec 23
>1198	81 24 00 1d ba 04 33 bc 1a 36 80 19 12 06 c2 c1
>11a8	cc ec 23 83 24 28 22 c2 c1 cc ec 23 83 24 09 00
>11b8	0a c4 04 01 51 00 02 60 04 00 05 ce 04 39 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 d1 a2	jsr $a2d1			jsr 	ExternInitialise			; set up external stuff.
.a006	a2 19		ldx #$19			ldx 	#BootPrompt & $FF 			; print start up.
.a008	a0 a0		ldy #$a0			ldy 	#BootPrompt >> 8
.a00a	20 f2 a1	jsr $a1f2			jsr 	PrintStringXY
.a00d					WarmStart:
.a00d	20 26 a3	jsr $a326			jsr 	ExternInput
.a010	20 65 a6	jsr $a665			jsr 	TokeniseInputBuffer
.a013	4c 0d a2	jmp $a20d			jmp	 	ExecuteProgram
>a016	ff						.byte 	$FF
.a017	a2 55		ldx #$55			ldx 	#$55
.a019					BootPrompt:
>a019	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (15-NOV-19) ***",13,13
>a021	36 35 20 28 31 35 2d 4e 4f 56 2d 31 39 29 20 2a
>a031	2a 2a 0d 0d
>a035	00						.byte 	0

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a036					KeywordText:
>a036	01 ff					.text $01,$ff                          ; $0000 %eol
>a038	01 ff					.text $01,$ff                          ; $0001 %const
>a03a	01 ff					.text $01,$ff                          ; $0002 %call
>a03c	01 ff					.text $01,$ff                          ; $0003 %comment
>a03e	01 ff					.text $01,$ff                          ; $0004 %qstring
>a040	01 ff					.text $01,$ff                          ; $0005 %define
>a042	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a045	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a04c	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a050	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a056	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a05c	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a061	01 aa					.text $01,$aa                          ; $000c *
>a063	01 af					.text $01,$af                          ; $000d /
>a065	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a069	01 ab					.text $01,$ab                          ; $000f +
>a06b	01 ad					.text $01,$ad                          ; $0010 -
>a06d	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a071	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a074	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a078	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a07c	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a080	01 bd					.text $01,$bd                          ; $0016 =
>a082	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a085	01 be					.text $01,$be                          ; $0018 >
>a087	01 bc					.text $01,$bc                          ; $0019 <
>a089	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a08c	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a08f	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a092	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a095	01 c0					.text $01,$c0                          ; $001e @
>a097	01 a1					.text $01,$a1                          ; $001f !
>a099	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a09c	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a0a2	01 de					.text $01,$de                          ; $0022 ^
>a0a4	01 db					.text $01,$db                          ; $0023 [
>a0a6	01 dd					.text $01,$dd                          ; $0024 ]
>a0a8	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a0ac	01 bf					.text $01,$bf                          ; $0026 ?
>a0ae	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a0b2	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a0b9	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a0bd	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a0c0	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a0c3	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a0c9	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a0cc	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a0cf	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a0d3	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a0d7	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a0db	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a0e0	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a0e4	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a0e8	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a0ed	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a0f2	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a0f7	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a0fd	01 bb					.text $01,$bb                          ; $0039 ;
>a0ff	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a106	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a10b	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a10f	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a113	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a118	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a11c	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a120	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a125	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a12a	00					.byte 0
>a12b						.align 2
.a12c					DispatchHandler:
>a12c	92 a2					.word ExecuteNextLine          ; $0000 %eol
>a12e	a8 a2					.word LongConstant             ; $0001 %const
>a130	6e ae					.word Command_Call             ; $0002 %call
>a132	92 a2					.word ExecuteComment           ; $0003 %comment
>a134	b9 a2					.word StringConstant           ; $0004 %qstring
>a136	b2 a1					.word SyntaxError              ; $0005 %define
>a138	e4 ae					.word Structure_If             ; $0006 if
>a13a	98 af					.word Struct_Repeat            ; $0007 repeat
>a13c	d4 af					.word Struct_For               ; $0008 for
>a13e	21 af					.word Structure_Endif          ; $0009 endif
>a140	a4 af					.word Struct_Until             ; $000a until
>a142	17 b0					.word Struct_Next              ; $000b next
>a144	72 ad					.word MulInteger16             ; $000c *
>a146	f0 ac					.word DivInteger16             ; $000d /
>a148	61 ad					.word ModInteger16             ; $000e mod
>a14a	dc ab					.word Stack_Add                ; $000f +
>a14c	f4 ab					.word Stack_Sub                ; $0010 -
>a14e	0c ac					.word Stack_And                ; $0011 and
>a150	3a ac					.word Stack_Or                 ; $0012 or
>a152	23 ac					.word Stack_Xor                ; $0013 xor
>a154	51 ac					.word Stack_Shl                ; $0014 shl
>a156	55 ac					.word Stack_Shr                ; $0015 shr
>a158	86 ac					.word Comp_Equal               ; $0016 =
>a15a	8a ac					.word Comp_NotEqual            ; $0017 <>
>a15c	d3 ac					.word Comp_Greater             ; $0018 >
>a15e	ae ac					.word Comp_Less                ; $0019 <
>a160	b2 ac					.word Comp_GreaterEqual        ; $001a >=
>a162	cf ac					.word Comp_LessEqual           ; $001b <=
>a164	d5 a9					.word Mem_Peek                 ; $001c c@
>a166	07 aa					.word Mem_Poke                 ; $001d c!
>a168	eb a9					.word Mem_WPeek                ; $001e @
>a16a	1c aa					.word Mem_WPoke                ; $001f !
>a16c	3a aa					.word Mem_DWPoke               ; $0020 d!
>a16e	54 aa					.word Mem_Alloc                ; $0021 alloc
>a170	e2 aa					.word Command_Store            ; $0022 ^
>a172	b2 a1					.word SyntaxError              ; $0023 [
>a174	b2 a1					.word SyntaxError              ; $0024 ]
>a176	73 ab					.word Command_Sys              ; $0025 sys
>a178	95 ab					.word Command_DumpStack        ; $0026 ?
>a17a	b0 ad					.word Unary_Absolute           ; $0027 abs
>a17c	b9 ad					.word Unary_Negate             ; $0028 negate
>a17e	ce ad					.word Unary_Not                ; $0029 not
>a180	e2 ad					.word Unary_Increment          ; $002a ++
>a182	ee ad					.word Unary_Decrement          ; $002b --
>a184	fd ad					.word Unary_BSwap              ; $002c bswap
>a186	0f ae					.word Unary_Shl                ; $002d <<
>a188	19 ae					.word Unary_Shr                ; $002e >>
>a18a	23 ae					.word Unary_Sgn                ; $002f sgn
>a18c	46 ae					.word Random_Handler           ; $0030 rnd
>a18e	82 aa					.word Stack_Empty              ; $0031 clr
>a190	88 aa					.word Stack_Drop               ; $0032 drop
>a192	8d aa					.word Stack_Dup                ; $0033 dup
>a194	9e aa					.word Stack_Nip                ; $0034 nip
>a196	af aa					.word Stack_Over               ; $0035 over
>a198	c0 aa					.word Stack_Swap               ; $0036 swap
>a19a	07 af					.word Structure_Else           ; $0037 else
>a19c	f8 af					.word Struct_Index             ; $0038 index
>a19e	c4 ae					.word Command_Return           ; $0039 ;
>a1a0	5c ab					.word Command_Assert           ; $003a assert
>a1a2	0d a8					.word Cmd_List                 ; $003b list
>a1a4	21 ab					.word Command_New              ; $003c new
>a1a6	28 ab					.word Command_Old              ; $003d old
>a1a8	52 ab					.word Command_Stop             ; $003e stop
>a1aa	0d a2					.word ExecuteProgram           ; $003f run
>a1ac	4e ab					.word Command_End              ; $0040 end
>a1ae	b2 a1					.word SyntaxError              ; $0041 save
>a1b0	b2 a1					.word SyntaxError              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a1b2					SyntaxError:
.a1b2	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a1b5	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a1bc					ErrorHandler:
.a1bc	fa		plx				plx 								; pull address off.
.a1bd	7a		ply				ply
.a1be	e8		inx				inx 								; point to message
.a1bf	d0 01		bne $a1c2			bne 	_EHNoCarry
.a1c1	c8		iny				iny
.a1c2					_EHNoCarry:
.a1c2	20 f2 a1	jsr $a1f2			jsr 	PrintStringXY 				; print string at XY
.a1c5	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a1c7	f0 13		beq $a1dc			beq 	_EHNoLine
.a1c9	a2 e1		ldx #$e1			ldx 	#_EHMessage & $FF 			; print " AT "
.a1cb	a0 a1		ldy #$a1			ldy 	#_EHMessage >> 8
.a1cd	20 f2 a1	jsr $a1f2			jsr 	PrintStringXY
.a1d0	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a1d2	b1 00		lda ($00),y			lda 	(codePtr),y
.a1d4	aa		tax				tax
.a1d5	c8		iny				iny
.a1d6	b1 00		lda ($00),y			lda 	(codePtr),y
.a1d8	a8		tay				tay
.a1d9	20 e6 a1	jsr $a1e6			jsr 	PrintIntegerUnsigned
.a1dc					_EHNoLine:
.a1dc	80 fe		bra $a1dc			bra 	_EHNoLine
.a1de	4c 0d a0	jmp $a00d			jmp 	WarmStart
.a1e1					_EHMessage:
>a1e1	20 41 54 20 00					.text	" AT ",0
.a1e6					PrintIntegerUnsigned:
.a1e6	20 20 a5	jsr $a520			jsr 	IntToString
.a1e9	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a1eb	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a1ed	20 f2 a1	jsr $a1f2			jsr 	PrintStringXY
.a1f0	98		tya				tya
.a1f1	60		rts				rts
.a1f2					PrintStringXY:
.a1f2	86 02		stx $02				stx 	zTemp0
.a1f4	84 03		sty $03				sty 	zTemp0+1
.a1f6	a0 00		ldy #$00			ldy 	#0
.a1f8	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a1fa	f0 06		beq $a202			beq 	_PSExit
.a1fc	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a1ff	c8		iny				iny
.a200	80 f6		bra $a1f8			bra 	_PSLoop
.a202	60		rts		_PSExit:rts
.a203					PrintCharacter:
.a203	48		pha				pha
.a204	da		phx				phx
.a205	5a		phy				phy
.a206	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a209	7a		ply				ply
.a20a	fa		plx				plx
.a20b	68		pla				pla
.a20c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a20d					ExecuteProgram:
.a20d	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.a20f	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.a211					ExecuteFromXY:
.a211	20 1b a4	jsr $a41b			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a214	20 53 a4	jsr $a453			jsr 	StackReset 					; reset the CPU stack.
.a217	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a219	80 0a		bra $a225			bra 	ExecuteLoop
.a21b					ShortConstant:
.a21b	c8		iny				iny 								; skip short const
.a21c	e8		inx				inx 								; space on stack
.a21d	29 3f		and #$3f			and 	#$3F 						; the value
.a21f	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a222	9e 00 07	stz $0700,x			stz 	highStack,x
.a225					ExecuteLoop:
.a225	e6 14		inc $14				inc 	breakCount 					; check break sometimes.
.a227	d0 03		bne $a22c			bne 	_EXNoBreak
.a229	20 e0 a2	jsr $a2e0			jsr 	ExternCheckBreak
.a22c					_EXNoBreak:
.a22c	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a22e	f0 58		beq $a288			beq 	_ELUnderflow
.a230	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a232	30 07		bmi $a23b			bmi 	_ELNotToken
.a234	c8		iny				iny 								; skip the token
.a235	da		phx				phx 								; save X on the stack
.a236	0a		asl a				asl 	a 							; double the token, put into X
.a237	aa		tax				tax
.a238	7c 2c a1	jmp ($a12c,x)			jmp 	(DispatchHandler,x)
.a23b					_ELNotToken:
.a23b	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a23d	90 dc		bcc $a21b			bcc 	ShortConstant 				; yes, it's a short constant
.a23f	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a241	90 1e		bcc $a261			bcc 	_ELNotFastVariable
.a243	c8		iny				iny 								; get the next token.
.a244	b1 00		lda ($00),y			lda 	(codePtr),y
.a246	88		dey				dey
.a247	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a249	f0 16		beq $a261			beq 	_ELNotFastVariable 			; which we can optimise.
.a24b	5a		phy				phy 								; save Y
.a24c	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a24e	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a24f	a8		tay				tay 								; access via Y
.a250	e8		inx				inx 								; make space on the stack.
.a251	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a254	9d 00 06	sta $0600,x			sta 	lowStack,x
.a257	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a25a	9d 00 07	sta $0700,x			sta 	highStack,x
.a25d	7a		ply				ply 								; restore code pointer
.a25e	c8		iny				iny 								; skip variable.
.a25f	80 c4		bra $a225			bra 	ExecuteLoop
.a261					_ELNotFastVariable:
.a261	18		clc				clc									; do not autocreate if not found.
.a262	20 6b a5	jsr $a56b			jsr 	VariableFind				; find the variable.
.a265	90 14		bcc $a27b			bcc 	_ELUnknown
.a267	20 c1 a3	jsr $a3c1			jsr 	IndexCheck
.a26a	5a		phy				phy 								; copy to stack
.a26b	e8		inx				inx
.a26c	b2 02		lda ($02)			lda 	(zTemp0)
.a26e	9d 00 06	sta $0600,x			sta 	lowStack,x
.a271	a0 01		ldy #$01			ldy 	#1
.a273	b1 02		lda ($02),y			lda 	(zTemp0),y
.a275	9d 00 07	sta $0700,x			sta 	highStack,x
.a278	7a		ply				ply
.a279	80 aa		bra $a225			bra 	ExecuteLoop
.a27b					_ELUnknown:
>a27b	ff						.byte 	$FF
.a27c	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a27f	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a287	00
.a288					_ELUnderflow:
.a288	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a28b	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a292					ExecuteNextLine:
.a292					ExecuteComment:
.a292	fa		plx				plx
.a293	18		clc				clc 								; skip forward
.a294	b2 00		lda ($00)			lda 	(codePtr)
.a296	18		clc				clc
.a297	65 00		adc $00				adc 	codePtr
.a299	85 00		sta $00				sta 	codePtr
.a29b	90 02		bcc $a29f			bcc 	_ENLNoCarry
.a29d	e6 01		inc $01				inc 	codePtr+1
.a29f					_ENLNoCarry:
.a29f	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a2a1	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a2a3	d0 80		bne $a225			bne 	ExecuteLoop
.a2a5	4c 4e ab	jmp $ab4e			jmp	 	Command_End 				; if zero end program.
.a2a8					LongConstant:
.a2a8	fa		plx				plx
.a2a9	e8		inx				inx 								; space for constant
.a2aa	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a2ac	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2af	c8		iny				iny
.a2b0	b1 00		lda ($00),y			lda 	(codePtr),y
.a2b2	9d 00 07	sta $0700,x			sta 	highStack,x
.a2b5	c8		iny				iny
.a2b6	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.a2b9					StringConstant:
.a2b9	fa		plx				plx
.a2ba	e8		inx				inx
.a2bb	18		clc				clc 								; copy Y + codePtr in.
.a2bc	98		tya				tya
.a2bd	65 00		adc $00				adc 	codePtr
.a2bf	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2c2	a5 01		lda $01				lda 	codePtr+1
.a2c4	69 00		adc #$00			adc 	#0
.a2c6	9d 00 07	sta $0700,x			sta 	highStack,x
.a2c9	98		tya				tya 								; add 1 + length to Y
.a2ca	38		sec				sec
.a2cb	71 00		adc ($00),y			adc 	(codePtr),y
.a2cd	a8		tay				tay
.a2ce	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a2d1					ExternInitialise:
.a2d1	a9 07		lda #$07			lda 	#$07 						; set colour
.a2d3	8d 86 02	sta $0286			sta 	646
.a2d6	a9 93		lda #$93			lda 	#147 						; clear screen
.a2d8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2db	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a2dd	4c fe a2	jmp $a2fe			jmp 	ExternColour
.a2e0					ExternCheckBreak:
.a2e0	da		phx				phx 								; make sure we keep XY
.a2e1	5a		phy				phy
.a2e2	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a2e5	f0 03		beq $a2ea			beq		_ECBExit 					; stopped
.a2e7	7a		ply				ply 								; restore and exit.
.a2e8	fa		plx				plx
.a2e9	60		rts				rts
.a2ea					_ECBExit:
.a2ea	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a2ed	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a2f4					ExternPrint:
.a2f4	48		pha				pha
.a2f5	da		phx				phx
.a2f6	5a		phy				phy
.a2f7	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2fa	7a		ply				ply
.a2fb	fa		plx				plx
.a2fc	68		pla				pla
.a2fd	60		rts				rts
.a2fe					ExternColour:
.a2fe	48		pha				pha
.a2ff	da		phx				phx
.a300	48		pha				pha
.a301	29 08		and #$08			and 	#8
.a303	0a		asl a				asl 	a
.a304	0a		asl a				asl 	a
.a305	0a		asl a				asl 	a
.a306	0a		asl a				asl 	a
.a307	49 92		eor #$92			eor 	#$92
.a309	20 f4 a2	jsr $a2f4			jsr 	ExternPrint
.a30c	a9 0e		lda #$0e			lda 	#14							; lower case
.a30e	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a311	68		pla				pla
.a312	29 07		and #$07			and 	#7
.a314	aa		tax				tax
.a315	bd 1e a3	lda $a31e,x			lda 	_ECTable,x
.a318	20 f4 a2	jsr $a2f4			jsr 	ExternPrint
.a31b	fa		plx				plx
.a31c	68		pla				pla
.a31d	60		rts				rts
.a31e					_ECTable:
>a31e	90						.byte 	144
>a31f	1c						.byte 	28
>a320	1e						.byte 	30
>a321	9e						.byte 	158
>a322	1f						.byte 	31
>a323	9c						.byte 	156
>a324	9f						.byte 	159
>a325	05						.byte 	5
.a326					ExternInput:
.a326	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a328	85 02		sta $02				sta 	zTemp0
.a32a	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a32c	85 03		sta $03				sta 	zTemp0+1
.a32e	a9 07		lda #$07			lda 	#COL_WHITE
.a330	20 fe a2	jsr $a2fe			jsr 	ExternColour
.a333	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a336	29 7f		and #$7f			and 	#$7F
.a338	c9 0d		cmp #$0d			cmp 	#13
.a33a	f0 0a		beq $a346			beq 	_EIExit
.a33c	92 02		sta ($02)			sta 	(zTemp0)
.a33e	e6 02		inc $02				inc 	zTemp0
.a340	d0 f1		bne $a333			bne 	_EIRead
.a342	e6 03		inc $03				inc 	zTemp0+1
.a344	80 ed		bra $a333			bra 	_EIRead
.a346	a9 00		lda #$00	_EIExit:lda 	#0
.a348	92 02		sta ($02)			sta 	(zTemp0)
.a34a	a9 0d		lda #$0d			lda 	#13
.a34c	20 f4 a2	jsr $a2f4			jsr 	ExternPrint
.a34f	60		rts				rts
.a350					ExternSave:
.a350	da		phx				phx
.a351	5a		phy				phy
.a352	85 06		sta $06				sta 	zTemp2 						; save start
.a354	84 07		sty $07				sty 	zTemp2+1
.a356	20 b8 a3	jsr $a3b8			jsr 	EXGetLength 				; get length of file into A
.a359	a6 02		ldx $02				ldx 	zTemp0
.a35b	a4 03		ldy $03				ldy 	zTemp0+1
.a35d	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a360	a9 01		lda #$01			lda 	#1
.a362	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a364	a0 00		ldy #$00			ldy 	#0
.a366	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a369	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a36b	a4 05		ldy $05				ldy 	zTemp1+1
.a36d	a9 06		lda #$06			lda 	#zTemp2
.a36f	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a372	b0 03		bcs $a377			bcs 	_ESSave
.a374	7a		ply				ply
.a375	fa		plx				plx
.a376	60		rts				rts
.a377					_ESSave:
.a377	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a37a	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a382	4c 45 44 00
.a386					ExternLoad:
.a386	da		phx				phx 								; save XY
.a387	5a		phy				phy
.a388	48		pha				pha 								; save target
.a389	5a		phy				phy
.a38a	20 b8 a3	jsr $a3b8			jsr 	EXGetLength 				; get length of file into A
.a38d	a6 02		ldx $02				ldx 	zTemp0
.a38f	a4 03		ldy $03				ldy 	zTemp0+1
.a391	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a394	a9 01		lda #$01			lda 	#1
.a396	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a398	a0 00		ldy #$00			ldy 	#0
.a39a	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a39d	7a		ply				ply 								; restore target to YX and call load
.a39e	fa		plx				plx
.a39f	a9 00		lda #$00			lda 	#0 							; load command
.a3a1	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a3a4	b0 03		bcs $a3a9			bcs 	_ESLoad
.a3a6	7a		ply				ply
.a3a7	fa		plx				plx
.a3a8	60		rts				rts
.a3a9					_ESLoad:
.a3a9	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a3ac	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a3b4	4c 45 44 00
.a3b8					EXGetLength:
.a3b8	a0 ff		ldy #$ff			ldy 	#255
.a3ba	c8		iny		_EXGL:	iny
.a3bb	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3bd	d0 fb		bne $a3ba			bne 	_EXGL
.a3bf	98		tya				tya
.a3c0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a3c1					IndexCheck:
.a3c1	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a3c3	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a3c5	f0 01		beq $a3c8			beq 	_ICFound
.a3c7	60		rts				rts
.a3c8					_ICFound:
.a3c8	c8		iny				iny 							; get next
.a3c9	b1 00		lda ($00),y			lda 	(codePtr),y
.a3cb	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a3cd	f0 2b		beq $a3fa			beq 	_ICStackIndex
.a3cf	38		sec				sec
.a3d0	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a3d2	c9 40		cmp #$40			cmp 	#$40
.a3d4	b0 1a		bcs $a3f0			bcs 	_ICError
.a3d6	0a		asl a				asl 	a 						; double index clear carry
.a3d7	5a		phy				phy 							; put into Y
.a3d8	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a3da	48		pha				pha
.a3db	a0 01		ldy #$01			ldy 	#1
.a3dd	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3df	69 00		adc #$00			adc 	#0
.a3e1	85 03		sta $03				sta 	zTemp0+1
.a3e3	68		pla				pla
.a3e4	85 02		sta $02				sta 	zTemp0
.a3e6	7a		ply				ply 							; restore position.
.a3e7	c8		iny				iny								; skip index
.a3e8	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a3ea	c8		iny				iny
.a3eb	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a3ed	d0 01		bne $a3f0			bne 	_ICError
.a3ef	60		rts				rts
.a3f0					_ICError:
.a3f0	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a3f3	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a3fa					_ICStackIndex:
.a3fa	c8		iny				iny 							; skip the ]
.a3fb	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a3fe	0a		asl a				asl 	a
.a3ff	85 04		sta $04				sta 	zTemp1
.a401	bd 00 07	lda $0700,x			lda 	highStack,x
.a404	2a		rol a				rol 	a
.a405	85 05		sta $05				sta 	zTemp1+1
.a407	ca		dex				dex 							; throw TOS.
.a408	5a		phy				phy
.a409	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a40b	b2 02		lda ($02)			lda 	(zTemp0)
.a40d	65 04		adc $04				adc 	zTemp1
.a40f	48		pha				pha
.a410	b1 02		lda ($02),y			lda 	(zTemp0),y
.a412	65 05		adc $05				adc 	zTemp1+1
.a414	85 03		sta $03				sta 	zTemp0+1
.a416	68		pla				pla
.a417	85 02		sta $02				sta 	zTemp0
.a419	7a		ply				ply 							; restore pos and exit.
.a41a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a41b					ResetMemory:
.a41b	da		phx				phx									; save run address
.a41c	5a		phy				phy
.a41d	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a41f	85 0d		sta $0d				sta 	allocPtr
.a421	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a423	85 0e		sta $0e				sta 	allocPtr+1
.a425	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a427	85 0f		sta $0f				sta 	memVarPtr
.a429	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a42b	85 10		sta $10				sta 	memVarPtr+1
.a42d					_RMFindEnd:
.a42d	b2 0f		lda ($0f)			lda 	(memVarPtr)					; offset 0, found end.
.a42f	f0 0b		beq $a43c			beq 	_RMFoundEnd 				; advance to next.
.a431	18		clc				clc
.a432	65 0f		adc $0f				adc 	memVarPtr
.a434	85 0f		sta $0f				sta 	memVarPtr
.a436	90 f5		bcc $a42d			bcc 	_RMFindEnd
.a438	e6 10		inc $10				inc 	memVarPtr+1
.a43a	80 f1		bra $a42d			bra 	_RMFindEnd
.a43c					_RMFoundEnd:
.a43c	e6 0f		inc $0f				inc 	memVarPtr 					; advance past last offset $00
.a43e	d0 02		bne $a442			bne 	_RMNoCarry
.a440	e6 10		inc $10				inc 	memVarPtr+1
.a442					_RMNoCarry:
.a442	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a444					_RMEraseHash:
.a444	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a447	ca		dex				dex
.a448	10 fa		bpl $a444			bpl 	_RMEraseHash
.a44a	7a		ply				ply 								; restore and set run address
.a44b	fa		plx				plx
.a44c	84 01		sty $01				sty 	codePtr+1
.a44e	86 00		stx $00				stx 	codePtr
.a450	a0 03		ldy #$03			ldy 	#3
.a452	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a453					StackReset:
.a453	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a455	85 0a		sta $0a				sta 	iStack
.a457	a9 09		lda #$09			lda 	#IntStack >> 8
.a459	85 0b		sta $0b				sta 	iStack+1
.a45b	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a45d	92 0a		sta ($0a)			sta 	(iStack)
.a45f	60		rts				rts
.a460					StackPushByte:
.a460	c6 0a		dec $0a				dec 	iStack
.a462	92 0a		sta ($0a)			sta 	(iStack)
.a464	f0 01		beq $a467			beq 	_SPBUnderflow
.a466	60		rts				rts
.a467					_SPBUnderflow:
.a467	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a46a	53 54 41 43 4b 00				.text 	"STACK",0
.a470					StackPushPosition:
.a470	98		tya				tya
.a471	20 60 a4	jsr $a460			jsr 	StackPushByte
.a474	a5 01		lda $01				lda 	codePtr+1
.a476	20 60 a4	jsr $a460			jsr 	StackPushByte
.a479	a5 00		lda $00				lda 	codePtr
.a47b	20 60 a4	jsr $a460			jsr 	StackPushByte
.a47e	60		rts				rts
.a47f					StackCheckTop:
.a47f	d2 0a		cmp ($0a)			cmp 	(iStack)
.a481	f0 02		beq $a485			beq 	_SCTOk
.a483	18		clc				clc
.a484	60		rts				rts
.a485	38		sec		_SCTOk:	sec
.a486	60		rts				rts
.a487					StackPop:
.a487	18		clc				clc
.a488	65 0a		adc $0a				adc 	iStack
.a48a	85 0a		sta $0a				sta 	iStack
.a48c	60		rts				rts
.a48d					StackRestorePosition:
.a48d	b1 0a		lda ($0a),y			lda 	(iStack),y
.a48f	85 00		sta $00				sta 	codePtr
.a491	c8		iny				iny
.a492	b1 0a		lda ($0a),y			lda 	(iStack),y
.a494	85 01		sta $01				sta 	codePtr+1
.a496	c8		iny				iny
.a497	b1 0a		lda ($0a),y			lda 	(iStack),y
.a499	a8		tay				tay
.a49a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a49b					StringToInt:
.a49b	86 08		stx $08				stx 	zTemp3 						; save string
.a49d	84 09		sty $09				sty 	zTemp3+1
.a49f	64 0c		stz $0c				stz 	signCount 					; signcount is the number of chars copied.
.a4a1	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a4a3	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a4a5	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a4a7	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a4a9	f0 03		beq $a4ae			beq 	_STIConvert 				; convert from character 1, base 16.
.a4ab	88		dey				dey 								; from character 0
.a4ac	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a4ae					_STIConvert:
.a4ae	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a4b0	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a4b2	f0 5f		beq $a513			beq 	_STIFail 					; if zero, then it has failed anyway.
.a4b4	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a4b6	64 03		stz $03				stz 	zTemp0+1
.a4b8					_STILoop:
.a4b8	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a4ba	c9 30		cmp #$30			cmp 	#"0"
.a4bc	90 55		bcc $a513			bcc 	_STIFail
.a4be	c9 3a		cmp #$3a			cmp 	#"9"+1
.a4c0	90 08		bcc $a4ca			bcc 	_STIOkay
.a4c2	c9 41		cmp #$41			cmp 	#"A"
.a4c4	90 4d		bcc $a513			bcc 	_STIFail
.a4c6	c9 47		cmp #$47			cmp 	#"F"+1
.a4c8	b0 49		bcs $a513			bcs 	_STIFail
.a4ca					_STIOkay:
.a4ca	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a4cc	85 06		sta $06				sta 	zTemp2
.a4ce	a5 03		lda $03				lda 	zTemp0+1
.a4d0	85 07		sta $07				sta 	zTemp2+1
.a4d2	64 02		stz $02				stz 	zTemp0 						; clear result
.a4d4	64 03		stz $03				stz 	zTemp0+1
.a4d6	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a4d8					_STIMultiply:
.a4d8	8a		txa				txa 								; shift Y right into carry.
.a4d9	4a		lsr a				lsr 	a
.a4da	aa		tax				tax
.a4db	90 0d		bcc $a4ea			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a4dd	18		clc				clc
.a4de	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a4e0	65 02		adc $02				adc 	zTemp0
.a4e2	85 02		sta $02				sta 	zTemp0
.a4e4	a5 07		lda $07				lda 	zTemp2+1
.a4e6	65 03		adc $03				adc 	zTemp0+1
.a4e8	85 03		sta $03				sta 	zTemp0+1
.a4ea					_STINoAdd:
.a4ea	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a4ec	26 07		rol $07				rol 	zTemp2+1
.a4ee	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a4f0	d0 e6		bne $a4d8			bne 	_STIMultiply
.a4f2	38		sec				sec 								; hex adjust
.a4f3	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a4f5	c9 3a		cmp #$3a			cmp 	#58
.a4f7	90 03		bcc $a4fc			bcc 	_STIDecimal
.a4f9	38		sec				sec
.a4fa	e9 07		sbc #$07			sbc 	#7
.a4fc					_STIDecimal:
.a4fc	38		sec				sec
.a4fd	e9 30		sbc #$30			sbc 	#48
.a4ff	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a501	b0 10		bcs $a513			bcs 	_STIFail
.a503	d8		cld				cld
.a504	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a506	85 02		sta $02				sta 	zTemp0
.a508	90 02		bcc $a50c			bcc 	_STINoCarry
.a50a	e6 03		inc $03				inc 	zTemp0+1
.a50c					_STINoCarry:
.a50c	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a50e	c8		iny				iny 								; point to next
.a50f	e6 0c		inc $0c				inc 	SignCount
.a511	80 a5		bra $a4b8			bra 	_STILoop 					; and go round again.
.a513					_STIFail:
.a513	a5 0c		lda $0c				lda 	SignCount 					; if converted 0 charactes, fail.
.a515	f0 07		beq $a51e			beq 	_STINoConvert
.a517	98		tya				tya 								; convert count in A.
.a518	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a51a	a4 03		ldy $03				ldy 	zTemp0+1
.a51c	38		sec				sec
.a51d	60		rts				rts
.a51e					_STINoConvert:
.a51e	18		clc				clc
.a51f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a520					IntToString:
.a520	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a522	84 03		sty $03				sty 	zTemp0+1
.a524	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a526	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a528					_ITSLoop:
.a528	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a52a					_ITSSubtractLoop:
.a52a	38		sec				sec
.a52b	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a52d	fd 63 a5	sbc $a563,x			sbc 	_ITSWords,x
.a530	48		pha				pha
.a531	a5 03		lda $03				lda 	zTemp0+1
.a533	fd 64 a5	sbc $a564,x			sbc 	_ITSWords+1,x
.a536	90 09		bcc $a541			bcc 	_ITSEndSub 					; can't subtract any more.
.a538	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a53a	68		pla				pla
.a53b	85 02		sta $02				sta 	zTemp0
.a53d	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a53f	80 e9		bra $a52a			bra 	_ITSSubtractLoop
.a541					_ITSEndSub:
.a541	68		pla				pla 								; throw away the interim result
.a542	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a544	d0 04		bne $a54a			bne 	_ITSWriteOut 				; always write it out
.a546	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a548	f0 06		beq $a550			beq 	_ITSNext 					; suppressing leading zeros.
.a54a					_ITSWriteOut:
.a54a	09 30		ora #$30			ora 	#48 						; output digit.
.a54c	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a54f	c8		iny				iny
.a550					_ITSNext:
.a550	e8		inx				inx
.a551	e8		inx				inx
.a552	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a554	d0 d2		bne $a528			bne 	_ITSLoop 					; do the new digits
.a556	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a558	09 30		ora #$30			ora 	#48
.a55a	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a55d	a9 00		lda #$00			lda 	#0
.a55f	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a562	60		rts				rts
.a563					_ITSWords:
>a563	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a56b					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a56b					VariableFind:
.a56b	da		phx				phx 								; save the stack position
.a56c	08		php				php 								; save the create flag
.a56d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a56f	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a571	90 10		bcc $a583			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a573	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a575	0a		asl a				asl 	a 							; double clear carry
.a576	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a578	85 02		sta $02				sta 	zTemp0
.a57a	a9 0f		lda #$0f			lda		#FastVariables >>8
.a57c	85 03		sta $03				sta 	zTemp0+1
.a57e	28		plp				plp 								; create flag is irrelevant.
.a57f	fa		plx				plx									; restore the old stack position
.a580	c8		iny				iny 								; skip over the single identifier character
.a581	38		sec				sec 								; return with CS
.a582	60		rts				rts
.a583					_VFIsNotFastVariable:
.a583	20 55 a6	jsr $a655			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a586	20 b0 a5	jsr $a5b0			jsr 	VFSearch 					; try to find the variable.
.a589	b0 0d		bcs $a598			bcs 	_VFEndSearch 				; found it, so exit
.a58b	28		plp				plp 								; do we want autocreate
.a58c	b0 03		bcs $a591			bcs 	_VFCreate
.a58e	fa		plx				plx 								; restore stack position and return CC
.a58f	18		clc				clc
.a590	60		rts				rts
.a591					_VFCreate:
.a591	20 55 a6	jsr $a655			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a594	20 ec a5	jsr $a5ec			jsr 	VFCreate 					; create a new record and link it in.
.a597	08		php				php 								; save a dummy P to be popped.
.a598					_VFEndSearch:
.a598	18		clc				clc 								; the data is at offset + 4
.a599	a5 04		lda $04				lda 	zTemp1
.a59b	69 04		adc #$04			adc 	#4
.a59d	85 02		sta $02				sta 	zTemp0
.a59f	a5 05		lda $05				lda 	zTemp1+1
.a5a1	69 00		adc #$00			adc 	#0
.a5a3	85 03		sta $03				sta 	zTemp0+1
.a5a5	28		plp				plp 								; dump the create flag
.a5a6					_VFSkipExit:
.a5a6	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a5a8	c8		iny				iny
.a5a9	c9 e0		cmp #$e0			cmp 	#$E0
.a5ab	90 f9		bcc $a5a6			bcc 	_VFSkipExit
.a5ad	fa		plx				plx 								; restore X
.a5ae	38		sec				sec
.a5af	60		rts				rts
.a5b0					VFSearch:
.a5b0	48		pha				pha 								; save AXY.
.a5b1	da		phx				phx
.a5b2	5a		phy				phy
.a5b3	98		tya				tya									; add Y to codePtr, put in zTemp2
.a5b4	18		clc				clc 								; so it points to the identifier.
.a5b5	65 00		adc $00				adc 	codePtr
.a5b7	85 06		sta $06				sta 	zTemp2
.a5b9	a5 01		lda $01				lda 	codePtr+1
.a5bb	69 00		adc #$00			adc 	#0
.a5bd	85 07		sta $07				sta 	zTemp2+1
.a5bf					_VFSLoop:
.a5bf	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a5c1	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a5c3	f0 22		beq $a5e7			beq 	_VFSFailed 					; failed.
.a5c5	aa		tax				tax 								; MSB in X
.a5c6	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a5c8	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a5ca	86 05		stx $05				stx 	zTemp1+1
.a5cc	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a5ce	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5d0	85 08		sta $08				sta 	zTemp3
.a5d2	c8		iny				iny
.a5d3	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5d5	85 09		sta $09				sta 	zTemp3+1
.a5d7	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a5d9					_VFSCheckName:
.a5d9	c8		iny				iny
.a5da	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a5dc	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a5de	d0 df		bne $a5bf			bne 	_VFSLoop
.a5e0	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a5e2	90 f5		bcc $a5d9			bcc 	_VFSCheckName
.a5e4	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a5e5	80 01		bra $a5e8			bra		_VFSExit
.a5e7					_VFSFailed:
.a5e7	18		clc				clc
.a5e8					_VFSExit:
.a5e8	7a		ply				ply 								; restore registers and exit.
.a5e9	fa		plx				plx
.a5ea	68		pla				pla
.a5eb	60		rts				rts
.a5ec					VFCreate:
.a5ec	48		pha				pha 								; save registers
.a5ed	da		phx				phx
.a5ee	5a		phy				phy
.a5ef	18		clc				clc 								; add 6 to memVarPtr, saving its
.a5f0	a5 0f		lda $0f				lda 	memVarPtr 					; address in zTemp0 as we go.
.a5f2	85 02		sta $02				sta 	zTemp0
.a5f4	69 06		adc #$06			adc 	#6
.a5f6	85 0f		sta $0f				sta 	memVarPtr
.a5f8	a5 10		lda $10				lda 	memVarPtr+1
.a5fa	85 03		sta $03				sta 	zTemp0+1
.a5fc	69 00		adc #$00			adc 	#0
.a5fe	85 10		sta $10				sta 	memVarPtr+1
.a600	c5 0e		cmp $0e				cmp 	allocPtr+1 					; out of memory ?
.a602	f0 46		beq $a64a			beq 	_VFCMemory
.a604	98		tya				tya 								; work out identifier address
.a605	18		clc				clc
.a606	65 00		adc $00				adc 	codePtr
.a608	48		pha				pha
.a609	c8		iny				iny
.a60a	a5 01		lda $01				lda 	codePtr+1
.a60c	69 00		adc #$00			adc 	#0
.a60e	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.a610	b0 0b		bcs $a61d			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.a612	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a615	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.a61d					_VFCInProgram:
.a61d	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a61f	91 02		sta ($02),y			sta 	(zTemp0),y
.a621	88		dey				dey
.a622	68		pla				pla
.a623	91 02		sta ($02),y			sta 	(zTemp0),y
.a625	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a627	a9 00		lda #$00			lda 	#0
.a629	91 02		sta ($02),y			sta 	(zTemp0),y
.a62b	c8		iny				iny
.a62c	91 02		sta ($02),y			sta 	(zTemp0),y
.a62e	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a630	b2 04		lda ($04)			lda 	(zTemp1)
.a632	92 02		sta ($02)			sta 	(zTemp0)
.a634	b1 04		lda ($04),y			lda 	(zTemp1),y
.a636	91 02		sta ($02),y			sta 	(zTemp0),y
.a638	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a63a	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a63c	a5 03		lda $03				lda 	zTemp0+1
.a63e	91 04		sta ($04),y			sta 	(zTemp1),y
.a640	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a642	a5 02		lda $02				lda 	zTemp0
.a644	85 04		sta $04				sta 	zTemp1
.a646	7a		ply				ply
.a647	fa		plx				plx
.a648	68		pla				pla
.a649	60		rts				rts
.a64a					_VFCMemory:
.a64a	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a64d	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a655					VFSetupHashPointer:
.a655	48		pha				pha
.a656	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a658	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a65a	0a		asl a				asl 	a 							; double it, also clears carry
.a65b	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a65d	85 04		sta $04				sta 	zTemp1
.a65f	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a661	85 05		sta $05				sta 	zTemp1+1
.a663	68		pla				pla
.a664	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.a665					TokeniseInputBuffer:
.a665	48		pha				pha
.a666	da		phx				phx
.a667	5a		phy				phy
.a668	64 15		stz $15				stz 	TokenOffset					; reset index into TokenBuffer
.a66a	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.a66d	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.a66f	20 d1 a6	jsr $a6d1			jsr 	TokWriteToken
.a672	20 d1 a6	jsr $a6d1			jsr 	TokWriteToken
.a675	20 d1 a6	jsr $a6d1			jsr 	TokWriteToken
.a678	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.a67a					_TIBForward:
.a67a	e8		inx				inx
.a67b	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a67e	d0 fa		bne $a67a			bne 	_TIBForward
.a680					_TIBBackward:
.a680	ca		dex				dex 								; back one.
.a681	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.a683	f0 48		beq $a6cd			beq 	_TIBExit					; return empty buffer
.a685	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a688	c9 20		cmp #$20			cmp 	#" "
.a68a	f0 f4		beq $a680			beq 	_TIBBackward
.a68c	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.a68f	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.a691					_TIBMainLoop:
.a691	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.a694	f0 37		beq $a6cd			beq 	_TIBExit 					; done the buffer if zero.
.a696	e8		inx				inx
.a697	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.a699	f0 f6		beq $a691			beq 	_TIBMainLoop
.a69b	ca		dex				dex 								; undo the last inx.
.a69c	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.a69e	f0 08		beq $a6a8			beq 	_TIBConstant
.a6a0	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.a6a2	90 09		bcc $a6ad			bcc 	_TIBNotConstant
.a6a4	c9 3a		cmp #$3a			cmp 	#"9"+1
.a6a6	b0 05		bcs $a6ad			bcs 	_TIBNotConstant
.a6a8					_TIBConstant:
.a6a8	20 02 a7	jsr $a702			jsr 	TOKConvertConstant
.a6ab	80 e4		bra $a691			bra 	_TIBMainLoop
.a6ad					_TIBNotConstant:
.a6ad	c9 3a		cmp #$3a			cmp 	#":"						; definition
.a6af	d0 05		bne $a6b6			bne 	_TIBNotDefinition
.a6b1	20 54 a7	jsr $a754			jsr 	TOKConvertDefinition
.a6b4	80 db		bra $a691			bra 	_TIBMainLoop
.a6b6					_TIBNotDefinition:
.a6b6	c9 27		cmp #$27			cmp 	#"'"
.a6b8	f0 04		beq $a6be			beq 	_TIBIsCommentString
.a6ba	c9 22		cmp #$22			cmp 	#'"'
.a6bc	d0 05		bne $a6c3			bne 	_TIBNotCommentString
.a6be					_TIBIsCommentString:
.a6be	20 7c a7	jsr $a77c			jsr 	TOKConvertCommentString
.a6c1	80 ce		bra $a691			bra 	_TIBMainLoop
.a6c3					_TIBNotCommentString:
.a6c3	20 c3 a7	jsr $a7c3			jsr 	TOKCheckIsToken 			; check if a token.
.a6c6	b0 c9		bcs $a691			bcs 	_TIBMainLoop
.a6c8	20 55 a7	jsr $a755			jsr 	TOKConvertIdentifierOnly
.a6cb	80 c4		bra $a691			bra 	_TIBMainLoop
.a6cd					_TIBExit:
.a6cd	7a		ply				ply
.a6ce	fa		plx				plx
.a6cf	68		pla				pla
.a6d0	60		rts				rts
.a6d1					TOKWriteToken:
.a6d1	da		phx				phx
.a6d2	a6 15		ldx $15				ldx 	TokenOffset
.a6d4	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.a6d7	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.a6da	e6 15		inc $15				inc 	TokenOffset
.a6dc	fa		plx				plx
.a6dd	60		rts				rts
.a6de					TOKFixUpLast:
.a6de	da		phx				phx
.a6df	a6 15		ldx $15				ldx 	TokenOffset
.a6e1	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.a6e4	09 e0		ora #$e0			ora 	#$E0
.a6e6	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.a6e9	fa		plx				plx
.a6ea	60		rts				rts
.a6eb					TOKConvertIdentifier:
.a6eb	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.a6ed	f0 0f		beq $a6fe			beq 	_TKCIDot
.a6ef	38		sec				sec 								; A-Z -> 1-27
.a6f0	e9 40		sbc #$40			sbc 	#64
.a6f2	f0 08		beq $a6fc			beq 	_TKCIFail
.a6f4	c9 1b		cmp #$1b			cmp 	#27
.a6f6	b0 04		bcs $a6fc			bcs 	_TKCIFail
.a6f8	09 c0		ora #$c0			ora 	#$C0 						; fix up
.a6fa	38		sec				sec
.a6fb	60		rts				rts
.a6fc					_TKCIFail:
.a6fc	18		clc				clc
.a6fd	60		rts				rts
.a6fe					_TKCIDot:
.a6fe	a9 db		lda #$db			lda 	#$C0+27
.a700	38		sec				sec
.a701	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.a702					TOKConvertConstant:
.a702	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.a704	da		phx				phx 								; save X position
.a705	20 9b a4	jsr $a49b			jsr 	StringToInt 				; try to convert
.a708	90 40		bcc $a74a			bcc 	_TKCCError
.a70a	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.a70c	86 02		stx $02				stx 	zTemp0
.a70e	85 04		sta $04				sta 	zTemp1 						; save count
.a710	68		pla				pla 								; restore X position, add the count
.a711	18		clc				clc
.a712	65 04		adc $04				adc 	zTemp1
.a714	aa		tax				tax
.a715	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.a718	c9 2d		cmp #$2d			cmp 	#"-"
.a71a	d0 0e		bne $a72a			bne 	_TKCCNotNegative
.a71c	e8		inx				inx 								; consume the -
.a71d	38		sec				sec
.a71e	a9 00		lda #$00			lda 	#0 							; negate the constant.
.a720	e5 02		sbc $02				sbc 	zTemp0
.a722	85 02		sta $02				sta 	zTemp0
.a724	a9 00		lda #$00			lda 	#0
.a726	e5 03		sbc $03				sbc 	zTemp0+1
.a728	85 03		sta $03				sta 	zTemp0+1
.a72a					_TKCCNotNegative:
.a72a	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.a72c	d0 0c		bne $a73a			bne 	_TKCCLongConstant
.a72e	a5 02		lda $02				lda 	zTemp0
.a730	c9 40		cmp #$40			cmp 	#$40
.a732	b0 06		bcs $a73a			bcs 	_TKCCLongConstant
.a734	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.a736	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a739	60		rts				rts
.a73a					_TKCCLongConstant:
.a73a	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.a73c	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a73f	a5 02		lda $02				lda 	zTemp0
.a741	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a744	a5 03		lda $03				lda 	zTemp0+1
.a746	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a749	60		rts				rts
.a74a					_TKCCError:
.a74a	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a74d	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.a754					TOKConvertDefinition:
.a754	e8		inx				inx 								; skip over :
.a755					TOKConvertIdentifierOnly:
.a755	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get first and check there's at least one.
.a758	20 eb a6	jsr $a6eb			jsr 	TOKConvertIdentifier
.a75b	90 10		bcc $a76d			bcc 	_TKCDFail
.a75d					_TKCDLoop:
.a75d	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken 				; write last one out
.a760	e8		inx				inx									; skip over it, get next and check
.a761	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a764	20 eb a6	jsr $a6eb			jsr 	TOKConvertIdentifier
.a767	b0 f4		bcs $a75d			bcs 	_TKCDLoop 					; keep going while identifier present.
.a769	20 de a6	jsr $a6de			jsr 	TOKFixUpLast 				; set bit for last character.
.a76c	60		rts				rts
.a76d					_TKCDFail:
.a76d	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a770	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>a778	45 52 3f 00

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.a77c					TOKConvertCommentString:
.a77c	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.a77e	f0 06		beq $a786			beq 	_TKCCSComment
.a780	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.a782	a0 22		ldy #$22			ldy 	#'"'						; match character
.a784	80 04		bra $a78a			bra 	_TKCCSContinue
.a786					_TKCCSComment:
.a786	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.a788	a0 00		ldy #$00			ldy 	#0 							; match character
.a78a					_TKCCSContinue:
.a78a	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken 				; write initial token
.a78d	e8		inx				inx 								; skip over ' or "
.a78e	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.a790	a0 00		ldy #$00			ldy 	#0 							; count of characters
.a792	da		phx				phx 								; save start position
.a793					_TKCCSFindSize:
.a793	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.a796	c5 02		cmp $02				cmp 	zTemp0
.a798	f0 10		beq $a7aa			beq 	_TKCCSFoundEnd
.a79a	e8		inx				inx 								; bump pos, count
.a79b	c8		iny				iny
.a79c	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.a79e	d0 f3		bne $a793			bne 	_TKCCSFindSize
.a7a0	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>a7a3	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.a7aa					_TKCCSFoundEnd:
.a7aa	98		tya				tya 								; length of element in Y
.a7ab	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a7ae	fa		plx				plx 								; restore start position and copy out
.a7af					_TKCCSCopyOut:
.a7af	c0 00		cpy #$00			cpy 	#0 							; complete ?
.a7b1	f0 0a		beq $a7bd			beq 	_TKCCSExit
.a7b3	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a7b6	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken
.a7b9	e8		inx				inx
.a7ba	88		dey				dey
.a7bb	80 f2		bra $a7af			bra 	_TKCCSCopyOut
.a7bd					_TKCCSExit:
.a7bd	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.a7bf	f0 01		beq $a7c2			beq 	_TKCSSNotComment
.a7c1	e8		inx				inx
.a7c2					_TKCSSNotComment:
.a7c2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.a7c3					TOKCheckIsToken:
.a7c3	a9 36		lda #$36			lda 	#(KeywordText) & $FF
.a7c5	85 02		sta $02				sta 	zTemp0
.a7c7	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a7c9	85 03		sta $03				sta 	zTemp0+1
.a7cb	64 04		stz $04				stz 	zTemp1 						; best match length
.a7cd	64 06		stz $06				stz 	zTemp2 						; current token.
.a7cf					_TCTLoop:
.a7cf	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.a7d1	da		phx				phx 								; save start
.a7d2					_TCTCompare:
.a7d2	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.a7d4	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.a7d7	e8		inx				inx 								; bump both pointers.
.a7d8	c8		iny				iny
.a7d9	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.a7da	d0 0e		bne $a7ea			bne 	_TCTNext 					; different, go to next.
.a7dc	90 f4		bcc $a7d2			bcc 	_TCTCompare 				; still comparing.
.a7de	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.a7e0	c5 04		cmp $04				cmp 	zTemp1						; best so far
.a7e2	90 06		bcc $a7ea			bcc 	_TCTNext 					; if not, skip to next.
.a7e4	85 04		sta $04				sta 	zTemp1 						; new best score
.a7e6	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.a7e8	85 07		sta $07				sta 	zTemp2+1
.a7ea					_TCTNext:
.a7ea	fa		plx				plx 								; restore start position.
.a7eb	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.a7ed	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.a7ef	38		sec				sec
.a7f0	65 02		adc $02				adc 	zTemp0
.a7f2	85 02		sta $02				sta 	zTemp0
.a7f4	90 02		bcc $a7f8			bcc		_TCTNoCarry
.a7f6	e6 03		inc $03				inc 	zTemp0+1
.a7f8					_TCTNoCarry:
.a7f8	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.a7fa	d0 d3		bne $a7cf			bne 	_TCTLoop 					; no, check the next keyword.
.a7fc	18		clc				clc
.a7fd	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.a7ff	f0 0b		beq $a80c			beq 	_TCTExit
.a801	8a		txa				txa 								; add that length to the input index.
.a802	18		clc				clc
.a803	65 04		adc $04				adc 	zTemp1
.a805	aa		tax				tax
.a806	a5 07		lda $07				lda 	zTemp2+1 					; token number
.a808	20 d1 a6	jsr $a6d1			jsr 	TOKWriteToken 				; write it out.
.a80b	38		sec				sec 								; set carry and exit
.a80c					_TCTExit:
.a80c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a80d					Cmd_List:
.a80d	fa		plx				plx
.a80e	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a810	64 07		stz $07				stz 	zTemp2+1
.a812	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.a814	f0 0b		beq $a821			beq 	_CLNoStart
.a816	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.a819	85 06		sta $06				sta 	zTemp2
.a81b	bd 00 07	lda $0700,x			lda 	highStack,x
.a81e	85 07		sta $07				sta 	zTemp2+1
.a820	ca		dex				dex
.a821					_CLNoStart:
.a821	a9 02		lda #$02			lda 	#COL_GREEN
.a823	20 fe a2	jsr $a2fe			jsr 	ExternColour
.a826					_CLNoStartLine:
.a826	a9 00		lda #$00			lda 	#(programStart) & $FF
.a828	85 00		sta $00				sta 	codePtr
.a82a	a9 10		lda #$10			lda 	#(programStart) >> 8
.a82c	85 01		sta $01				sta 	codePtr+1
.a82e					_CLILoop:
.a82e	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a830	f0 24		beq $a856			beq 	_CLIEnd
.a832	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a834	38		sec				sec
.a835	b1 00		lda ($00),y			lda 	(codePtr),y
.a837	e5 06		sbc $06				sbc 	zTemp2
.a839	c8		iny				iny
.a83a	b1 00		lda ($00),y			lda 	(codePtr),y
.a83c	e5 07		sbc $07				sbc 	zTemp2+1
.a83e	90 09		bcc $a849			bcc 	_CLISkip
.a840	da		phx				phx
.a841	20 59 a8	jsr $a859			jsr 	ListCurrent 				; list the line.
.a844	fa		plx				plx
.a845	c6 08		dec $08				dec 	zTemp3 						; done all lines
.a847	f0 0d		beq $a856			beq 	_CLIEnd
.a849					_CLISkip:
.a849	18		clc				clc
.a84a	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a84c	65 00		adc $00				adc 	codePtr
.a84e	85 00		sta $00				sta 	codePtr
.a850	90 dc		bcc $a82e			bcc 	_CLILoop
.a852	e6 01		inc $01				inc 	codePtr+1
.a854	80 d8		bra $a82e			bra 	_CLILoop
.a856					_CLIEnd:
.a856	4c 0d a0	jmp $a00d			jmp 	WarmStart
.a859					ListCurrent:
.a859	a0 01		ldy #$01			ldy 	#1							; print line#
.a85b	b1 00		lda ($00),y			lda 	(codePtr),y
.a85d	aa		tax				tax
.a85e	c8		iny				iny
.a85f	b1 00		lda ($00),y			lda 	(codePtr),y
.a861	a8		tay				tay
.a862	20 e6 a1	jsr $a1e6			jsr 	PrintIntegerUnsigned
.a865	a8		tay				tay
.a866					_LCPadOut:
.a866	a9 20		lda #$20			lda 	#' '
.a868	20 f4 a2	jsr $a2f4			jsr 	ExternPrint
.a86b	c8		iny				iny
.a86c	c0 06		cpy #$06			cpy 	#6
.a86e	d0 f6		bne $a866			bne 	_LCPadOut
.a870	a0 03		ldy #$03			ldy 	#3 							; start here
.a872	64 13		stz $13				stz 	PrefixCharacter				; no prefix
.a874					_LCLoop:
.a874	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.a876	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a878	f0 0b		beq $a885			beq 	_LCNoPrefix
.a87a	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.a87c	f0 07		beq $a885			beq 	_LCNoPrefix
.a87e	a5 13		lda $13				lda 	PrefixCharacter 			; output prefix, reset to space
.a880	f0 03		beq $a885			beq		_LCNoPrefix
.a882	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a885					_LCNoPrefix:
.a885	a9 20		lda #$20			lda 	#32
.a887	85 13		sta $13				sta 	PrefixCharacter
.a889	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.a88b	f0 13		beq $a8a0			beq 	_LCExit
.a88d	10 4d		bpl $a8dc			bpl 	_LCIsToken 					; +ve goto token.
.a88f	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.a891	b0 13		bcs $a8a6			bcs 	_LCIsIdentifier
.a893	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.a895	aa		tax				tax
.a896	c8		iny				iny
.a897	5a		phy				phy 								; push pos
.a898	a0 00		ldy #$00			ldy 	#0
.a89a	20 e6 a1	jsr $a1e6			jsr 	PrintIntegerUnsigned
.a89d	7a		ply				ply
.a89e	80 d4		bra $a874			bra 	_LCLoop
.a8a0					_LCExit:
.a8a0	a9 0d		lda #$0d			lda 	#13
.a8a2	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a8a5	60		rts				rts
.a8a6					_LCIsIdentifier:
.a8a6					_LCIdentLoop:
.a8a6	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.a8a8	20 92 a9	jsr $a992			jsr 	ListPrintIDChar
.a8ab	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.a8ad	c8		iny				iny
.a8ae	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.a8b0	b0 c2		bcs $a874			bcs 	_LCLoop 					; if so, do next
.a8b2	80 f2		bra $a8a6			bra 	_LCIdentLoop				; if not loop round
.a8b4					_LCConstant:
.a8b4	c8		iny				iny
.a8b5	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.a8b7	aa		tax				tax
.a8b8	c8		iny				iny 								; get MSB into Y
.a8b9	b1 00		lda ($00),y			lda 	(codePtr),y
.a8bb	c8		iny				iny
.a8bc	5a		phy				phy
.a8bd	a8		tay				tay
.a8be	5a		phy				phy 								; save sign
.a8bf	10 0c		bpl $a8cd			bpl 	_LCNotNegative
.a8c1	98		tya				tya 								; YX = |YX|
.a8c2	49 ff		eor #$ff			eor 	#$FF
.a8c4	a8		tay				tay
.a8c5	8a		txa				txa
.a8c6	49 ff		eor #$ff			eor 	#$FF
.a8c8	aa		tax				tax
.a8c9	e8		inx				inx
.a8ca	d0 01		bne $a8cd			bne 	_LCNotNegative
.a8cc	c8		iny				iny
.a8cd					_LCNotNegative:
.a8cd					_LCPrintYX:
.a8cd	20 e6 a1	jsr $a1e6			jsr 	PrintIntegerUnsigned
.a8d0	68		pla				pla 								; restore sign
.a8d1	10 05		bpl $a8d8			bpl 	_LCNoTrail
.a8d3	a9 2d		lda #$2d			lda 	#"-"
.a8d5	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a8d8					_LCNoTrail:
.a8d8	7a		ply				ply 								; restore Y
.a8d9	4c 74 a8	jmp $a874			jmp 	_LCLoop
.a8dc					_LCIsToken:
.a8dc	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.a8de	f0 d4		beq $a8b4			beq 	_LCConstant
.a8e0	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.a8e2	90 3e		bcc $a922			bcc 	_LCControl
.a8e4					_LCIsKeywordToken:
.a8e4	85 02		sta $02				sta 	zTemp0 						; save token #
.a8e6	a9 36		lda #$36			lda 	#(KeywordText) & $FF
.a8e8	85 04		sta $04				sta 	zTemp1
.a8ea	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a8ec	85 05		sta $05				sta 	zTemp1+1
.a8ee	5a		phy				phy 								; save code offset
.a8ef					_LCForward:
.a8ef	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.a8f1	f0 0f		beq $a902			beq 	_LCFoundToken
.a8f3	c6 02		dec $02				dec 	zTemp0						; dec count.
.a8f5	38		sec				sec 								; go to next keyword.
.a8f6	b2 04		lda ($04)			lda 	(zTemp1)
.a8f8	65 04		adc $04				adc 	zTemp1
.a8fa	85 04		sta $04				sta 	zTemp1
.a8fc	90 f1		bcc $a8ef			bcc 	_LCForward
.a8fe	e6 05		inc $05				inc 	zTemp1+1
.a900	80 ed		bra $a8ef			bra 	_LCForward
.a902					_LCFoundToken:
.a902	a0 01		ldy #$01			ldy 	#1 							; output the token.
.a904					_LCOutToken:
.a904	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.a906	29 7f		and #$7f			and 	#$7F
.a908	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a90b	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.a90d	c8		iny				iny
.a90e	0a		asl a				asl 	a
.a90f	90 f3		bcc $a904			bcc 	_LCOutToken
.a911	7a		ply				ply 								; restore code offset
.a912	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.a914	c8		iny				iny
.a915	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.a917	f0 04		beq $a91d			beq 	_LCCancelPrefix
.a919	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a91b	d0 02		bne $a91f			bne 	_LCGoLoop
.a91d					_LCCancelPrefix:
.a91d	64 13		stz $13				stz 	PrefixCharacter
.a91f					_LCGoLoop:
.a91f	4c 74 a8	jmp $a874			jmp 	_LCLoop
.a922					_LCControl:
.a922	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.a924	f0 2c		beq $a952			beq 	_LCDecodeCall
.a926	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a928	f0 1d		beq $a947			beq 	_LCDecodeDefine
.a92a	5a		phy				phy 								; save Y
.a92b	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.a92d	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.a92f	f0 02		beq $a933			beq 	_LCDecodeString
.a931	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.a933					_LCDecodeString
.a933	98		tya				tya
.a934	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a937	7a		ply				ply 								; restore Y pos
.a938	48		pha				pha 								; save end character on stack.
.a939	20 72 a9	jsr $a972			jsr 	ListPrintCodeIdentifier
.a93c	68		pla				pla 								; last character
.a93d	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.a93f	f0 03		beq $a944			beq 	_LCEDNoQuote
.a941	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a944					_LCEDNoQuote:
.a944	4c 74 a8	jmp $a874			jmp 	_LCLoop
.a947					_LCDecodeDefine:
.a947	a9 3a		lda #$3a			lda 	#":"
.a949	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a94c	20 72 a9	jsr $a972			jsr 	ListPrintCodeIdentifier
.a94f	4c 74 a8	jmp $a874			jmp 	_LCLoop
.a952					_LCDecodeCall:
.a952	c8		iny				iny 								; get line number into XA
.a953	b1 00		lda ($00),y			lda 	(codePtr),y
.a955	48		pha				pha
.a956	c8		iny				iny
.a957	b1 00		lda ($00),y			lda 	(codePtr),y
.a959	c8		iny				iny
.a95a	aa		tax				tax
.a95b	68		pla				pla
.a95c	20 a4 a9	jsr $a9a4			jsr 	ListFindLine 				; find that line.
.a95f	90 10		bcc $a971			bcc 	_LCNoDefinition
.a961	5a		phy				phy
.a962	a0 03		ldy #$03			ldy 	#3 							; look at first character
.a964	b1 02		lda ($02),y			lda 	(zTemp0),y
.a966	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a968	d0 07		bne $a971			bne 	_LCNoDefinition 			; not define
.a96a	20 7c a9	jsr $a97c			jsr 	ListPrintIdentifier
.a96d	7a		ply				ply
.a96e	4c 74 a8	jmp $a874			jmp 	_LCLoop
.a971					_LCNoDefinition:
>a971	ff						.byte 	$FF 						; definition is missing.
.a972					ListPrintCodeIdentifier:
.a972	48		pha				pha 								; copy codePtr -> zTemp0
.a973	a5 00		lda $00				lda 	codePtr
.a975	85 02		sta $02				sta 	zTemp0
.a977	a5 01		lda $01				lda 	codePtr+1
.a979	85 03		sta $03				sta 	zTemp0+1
.a97b	68		pla				pla
.a97c					ListPrintIdentifier:
.a97c	48		pha				pha
.a97d	da		phx				phx
.a97e	c8		iny				iny 								; skip over the type
.a97f	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.a981	aa		tax				tax
.a982					_LPILoop:
.a982	c8		iny				iny
.a983	e0 00		cpx #$00			cpx 	#0
.a985	f0 08		beq $a98f			beq 	_LPIExit
.a987	b1 02		lda ($02),y			lda 	(zTemp0),y
.a989	20 92 a9	jsr $a992			jsr 	ListPrintIDChar
.a98c	ca		dex				dex
.a98d	80 f3		bra $a982			bra 	_LPILoop
.a98f					_LPIExit:
.a98f	fa		plx				plx
.a990	68		pla				pla
.a991	60		rts				rts
.a992					ListPrintIDChar:
.a992	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.a994	10 0a		bpl $a9a0			bpl	 	_LCNotDot
.a996	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.a998	09 40		ora #$40			ora 	#$40 						; ASCII except .
.a99a	c9 5b		cmp #$5b			cmp 	#$40+27
.a99c	d0 02		bne $a9a0			bne 	_LCNotDot
.a99e	a9 2e		lda #$2e			lda 	#"."
.a9a0					_LCNotDot:
.a9a0	20 03 a2	jsr $a203			jsr 	PrintCharacter
.a9a3	60		rts				rts
.a9a4					ListFindLine:
.a9a4	5a		phy				phy
.a9a5	86 05		stx $05				stx 	zTemp1+1
.a9a7	85 04		sta $04				sta 	zTemp1
.a9a9	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a9ab	85 02		sta $02				sta 	zTemp0
.a9ad	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a9af	85 03		sta $03				sta 	zTemp0+1
.a9b1					_LFLSearch:
.a9b1	18		clc				clc									; reached the end.
.a9b2	b2 02		lda ($02)			lda 	(zTemp0)
.a9b4	f0 1d		beq $a9d3			beq 	_LFLExit 					; exit with CC
.a9b6	a0 01		ldy #$01			ldy 	#1
.a9b8	a5 04		lda $04				lda 	zTemp1
.a9ba	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a9bc	d0 07		bne $a9c5			bne 	_LFLNext
.a9be	c8		iny				iny
.a9bf	a5 05		lda $05				lda 	zTemp1+1
.a9c1	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a9c3	f0 0d		beq $a9d2			beq 	_LFLFound
.a9c5					_LFLNext:
.a9c5	18		clc				clc
.a9c6	b2 02		lda ($02)			lda 	(zTemp0)
.a9c8	65 02		adc $02				adc 	zTemp0
.a9ca	85 02		sta $02				sta 	zTemp0
.a9cc	90 e3		bcc $a9b1			bcc 	_LFLSearch
.a9ce	e6 03		inc $03				inc 	zTemp0+1
.a9d0	80 df		bra $a9b1			bra 	_LFLSearch
.a9d2					_LFLFound:
.a9d2	38		sec				sec
.a9d3					_LFLExit:
.a9d3	7a		ply				ply
.a9d4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.a9d5					Mem_Peek:
.a9d5	fa		plx				plx
.a9d6	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a9d9	85 02		sta $02				sta 	zTemp0
.a9db	bd 00 07	lda $0700,x			lda 	highStack,x
.a9de	85 03		sta $03				sta 	zTemp0+1
.a9e0	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a9e2	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a9e5	9e 00 07	stz $0700,x			stz 	highStack,x
.a9e8	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.a9eb					Mem_WPeek:
.a9eb	fa		plx				plx
.a9ec	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a9ef	85 02		sta $02				sta 	zTemp0
.a9f1	bd 00 07	lda $0700,x			lda 	highStack,x
.a9f4	85 03		sta $03				sta 	zTemp0+1
.a9f6	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a9f8	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a9fb	5a		phy				phy 								; read msb
.a9fc	a0 01		ldy #$01			ldy 	#1
.a9fe	b1 02		lda ($02),y			lda 	(zTemp0),y
.aa00	7a		ply				ply
.aa01	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.aa04	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa07					Mem_Poke:
.aa07	fa		plx				plx
.aa08	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa0b	85 02		sta $02				sta 	zTemp0
.aa0d	bd 00 07	lda $0700,x			lda 	highStack,x
.aa10	85 03		sta $03				sta 	zTemp0+1
.aa12	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aa15	92 02		sta ($02)			sta 	(zTemp0)
.aa17	ca		dex				dex
.aa18	ca		dex				dex
.aa19	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa1c					Mem_WPoke:
.aa1c	fa		plx				plx
.aa1d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa20	85 02		sta $02				sta 	zTemp0
.aa22	bd 00 07	lda $0700,x			lda 	highStack,x
.aa25	85 03		sta $03				sta 	zTemp0+1
.aa27	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aa2a	92 02		sta ($02)			sta 	(zTemp0)
.aa2c	5a		phy				phy
.aa2d	a0 01		ldy #$01			ldy 	#1
.aa2f	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aa32	91 02		sta ($02),y			sta 	(zTemp0),y
.aa34	7a		ply				ply
.aa35	ca		dex				dex
.aa36	ca		dex				dex
.aa37	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa3a					Mem_DWPoke:
.aa3a	fa		plx				plx
.aa3b	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aa3e	85 02		sta $02				sta 	zTemp0
.aa40	bd 00 07	lda $0700,x			lda 	highStack,x
.aa43	85 03		sta $03				sta 	zTemp0+1
.aa45	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aa48	92 02		sta ($02)			sta 	(zTemp0)
.aa4a	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aa4d	92 02		sta ($02)			sta 	(zTemp0)
.aa4f	ca		dex				dex
.aa50	ca		dex				dex
.aa51	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa54					Mem_Alloc:
.aa54	fa		plx				plx
.aa55	38		sec				sec 								; subtract count from alloc ptr
.aa56	a5 0d		lda $0d				lda 	allocPtr
.aa58	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.aa5b	85 0d		sta $0d				sta 	allocPtr
.aa5d	48		pha				pha 								; save low.
.aa5e	a5 0e		lda $0e				lda 	allocPtr+1
.aa60	fd 00 07	sbc $0700,x			sbc 	highStack,x
.aa63	85 0e		sta $0e				sta 	allocPtr+1
.aa65	90 10		bcc $aa77			bcc 	_MAError 					; borrow ?
.aa67	c5 10		cmp $10				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.aa69	90 0c		bcc $aa77			bcc 	_MAError
.aa6b	f0 0a		beq $aa77			beq 	_MAError
.aa6d	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.aa70	68		pla				pla
.aa71	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa74	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa77					_MAError:
.aa77	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>aa7a	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.aa82					Stack_Empty:
.aa82	fa		plx				plx
.aa83	a2 00		ldx #$00			ldx 	#0
.aa85	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa88					Stack_Drop:
.aa88	fa		plx				plx
.aa89	ca		dex				dex
.aa8a	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa8d					Stack_Dup:
.aa8d	fa		plx				plx
.aa8e	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.aa91	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.aa94	bd 00 07	lda $0700,x			lda 	highStack,x
.aa97	9d 01 07	sta $0701,x			sta 	highStack+1,x
.aa9a	e8		inx				inx 								; bump stack pointer
.aa9b	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aa9e					Stack_Nip:
.aa9e	fa		plx				plx
.aa9f	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.aaa2	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.aaa5	bd 00 07	lda $0700,x			lda 	highStack,x
.aaa8	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.aaab	ca		dex				dex 								; drop tos
.aaac	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aaaf					Stack_Over:
.aaaf	fa		plx				plx
.aab0	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.aab3	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.aab6	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.aab9	9d 01 07	sta $0701,x			sta 	highStack+1,x
.aabc	e8		inx				inx 							; bump stack pointer
.aabd	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aac0					Stack_Swap:
.aac0	fa		plx				plx
.aac1	5a		phy				phy
.aac2	bd 00 06	lda $0600,x			lda 	lowStack,x
.aac5	a8		tay				tay
.aac6	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.aac9	9d 00 06	sta $0600,x			sta 	lowStack,x
.aacc	98		tya				tya
.aacd	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.aad0	bd 00 07	lda $0700,x			lda 	highStack,x
.aad3	a8		tay				tay
.aad4	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.aad7	9d 00 07	sta $0700,x			sta 	highStack,x
.aada	98		tya				tya
.aadb	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.aade	7a		ply				ply
.aadf	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.aae2					Command_Store:
.aae2	fa		plx				plx
.aae3	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.aae5	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.aae7	90 1f		bcc $ab08			bcc 	_CSLongVariable
.aae9	c8		iny				iny 								; get the next
.aaea	b1 00		lda ($00),y			lda 	(codePtr),y
.aaec	88		dey				dey
.aaed	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.aaef	f0 17		beq $ab08			beq 	_CSLongVariable
.aaf1	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.aaf3	c8		iny				iny 								; skip over it and push on stack
.aaf4	5a		phy				phy
.aaf5	0a		asl a				asl 	a 							; double it, now C0-FE
.aaf6	a8		tay				tay 								; put in Y
.aaf7	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.aafa	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.aafd	bd 00 07	lda $0700,x			lda 	highStack,x
.ab00	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.ab03	ca		dex				dex 								; pop off stack
.ab04	7a		ply				ply 								; restore position and do next
.ab05	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ab08					_CSLongVariable:
.ab08	38		sec				sec 								; create variable if not found.
.ab09	20 6b a5	jsr $a56b			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.ab0c	20 c1 a3	jsr $a3c1			jsr 	IndexCheck 					; check indexing.
.ab0f	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.ab12	92 02		sta ($02)			sta 	(zTemp0)
.ab14	5a		phy				phy
.ab15	a0 01		ldy #$01			ldy 	#1
.ab17	bd 00 07	lda $0700,x			lda 	highStack,x
.ab1a	91 02		sta ($02),y			sta 	(zTemp0),y
.ab1c	7a		ply				ply
.ab1d	ca		dex				dex 								; pop off stack
.ab1e	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.ab21					Command_New:
.ab21	fa		plx				plx
.ab22	9c 00 10	stz $1000			stz 	ProgramStart
.ab25	4c 0d a0	jmp $a00d			jmp 	WarmStart
.ab28					Command_Old:
.ab28	fa		plx				plx
.ab29	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ab2b	85 00		sta $00				sta 	codePtr
.ab2d	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ab2f	85 01		sta $01				sta 	codePtr+1
.ab31	a0 03		ldy #$03			ldy 	#3
.ab33					_COAdvance:
.ab33	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.ab35	b0 0e		bcs $ab45			bcs		_COFail
.ab37	20 59 af	jsr $af59			jsr 	AdvanceInCode
.ab3a	b1 00		lda ($00),y			lda 	(codePtr),y
.ab3c	d0 f5		bne $ab33			bne 	_COAdvance
.ab3e	c8		iny				iny 								; byte after end of line
.ab3f	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.ab42					_CONotDeleted:
.ab42	4c 0d a0	jmp $a00d			jmp 	WarmStart
.ab45					_COFail:
.ab45	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>ab48	43 41 4e 54 3f 00				.text 	"CANT?",0
.ab4e					Command_End:
.ab4e	fa		plx				plx
.ab4f	4c 0d a0	jmp $a00d			jmp 	WarmStart
.ab52					Command_Stop:
>ab52	ff						.byte 	$FF
.ab53	fa		plx				plx
.ab54	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>ab57	53 54 4f 50 00					.text 	"STOP",0
.ab5c					Command_Assert:
.ab5c	fa		plx				plx
.ab5d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.ab60	1d 00 07	ora $0700,x			ora 	highStack,x
.ab63	f0 04		beq $ab69			beq 	_CAFail
.ab65	ca		dex				dex 								; throw if not.
.ab66	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ab69					_CAFail:
.ab69	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>ab6c	41 53 53 45 52 54 00				.text 	"ASSERT",0
.ab73					Command_Sys:
.ab73	fa		plx				plx
.ab74	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.ab77	85 02		sta $02				sta 	zTemp0
.ab79	bd 00 07	lda $0700,x			lda 	highStack,x
.ab7c	85 03		sta $03				sta 	zTemp0+1
.ab7e	ca		dex				dex 								; pop tos
.ab7f	da		phx				phx 								; save XY
.ab80	5a		phy				phy
.ab81	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.ab84	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.ab87	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.ab8a	20 92 ab	jsr $ab92			jsr 	_CSCallInd
.ab8d	7a		ply				ply 								; restore XY
.ab8e	fa		plx				plx
.ab8f	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ab92					_CSCallInd:
.ab92	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.ab95					Command_DumpStack:
.ab95	fa		plx				plx
.ab96	da		phx				phx 								; save pos and sp
.ab97	5a		phy				phy
.ab98	86 0c		stx $0c				stx 	SignCount
.ab9a	a2 ff		ldx #$ff			ldx 	#$FF
.ab9c					_CDSLoop:
.ab9c	e4 0c		cpx $0c				cpx 	SignCount 					; done all ?
.ab9e	f0 2a		beq $abca			beq 	_CDSExit
.aba0	e8		inx				inx
.aba1	da		phx				phx 								; save SP
.aba2	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.aba5	a8		tay				tay
.aba6	bd 00 06	lda $0600,x			lda 	lowStack,x
.aba9	aa		tax				tax
.abaa	c0 00		cpy #$00			cpy 	#0
.abac	10 11		bpl $abbf			bpl 	_CDSPositive
.abae	a9 2d		lda #$2d			lda 	#"-" 						; minus
.abb0	20 03 a2	jsr $a203			jsr 	PrintCharacter
.abb3	98		tya				tya 								; negate YX
.abb4	49 ff		eor #$ff			eor 	#$FF
.abb6	a8		tay				tay
.abb7	8a		txa				txa
.abb8	49 ff		eor #$ff			eor 	#$FF
.abba	aa		tax				tax
.abbb	e8		inx				inx
.abbc	d0 01		bne $abbf			bne 	_CDSPositive
.abbe	c8		iny				iny
.abbf					_CDSPositive:
.abbf	20 e6 a1	jsr $a1e6			jsr 	PrintIntegerUnsigned
.abc2	a9 20		lda #$20			lda 	#" " 						; space
.abc4	20 03 a2	jsr $a203			jsr 	PrintCharacter
.abc7	fa		plx				plx
.abc8	80 d2		bra $ab9c			bra 	_CDSLoop
.abca					_CDSExit:
.abca	a9 3c		lda #$3c			lda 	#"<"
.abcc	20 03 a2	jsr $a203			jsr 	PrintCharacter
.abcf	20 03 a2	jsr $a203			jsr 	PrintCharacter
.abd2	a9 0d		lda #$0d			lda 	#13 						; CR
.abd4	20 03 a2	jsr $a203			jsr 	PrintCharacter
.abd7	7a		ply				ply
.abd8	fa		plx				plx
.abd9	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.abdc					Stack_Add:
.abdc	fa		plx				plx
.abdd	ca		dex				dex
.abde	18		clc				clc
.abdf	bd 00 06	lda $0600,x			lda		lowStack,x
.abe2	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.abe5	9d 00 06	sta $0600,x			sta 	lowStack,x
.abe8	bd 00 07	lda $0700,x			lda		highStack,x
.abeb	7d 01 07	adc $0701,x			adc 	highStack+1,x
.abee	9d 00 07	sta $0700,x			sta 	highStack,x
.abf1	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.abf4					Stack_Sub:
.abf4	fa		plx				plx
.abf5	ca		dex				dex
.abf6	38		sec				sec
.abf7	bd 00 06	lda $0600,x			lda		lowStack,x
.abfa	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.abfd	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac00	bd 00 07	lda $0700,x			lda		highStack,x
.ac03	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ac06	9d 00 07	sta $0700,x			sta 	highStack,x
.ac09	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ac0c					Stack_And:
.ac0c	fa		plx				plx
.ac0d	ca		dex				dex
.ac0e	bd 00 06	lda $0600,x			lda		lowStack,x
.ac11	3d 01 06	and $0601,x			and		lowStack+1,x
.ac14	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac17	bd 00 07	lda $0700,x			lda		highStack,x
.ac1a	3d 01 07	and $0701,x			and 	highStack+1,x
.ac1d	9d 00 07	sta $0700,x			sta 	highStack,x
.ac20	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ac23					Stack_Xor:
.ac23	fa		plx				plx
.ac24	ca		dex				dex
.ac25	bd 00 06	lda $0600,x			lda		lowStack,x
.ac28	5d 01 06	eor $0601,x			eor		lowStack+1,x
.ac2b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac2e	bd 00 07	lda $0700,x			lda		highStack,x
.ac31	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ac34	9d 00 07	sta $0700,x			sta 	highStack,x
.ac37	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ac3a					Stack_Or:
.ac3a	fa		plx				plx
.ac3b	ca		dex				dex
.ac3c	bd 00 06	lda $0600,x			lda		lowStack,x
.ac3f	1d 01 06	ora $0601,x			ora		lowStack+1,x
.ac42	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac45	bd 00 07	lda $0700,x			lda		highStack,x
.ac48	1d 01 07	ora $0701,x			ora 	highStack+1,x
.ac4b	9d 00 07	sta $0700,x			sta 	highStack,x
.ac4e	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ac51					Stack_Shl:
.ac51	fa		plx				plx
.ac52	38		sec				sec
.ac53	80 02		bra $ac57			bra 	StackShift
.ac55					Stack_Shr:
.ac55	fa		plx				plx
.ac56	18		clc				clc
.ac57					StackShift:
.ac57	08		php				php
.ac58	ca		dex				dex
.ac59	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.ac5c	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.ac5e	1d 01 07	ora $0701,x			ora 	highStack+1,x
.ac61	d0 19		bne $ac7c			bne 	_SSZero
.ac63					_SSLoop:
.ac63	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.ac66	30 1a		bmi $ac82			bmi 	_SSDone 					; completed ?
.ac68	28		plp				plp 								; restore flag
.ac69	08		php				php
.ac6a	b0 08		bcs $ac74			bcs 	_SSLeft 					; do either shift.
.ac6c	5e 00 07	lsr $0700,x			lsr 	highStack,x
.ac6f	7e 00 06	ror $0600,x			ror 	lowStack,x
.ac72	80 ef		bra $ac63			bra 	_SSLoop
.ac74					_SSLeft:
.ac74	1e 00 06	asl $0600,x			asl 	lowStack,x
.ac77	3e 00 07	rol $0700,x			rol 	highStack,x
.ac7a	80 e7		bra $ac63			bra 	_SSLoop
.ac7c					_SSZero:
.ac7c	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.ac7f	9e 00 07	stz $0700,x			stz 	highStack,x
.ac82					_SSDone:
.ac82	28		plp				plp 								; throw flag.
.ac83	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.ac86					Comp_Equal:
.ac86	fa		plx				plx
.ac87	38		sec				sec
.ac88	80 02		bra $ac8c			bra 	Comp_CheckEqual
.ac8a					Comp_NotEqual:
.ac8a	fa		plx				plx
.ac8b	18		clc				clc
.ac8c					Comp_CheckEqual:
.ac8c	08		php				php
.ac8d	ca		dex				dex
.ac8e	bd 00 06	lda $0600,x			lda		lowStack,x
.ac91	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.ac94	d0 06		bne $ac9c			bne 	_CCENonZero
.ac96	bd 00 07	lda $0700,x			lda		highStack,x
.ac99	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ac9c					_CCENonZero:
.ac9c	f0 02		beq $aca0			beq 	_CCENotSet
.ac9e	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.aca0					_CCENotSet:
.aca0					CompCheckFlip:
.aca0	28		plp				plp 								; if carry set, we want $FF if equal
.aca1	90 02		bcc $aca5			bcc 	CompReturn
.aca3	49 ff		eor #$ff			eor 	#$FF
.aca5					CompReturn:
.aca5	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.aca8	9d 00 07	sta $0700,x			sta 	highStack,x
.acab	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.acae					Comp_Less:
.acae	fa		plx				plx
.acaf	18		clc				clc
.acb0	80 02		bra $acb4			bra 	Comp_LessCont
.acb2					Comp_GreaterEqual:
.acb2	fa		plx				plx
.acb3	38		sec				sec
.acb4					Comp_LessCont:
.acb4	08		php				php
.acb5	ca		dex				dex
.acb6	38		sec				sec
.acb7	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.acba	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.acbd	bd 00 07	lda $0700,x			lda 	highStack,x
.acc0	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.acc3	50 02		bvc $acc7			bvc 	_CLNoFlip 					; unsigned -> signed
.acc5	49 80		eor #$80			eor 	#$80
.acc7					_CLNoFlip:
.acc7	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.acc9	f0 d5		beq $aca0			beq 	CompCheckFlip
.accb	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.accd	80 d1		bra $aca0			bra 	CompCheckFlip
.accf					Comp_LessEqual:
.accf	fa		plx				plx
.acd0	38		sec				sec
.acd1	80 02		bra $acd5			bra 	Comp_LessEqualCont
.acd3					Comp_Greater:
.acd3	fa		plx				plx
.acd4	18		clc				clc
.acd5					Comp_LessEqualCont:
.acd5	08		php				php
.acd6	ca		dex				dex
.acd7	38		sec				sec
.acd8	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.acdb	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.acde	bd 01 07	lda $0701,x			lda 	highStack+1,x
.ace1	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ace4	50 02		bvc $ace8			bvc 	_CLENoFlip 					; unsigned -> signed
.ace6	49 80		eor #$80			eor 	#$80
.ace8					_CLENoFlip:
.ace8	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.acea	f0 b4		beq $aca0			beq 	CompCheckFlip
.acec	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.acee	80 b0		bra $aca0			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.acf0					DivInteger16:
.acf0	fa		plx				plx
.acf1	20 f7 ac	jsr $acf7			jsr 	IntegerDivide
.acf4	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.acf7					IntegerDivide:
.acf7	ca		dex				dex
.acf8	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.acfb	1d 01 07	ora $0701,x			ora 	highStack+1,x
.acfe	d0 14		bne $ad14			bne 	_BFDOkay
.ad00	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>ad03	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ad0b	20 42 59 20 5a 45 52 4f 00
.ad14					_BFDOkay:
.ad14	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.ad16	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.ad18	64 0c		stz $0c				stz 	SignCount 					; Count of signs.
.ad1a	20 56 ad	jsr $ad56			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ad1d	e8		inx				inx
.ad1e	20 56 ad	jsr $ad56			jsr 	CheckIntegerNegate
.ad21	ca		dex				dex
.ad22	5a		phy				phy 								; Y is the counter
.ad23	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.ad25					_BFDLoop:
.ad25	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.ad28	3e 00 07	rol $0700,x			rol 	highStack,x
.ad2b	26 04		rol $04				rol 	zTemp1
.ad2d	26 05		rol $05				rol 	zTemp1+1
.ad2f	38		sec				sec
.ad30	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.ad32	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ad35	48		pha				pha
.ad36	a5 05		lda $05				lda 	zTemp1+1
.ad38	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ad3b	90 0f		bcc $ad4c			bcc 	_BFDNoAdd
.ad3d	85 05		sta $05				sta 	zTemp1+1
.ad3f	68		pla				pla
.ad40	85 04		sta $04				sta 	zTemp1+0
.ad42	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.ad45	09 01		ora #$01			ora 	#1
.ad47	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad4a	80 01		bra $ad4d			bra 	_BFDNext
.ad4c					_BFDNoAdd:
.ad4c	68		pla				pla 								; Throw away the intermediate calculations
.ad4d					_BFDNext:
.ad4d	88		dey				dey
.ad4e	d0 d5		bne $ad25			bne 	_BFDLoop
.ad50	7a		ply				ply 								; restore Y
.ad51	46 0c		lsr $0c				lsr 	SignCount 					; if sign count odd,
.ad53	b0 07		bcs $ad5c			bcs		IntegerNegateAlways 		; negate the result
.ad55	60		rts				rts
.ad56					CheckIntegerNegate:
.ad56	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.ad59	30 01		bmi $ad5c			bmi 	IntegerNegateAlways 		; if so negate it
.ad5b	60		rts				rts
.ad5c					IntegerNegateAlways:
.ad5c	e6 0c		inc $0c				inc 	SignCount 					; bump the count of signs
.ad5e	4c b9 ad	jmp $adb9			jmp 	Unary_Negate
.ad61					ModInteger16:
.ad61	fa		plx				plx
.ad62	20 f7 ac	jsr $acf7			jsr 	IntegerDivide
.ad65	a5 04		lda $04				lda 	zTemp1
.ad67	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad6a	a5 05		lda $05				lda 	zTemp1+1
.ad6c	9d 00 07	sta $0700,x			sta 	highStack,x
.ad6f	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.ad72					MulInteger16:
.ad72	fa		plx				plx
.ad73	ca		dex				dex
.ad74	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.ad77	85 04		sta $04				sta 	zTemp1
.ad79	bd 00 07	lda $0700,x			lda 	highStack,x
.ad7c	85 05		sta $05				sta 	zTemp1+1
.ad7e	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.ad81	9e 00 07	stz $0700,x			stz 	highStack,x
.ad84					_BFMMultiply:
.ad84	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.ad86	29 01		and #$01			and 	#1
.ad88	f0 13		beq $ad9d			beq 	_BFMNoAdd
.ad8a	18		clc				clc 								; add old tos to current tos.
.ad8b	bd 00 06	lda $0600,x			lda		lowStack,x
.ad8e	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ad91	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad94	bd 00 07	lda $0700,x			lda		highStack,x
.ad97	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ad9a	9d 00 07	sta $0700,x			sta 	highStack,x
.ad9d					_BFMNoAdd:
.ad9d	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.ada0	3e 01 07	rol $0701,x			rol 	highStack+1,x
.ada3	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.ada5	66 04		ror $04				ror 	zTemp1+0
.ada7	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.ada9	05 05		ora $05				ora 	zTemp1+1
.adab	d0 d7		bne $ad84			bne 	_BFMMultiply
.adad	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.adb0					Unary_Absolute:
.adb0	fa		plx				plx
.adb1	bd 00 07	lda $0700,x			lda 	highStack,x
.adb4	30 04		bmi $adba			bmi 	Unary_Negate_Code
.adb6	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.adb9					Unary_Negate:
.adb9	fa		plx				plx
.adba					Unary_Negate_Code:
.adba	38		sec				sec
.adbb	a9 00		lda #$00			lda		#0
.adbd	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.adc0	9d 00 06	sta $0600,x			sta 	lowStack,x
.adc3	a9 00		lda #$00			lda		#0
.adc5	fd 00 07	sbc $0700,x			sbc 	highStack,x
.adc8	9d 00 07	sta $0700,x			sta 	highStack,x
.adcb	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.adce					Unary_Not:
.adce	fa		plx				plx
.adcf	bd 00 06	lda $0600,x			lda 	lowStack,x
.add2	49 ff		eor #$ff			eor 	#$FF
.add4	9d 00 06	sta $0600,x			sta 	lowStack,x
.add7	bd 00 07	lda $0700,x			lda 	highStack,x
.adda	49 ff		eor #$ff			eor 	#$FF
.addc	9d 00 07	sta $0700,x			sta 	highStack,x
.addf	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ade2					Unary_Increment:
.ade2	fa		plx				plx
.ade3	fe 00 06	inc $0600,x			inc 	lowStack,x
.ade6	d0 03		bne $adeb			bne 	_UIExit
.ade8	fe 00 07	inc $0700,x			inc 	highStack,x
.adeb					_UIExit:
.adeb	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.adee					Unary_Decrement:
.adee	fa		plx				plx
.adef	bd 00 06	lda $0600,x			lda 	lowStack,x
.adf2	d0 03		bne $adf7			bne 	_UDNoBorrow
.adf4	de 00 07	dec $0700,x			dec 	highStack,x
.adf7					_UDNoBorrow:
.adf7	de 00 06	dec $0600,x			dec 	lowStack,x
.adfa	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.adfd					Unary_BSwap:
.adfd	fa		plx				plx
.adfe	bd 00 06	lda $0600,x			lda 	lowStack,x
.ae01	48		pha				pha
.ae02	bd 00 07	lda $0700,x			lda 	highStack,x
.ae05	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae08	68		pla				pla
.ae09	9d 00 07	sta $0700,x			sta 	highStack,x
.ae0c	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ae0f					Unary_Shl:
.ae0f	fa		plx				plx
.ae10	1e 00 06	asl $0600,x			asl 	lowStack,x
.ae13	3e 00 07	rol $0700,x			rol 	highStack,x
.ae16	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ae19					Unary_Shr:
.ae19	fa		plx				plx
.ae1a	5e 00 07	lsr $0700,x			lsr 	highStack,x
.ae1d	7e 00 06	ror $0600,x			ror 	lowStack,x
.ae20	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ae23					Unary_Sgn:
.ae23	fa		plx				plx
.ae24	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.ae27	10 0a		bpl $ae33			bpl 	_USNotNeg
.ae29	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.ae2b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae2e	9d 00 07	sta $0700,x			sta 	highStack,x
.ae31	80 10		bra $ae43			bra 	_USExit
.ae33					_USNotNeg:
.ae33	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.ae36	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.ae39	9e 00 07	stz $0700,x			stz 	highStack,x
.ae3c	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.ae3e	f0 03		beq $ae43			beq 	_USExit
.ae40	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.ae43					_USExit:
.ae43	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.ae46					Random_Handler:
.ae46	fa		plx				plx
.ae47	a5 11		lda $11				lda 	randomSeed
.ae49	05 12		ora $12				ora 	randomSeed+1
.ae4b	d0 08		bne $ae55			bne 	_RH_NoInit
.ae4d	a9 7c		lda #$7c			lda 	#$7C
.ae4f	85 11		sta $11				sta 	randomSeed
.ae51	a9 a1		lda #$a1			lda 	#$A1
.ae53	85 12		sta $12				sta 	randomSeed+1
.ae55					_RH_NoInit:
.ae55	a5 11		lda $11				lda 	randomSeed
.ae57	4a		lsr a		        lsr		a
.ae58	26 12		rol $12		        rol 	randomSeed+1
.ae5a	90 02		bcc $ae5e	        bcc 	_RH_NoEor
.ae5c	49 b4		eor #$b4	        eor 	#$B4
.ae5e					_RH_NoEor:
.ae5e	85 11		sta $11		        sta 	randomSeed
.ae60	45 12		eor $12		        eor 	randomSeed+1
.ae62	e8		inx		        inx
.ae63	9d 00 07	sta $0700,x	        sta 	highStack,x
.ae66	a5 11		lda $11		        lda 	randomSeed
.ae68	9d 00 06	sta $0600,x	        sta 	lowStack,x
.ae6b	4c 25 a2	jmp $a225			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.ae6e					Command_Call:
.ae6e	fa		plx				plx
.ae6f	20 70 a4	jsr $a470			jsr 	StackPushPosition 				; save stack position
.ae72	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.ae74	20 60 a4	jsr $a460			jsr 	StackPushByte
.ae77	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.ae79	85 02		sta $02				sta 	zTemp0
.ae7b	c8		iny				iny
.ae7c	b1 00		lda ($00),y			lda 	(codePtr),y
.ae7e	85 03		sta $03				sta 	zTemp0+1
.ae80	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ae82	85 00		sta $00				sta 	codePtr
.ae84	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ae86	85 01		sta $01				sta 	codePtr+1
.ae88	a0 01		ldy #$01			ldy 	#1
.ae8a					_CCSearch:
.ae8a	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.ae8c	f0 2d		beq $aebb			beq		_CCFail
.ae8e	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.ae90	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.ae92	f0 0d		beq $aea1			beq 	_CCCheckMSB
.ae94	18		clc				clc 									; forward to next line.
.ae95	b2 00		lda ($00)			lda 	(codePtr)
.ae97	65 00		adc $00				adc 	codePtr
.ae99	85 00		sta $00				sta 	codePtr
.ae9b	90 ed		bcc $ae8a			bcc 	_CCSearch
.ae9d	e6 01		inc $01				inc 	codePtr+1
.ae9f	80 e9		bra $ae8a			bra 	_CCSearch
.aea1					_CCCheckMSB:
.aea1	c8		iny				iny 									; get MSB, keeping Y as 1
.aea2	b1 00		lda ($00),y			lda 	(codePtr),y
.aea4	88		dey				dey
.aea5	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.aea7	d0 e1		bne $ae8a			bne 	_CCSearch
.aea9	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.aeab	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.aead	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.aeaf	d0 0a		bne $aebb			bne 	_CCFail
.aeb1	c8		iny				iny 									; get the length of this.
.aeb2	b1 00		lda ($00),y			lda 	(codePtr),y
.aeb4	18		clc				clc
.aeb5	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.aeb7	a8		tay				tay
.aeb8	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aebb					_CCFail:
.aebb	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>aebe	43 41 4c 4c 3f 00				.text 	"CALL?",0
.aec4					Command_Return:
.aec4	fa		plx				plx
.aec5	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.aec7	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.aeca	90 0f		bcc $aedb			bcc 	_CRFail
.aecc	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.aece	20 8d a4	jsr $a48d			jsr 	StackRestorePosition
.aed1	c8		iny				iny
.aed2	c8		iny				iny
.aed3	a9 04		lda #$04			lda 	#4 								; pop off stack
.aed5	20 87 a4	jsr $a487			jsr 	StackPop
.aed8	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aedb					_CRFail:
.aedb	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>aede	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.aee4					Structure_If:
.aee4	fa		plx				plx
.aee5	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.aee7	20 60 a4	jsr $a460			jsr 	StackPushByte
.aeea	18		clc				clc
.aeeb	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.aeee	1d 00 07	ora $0700,x			ora 	highStack,x
.aef1	ca		dex				dex 									; drop TOS
.aef2	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.aef4	d0 0e		bne $af04			bne 	_SIFNoSkip 						; at this level.
.aef6	da		phx				phx
.aef7	a9 37		lda #$37			lda 	#KWD_ELSE
.aef9	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.aefb	20 31 af	jsr $af31			jsr 	StructSkipForward
.aefe	fa		plx				plx 									; restore X
.aeff	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.af01	d0 01		bne $af04			bne 	_SIFNoSkip 						; clause.
.af03	c8		iny				iny
.af04					_SIFNoSkip:
.af04	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.af07					Structure_Else:
.af07	fa		plx				plx
.af08	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.af0a	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.af0d	90 0b		bcc $af1a			bcc 	SIFail
.af0f	da		phx				phx 									; got here by executing IF clause so skip
.af10	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.af12	aa		tax				tax
.af13	20 31 af	jsr $af31			jsr 	StructSkipForward
.af16	fa		plx				plx
.af17	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.af1a					SIFail:
.af1a	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>af1d	49 46 3f 00					.text 	"IF?",0
.af21					Structure_Endif:
.af21	fa		plx				plx
.af22	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.af24	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.af27	90 f1		bcc $af1a			bcc 	SIFail
.af29	a9 01		lda #$01			lda 	#1 								; throw it.
.af2b	20 87 a4	jsr $a487			jsr 	StackPop
.af2e	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.af31					StructSkipForward:
.af31	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.af33	86 03		stx $03				stx 	zTemp0+1
.af35	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.af37					_SSFLoop:
.af37	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.af39	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.af3b	d0 08		bne $af45			bne		_SSFFail
.af3d	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.af3f	f0 17		beq $af58			beq 	_SSFEnd
.af41	c5 03		cmp $03				cmp 	zTemp0+1
.af43	f0 13		beq $af58			beq 	_SSFEnd
.af45					_SSFFail:
.af45	20 59 af	jsr $af59			jsr 	AdvanceInCode 					; skip over in code.
.af48	b0 ed		bcs $af37			bcs 	_SSFLoop 						; if not end of program, keep going.
.af4a	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>af4d	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>af55	45 3f 00
.af58					_SSFEnd:
.af58	60		rts				rts
.af59					AdvanceInCode:
.af59	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.af5b	f0 28		beq $af85			beq 	_AICEndOfLine 					; end of line.
.af5d	c8		iny				iny 									; advance one.
.af5e	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.af60	90 10		bcc $af72			bcc 	_AICControl
.af62	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.af64	b0 0a		bcs $af70			bcs 	_AICExit
.af66	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.af68	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.af6a	90 04		bcc $af70			bcc 	_AICExit
.af6c	c6 04		dec $04				dec 	zTemp1
.af6e	c6 04		dec $04				dec 	zTemp1
.af70					_AICExit:
.af70	38		sec				sec
.af71	60		rts				rts
.af72					_AICControl:
.af72	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.af74	f0 0b		beq $af81			beq 	_AICThree
.af76	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.af78	f0 07		beq $af81			beq 	_AICThree
.af7a	98		tya				tya										; skip over a string/comment/define.
.af7b	38		sec				sec
.af7c	71 00		adc ($00),y			adc 	(codePtr),y
.af7e	a8		tay				tay
.af7f	38		sec				sec
.af80	60		rts				rts
.af81					_AICThree:
.af81	c8		iny				iny
.af82	c8		iny				iny
.af83	38		sec				sec
.af84	60		rts				rts
.af85					_AICEndOfLine:
.af85	18		clc				clc 									; forward to next line.
.af86	b2 00		lda ($00)			lda 	(codePtr)
.af88	65 00		adc $00				adc 	codePtr
.af8a	85 00		sta $00				sta 	codePtr
.af8c	90 02		bcc $af90			bcc 	_AICNoCarry
.af8e	e6 01		inc $01				inc 	codePtr+1
.af90					_AICNoCarry:
.af90	a0 03		ldy #$03			ldy 	#3 								; start of new line
.af92	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.af94	d0 da		bne $af70			bne 	_AICExit
.af96	18		clc				clc 									; program end.
.af97	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.af98					Struct_Repeat:
.af98	fa		plx				plx
.af99	20 70 a4	jsr $a470			jsr 	StackPushPosition 				; save stack position
.af9c	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.af9e	20 60 a4	jsr $a460			jsr 	StackPushByte
.afa1	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.afa4					Struct_Until:
.afa4	fa		plx				plx
.afa5	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.afa7	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.afaa	90 1b		bcc $afc7			bcc 	_SUFail
.afac	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.afaf	1d 00 07	ora $0700,x			ora 	highStack,x
.afb2	ca		dex				dex
.afb3	09 00		ora #$00			ora 	#0
.afb5	f0 08		beq $afbf			beq 	_SULoopBack 					; if so keep going.
.afb7	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.afb9	20 87 a4	jsr $a487			jsr 	StackPop
.afbc	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.afbf					_SULoopBack:
.afbf	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.afc1	20 8d a4	jsr $a48d			jsr 	StackRestorePosition
.afc4	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.afc7					_SUFail:
.afc7	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>afca	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>afd2	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.afd4					Struct_For:
.afd4	fa		plx				plx
.afd5	18		clc				clc
.afd6	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.afd9	49 ff		eor #$ff			eor 	#$FF
.afdb	69 01		adc #$01			adc 	#1
.afdd	08		php				php
.afde	20 60 a4	jsr $a460			jsr 	StackPushByte
.afe1	bd 00 07	lda $0700,x			lda 	highStack,x
.afe4	49 ff		eor #$ff			eor 	#$FF
.afe6	28		plp				plp
.afe7	69 00		adc #$00			adc 	#0
.afe9	20 60 a4	jsr $a460			jsr 	StackPushByte
.afec	ca		dex				dex 									; throw TOS
.afed	20 70 a4	jsr $a470			jsr 	StackPushPosition 				; save stack position
.aff0	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.aff2	20 60 a4	jsr $a460			jsr 	StackPushByte
.aff5	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.aff8					Struct_Index:
.aff8	fa		plx				plx
.aff9	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.affb	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.affe	90 43		bcc $b043			bcc 	SNFail
.b000	e8		inx				inx 									; new stack entry
.b001	5a		phy				phy
.b002	a0 04		ldy #$04			ldy 	#4 								; access index value
.b004	b1 0a		lda ($0a),y			lda 	(iStack),y
.b006	49 ff		eor #$ff			eor 	#$FF
.b008	9d 00 07	sta $0700,x			sta 	highStack,x
.b00b	c8		iny				iny
.b00c	b1 0a		lda ($0a),y			lda 	(iStack),y
.b00e	49 ff		eor #$ff			eor 	#$FF
.b010	9d 00 06	sta $0600,x			sta 	lowStack,x
.b013	7a		ply				ply 									; restore code pointer
.b014	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.b017					Struct_Next:
.b017	fa		plx				plx
.b018	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b01a	20 7f a4	jsr $a47f			jsr 	StackCheckTop
.b01d	90 24		bcc $b043			bcc 	SNFail
.b01f	5a		phy				phy 									; save code position
.b020	a0 05		ldy #$05			ldy 	#5 								; bump the count
.b022	b1 0a		lda ($0a),y			lda 	(iStack),y
.b024	1a		inc a				inc 	a
.b025	91 0a		sta ($0a),y			sta 	(iStack),y
.b027	d0 11		bne $b03a			bne 	_SNLoopBack
.b029	88		dey				dey
.b02a	b1 0a		lda ($0a),y			lda 	(iStack),y
.b02c	1a		inc a				inc 	a
.b02d	91 0a		sta ($0a),y			sta 	(iStack),y
.b02f	d0 09		bne $b03a			bne 	_SNLoopBack  					; non-zero loop back.
.b031	7a		ply				ply 									; restore code position.
.b032	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.b034	20 87 a4	jsr $a487			jsr 	StackPop
.b037	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.b03a					_SNLoopBack:
.b03a	7a		ply				ply 									; restore code position, being junked anyway.
.b03b	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b03d	20 8d a4	jsr $a48d			jsr 	StackRestorePosition
.b040	4c 25 a2	jmp $a225			jmp 	ExecuteLoop
.b043					SNFail:
.b043	20 bc a1	jsr $a1bc			jsr 	ErrorHandler
>b046	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
