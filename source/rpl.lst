
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Thu Nov 14 19:43:56 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					iStack:			.word ?						; stack pointer
>000c					signCount:		.byte ? 					; divide sign count.
>000d					allocPtr:		.word ? 					; memory allocation pointer (down)
>000f					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0011					randomSeed:		.word ? 					; random number seed
>0013					prefixCharacter:.byte ?						; char to print before listed element.
>0014					breakCount:		.byte ? 					; counter avoids repeated break checks
>0015					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	1a e8 03 3d 01 00 60 22			.byte	$1a,$e8,$03,$3d,$01,$00,$60,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$04,$05,$48,$45,$4c,$4c,$4f,$03,$01,$27,$00,$0b,$f2,$03,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$fc,$03,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$06,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$42,$04,$0b,$00,$08,$10,$04,$01,$50,$00,$08,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$88,$04,$0b,$00,$05,$24,$04,$0b,$00,$05,$2e,$04,$40,$00,$1e,$38,$04,$05,$06,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$42,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$4c,$04,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$60,$04,$39,$00,$15,$56,$04,$05,$04,$d2,$d3,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$60,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$6a,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$74,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$7e,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$88,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$92,$04,$a0,$02,$60,$04,$00,$1c,$9c,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$a6,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ba,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$c4,$04,$01,$51,$00,$02,$60,$04,$00,$05,$ce,$04,$39,$00
>1008	c2 c1 cc cc cd c5 ed 04 05 48 45 4c 4c 4f 03 01
>1018	27 00 0b f2 03 a0 22 c3 cf d5 ce f4 00 0d fc 03
>1028	01 8e 00 22 e1 01 d2 ff 25 00 12 06 04 c3 cf d5
>1038	ce f4 08 38 02 38 04 02 42 04 0b 00 08 10 04 01
>1048	50 00 08 00 12 1a 04 c3 cf d5 ce f4 08 38 02 38
>1058	04 02 88 04 0b 00 05 24 04 0b 00 05 2e 04 40 00
>1068	1e 38 04 05 06 d3 c5 cc c5 c3 f4 2d 2d 2d 2d c2
>1078	c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 39 00 29 42
>1088	04 05 09 c2 c1 cc cc db c9 ce c9 f4 30 27 01 50
>1098	00 0e 22 c2 c1 cc ec 23 80 24 30 27 bc 0e 22 c2
>10a8	c1 cc ec 23 81 24 00 2d 4c 04 02 56 04 22 c2 c1
>10b8	cc ec 23 82 24 02 56 04 22 c2 c1 cc ec 23 83 24
>10c8	30 87 11 2a 22 c2 c1 cc ec 23 84 24 01 51 00 02
>10d8	60 04 39 00 15 56 04 05 04 d2 d3 c7 ee 30 81 11
>10e8	06 81 37 01 ff ff 09 39 00 0f 60 04 05 09 c2 c1
>10f8	cc cc db c4 d2 c1 f7 00 10 6a 04 c2 c1 cc ec 23
>1108	80 24 2d 01 20 9f 1d 00 0f 74 04 c2 c1 cc ec 23
>1118	81 24 01 21 9f 1d 00 19 7e 04 90 01 22 9f 1d 01
>1128	23 9f 1d c2 c1 cc ec 23 84 24 01 23 9f 1d 39 00
>1138	0f 88 04 05 09 c2 c1 cc cc db cd cf d6 e5 00 08
>1148	92 04 a0 02 60 04 00 1c 9c 04 c2 c1 cc ec 23 80
>1158	24 c2 c1 cc ec 23 82 24 0f 33 22 c2 c1 cc ec 23
>1168	80 24 00 1f a6 04 33 01 50 00 1a 36 80 19 12 06
>1178	c2 c1 cc ec 23 82 24 28 22 c2 c1 cc ec 23 82 24
>1188	09 00 1c b0 04 c2 c1 cc ec 23 81 24 c2 c1 cc ec
>1198	23 83 24 0f 33 22 c2 c1 cc ec 23 81 24 00 1d ba
>11a8	04 33 bc 1a 36 80 19 12 06 c2 c1 cc ec 23 83 24
>11b8	28 22 c2 c1 cc ec 23 83 24 09 00 0a c4 04 01 51
>11c8	00 02 60 04 00 05 ce 04 39 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs

;******  Processing file: tokenise/test.asm

.a003	4c 14 a0	jmp $a014				jmp 	TokTest1
.a006					TokenCode:
>a006	20 20 34 32 20 24 35 41				.text 	"  42 $5A7 4- "
>a00e	37 20 34 2d 20
>a013	00						.byte 	0
.a014					TokTest1:
.a014	a2 ff		ldx #$ff			ldx 	#255 						; copy to input buffer.
.a016					_TT1Copy:
.a016	e8		inx				inx
.a017	bd 06 a0	lda $a006,x			lda 	TokenCode,x
.a01a	9d 00 08	sta $0800,x			sta	 	InputBuffer,x
.a01d	d0 f7		bne $a016			bne 	_TT1Copy
.a01f	20 53 a6	jsr $a653			jsr 	TokeniseInputBuffer
.a022					_TT1Halt:
.a022	80 fe		bra $a022			bra 	_TT1Halt

;******  Return to file: main.asm

.a024	20 c3 a2	jsr $a2c3			jsr 	ExternInitialise
.a027	4c 03 a2	jmp $a203			jmp 	ExecuteProgram
.a02a					WarmStart:
>a02a	ff						.byte 	$FF
.a02b	a2 55		ldx #$55			ldx 	#$55

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a02d					KeywordText:
>a02d	01 ff					.text $01,$ff                          ; $0000 %eol
>a02f	01 ff					.text $01,$ff                          ; $0001 %const
>a031	01 ff					.text $01,$ff                          ; $0002 %call
>a033	01 ff					.text $01,$ff                          ; $0003 %comment
>a035	01 ff					.text $01,$ff                          ; $0004 %qstring
>a037	01 ff					.text $01,$ff                          ; $0005 %define
>a039	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a03c	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a043	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a047	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a04d	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a053	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a058	01 aa					.text $01,$aa                          ; $000c *
>a05a	01 af					.text $01,$af                          ; $000d /
>a05c	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a060	01 ab					.text $01,$ab                          ; $000f +
>a062	01 ad					.text $01,$ad                          ; $0010 -
>a064	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a068	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a06b	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a06f	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a073	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a077	01 bd					.text $01,$bd                          ; $0016 =
>a079	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a07c	01 be					.text $01,$be                          ; $0018 >
>a07e	01 bc					.text $01,$bc                          ; $0019 <
>a080	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a083	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a086	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a089	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a08c	01 c0					.text $01,$c0                          ; $001e @
>a08e	01 a1					.text $01,$a1                          ; $001f !
>a090	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a093	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a099	01 de					.text $01,$de                          ; $0022 ^
>a09b	01 db					.text $01,$db                          ; $0023 [
>a09d	01 dd					.text $01,$dd                          ; $0024 ]
>a09f	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a0a3	01 bf					.text $01,$bf                          ; $0026 ?
>a0a5	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a0a9	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a0b0	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a0b4	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a0b7	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a0ba	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a0c0	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a0c3	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a0c6	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a0ca	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a0ce	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a0d2	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a0d7	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a0db	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a0df	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a0e4	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a0e9	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a0ee	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a0f4	01 bb					.text $01,$bb                          ; $0039 ;
>a0f6	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a0fd	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a102	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a106	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a10a	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a10f	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a113	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a117	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a11c	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a121	00					.byte 0
>a122						.align 2
.a122					DispatchHandler:
>a122	84 a2					.word ExecuteNextLine          ; $0000 %eol
>a124	9a a2					.word LongConstant             ; $0001 %const
>a126	e5 ac					.word Command_Call             ; $0002 %call
>a128	84 a2					.word ExecuteComment           ; $0003 %comment
>a12a	ab a2					.word StringConstant           ; $0004 %qstring
>a12c	a8 a1					.word SyntaxError              ; $0005 %define
>a12e	5b ad					.word Structure_If             ; $0006 if
>a130	0f ae					.word Struct_Repeat            ; $0007 repeat
>a132	4b ae					.word Struct_For               ; $0008 for
>a134	98 ad					.word Structure_Endif          ; $0009 endif
>a136	1b ae					.word Struct_Until             ; $000a until
>a138	8e ae					.word Struct_Next              ; $000b next
>a13a	e9 ab					.word MulInteger16             ; $000c *
>a13c	67 ab					.word DivInteger16             ; $000d /
>a13e	d8 ab					.word ModInteger16             ; $000e mod
>a140	53 aa					.word Stack_Add                ; $000f +
>a142	6b aa					.word Stack_Sub                ; $0010 -
>a144	83 aa					.word Stack_And                ; $0011 and
>a146	b1 aa					.word Stack_Or                 ; $0012 or
>a148	9a aa					.word Stack_Xor                ; $0013 xor
>a14a	c8 aa					.word Stack_Shl                ; $0014 shl
>a14c	cc aa					.word Stack_Shr                ; $0015 shr
>a14e	fd aa					.word Comp_Equal               ; $0016 =
>a150	01 ab					.word Comp_NotEqual            ; $0017 <>
>a152	4a ab					.word Comp_Greater             ; $0018 >
>a154	25 ab					.word Comp_Less                ; $0019 <
>a156	29 ab					.word Comp_GreaterEqual        ; $001a >=
>a158	46 ab					.word Comp_LessEqual           ; $001b <=
>a15a	4c a8					.word Mem_Peek                 ; $001c c@
>a15c	7e a8					.word Mem_Poke                 ; $001d c!
>a15e	62 a8					.word Mem_WPeek                ; $001e @
>a160	93 a8					.word Mem_WPoke                ; $001f !
>a162	b1 a8					.word Mem_DWPoke               ; $0020 d!
>a164	cb a8					.word Mem_Alloc                ; $0021 alloc
>a166	59 a9					.word Command_Store            ; $0022 ^
>a168	a8 a1					.word SyntaxError              ; $0023 [
>a16a	a8 a1					.word SyntaxError              ; $0024 ]
>a16c	ea a9					.word Command_Sys              ; $0025 sys
>a16e	0c aa					.word Command_DumpStack        ; $0026 ?
>a170	27 ac					.word Unary_Absolute           ; $0027 abs
>a172	30 ac					.word Unary_Negate             ; $0028 negate
>a174	45 ac					.word Unary_Not                ; $0029 not
>a176	59 ac					.word Unary_Increment          ; $002a ++
>a178	65 ac					.word Unary_Decrement          ; $002b --
>a17a	74 ac					.word Unary_BSwap              ; $002c bswap
>a17c	86 ac					.word Unary_Shl                ; $002d <<
>a17e	90 ac					.word Unary_Shr                ; $002e >>
>a180	9a ac					.word Unary_Sgn                ; $002f sgn
>a182	bd ac					.word Random_Handler           ; $0030 rnd
>a184	f9 a8					.word Stack_Empty              ; $0031 clr
>a186	ff a8					.word Stack_Drop               ; $0032 drop
>a188	04 a9					.word Stack_Dup                ; $0033 dup
>a18a	15 a9					.word Stack_Nip                ; $0034 nip
>a18c	26 a9					.word Stack_Over               ; $0035 over
>a18e	37 a9					.word Stack_Swap               ; $0036 swap
>a190	7e ad					.word Structure_Else           ; $0037 else
>a192	6f ae					.word Struct_Index             ; $0038 index
>a194	3b ad					.word Command_Return           ; $0039 ;
>a196	d3 a9					.word Command_Assert           ; $003a assert
>a198	84 a6					.word Cmd_List                 ; $003b list
>a19a	98 a9					.word Command_New              ; $003c new
>a19c	9f a9					.word Command_Old              ; $003d old
>a19e	c9 a9					.word Command_Stop             ; $003e stop
>a1a0	03 a2					.word ExecuteProgram           ; $003f run
>a1a2	c5 a9					.word Command_End              ; $0040 end
>a1a4	a8 a1					.word SyntaxError              ; $0041 save
>a1a6	a8 a1					.word SyntaxError              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a1a8					SyntaxError:
.a1a8	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a1ab	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a1b2					ErrorHandler:
.a1b2	fa		plx				plx 								; pull address off.
.a1b3	7a		ply				ply
.a1b4	e8		inx				inx 								; point to message
.a1b5	d0 01		bne $a1b8			bne 	_EHNoCarry
.a1b7	c8		iny				iny
.a1b8					_EHNoCarry:
.a1b8	20 e8 a1	jsr $a1e8			jsr 	PrintStringXY 				; print string at XY
.a1bb	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a1bd	f0 13		beq $a1d2			beq 	_EHNoLine
.a1bf	a2 d7		ldx #$d7			ldx 	#_EHMessage & $FF 			; print " AT "
.a1c1	a0 a1		ldy #$a1			ldy 	#_EHMessage >> 8
.a1c3	20 e8 a1	jsr $a1e8			jsr 	PrintStringXY
.a1c6	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a1c8	b1 00		lda ($00),y			lda 	(codePtr),y
.a1ca	aa		tax				tax
.a1cb	c8		iny				iny
.a1cc	b1 00		lda ($00),y			lda 	(codePtr),y
.a1ce	a8		tay				tay
.a1cf	20 dc a1	jsr $a1dc			jsr 	PrintIntegerUnsigned
.a1d2					_EHNoLine:
.a1d2	80 fe		bra $a1d2			bra 	_EHNoLine
.a1d4	4c 2a a0	jmp $a02a			jmp 	WarmStart
.a1d7					_EHMessage:
>a1d7	20 41 54 20 00					.text	" AT ",0
.a1dc					PrintIntegerUnsigned:
.a1dc	20 1d a5	jsr $a51d			jsr 	IntToString
.a1df	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a1e1	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a1e3	20 e8 a1	jsr $a1e8			jsr 	PrintStringXY
.a1e6	98		tya				tya
.a1e7	60		rts				rts
.a1e8					PrintStringXY:
.a1e8	86 02		stx $02				stx 	zTemp0
.a1ea	84 03		sty $03				sty 	zTemp0+1
.a1ec	a0 00		ldy #$00			ldy 	#0
.a1ee	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a1f0	f0 06		beq $a1f8			beq 	_PSExit
.a1f2	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a1f5	c8		iny				iny
.a1f6	80 f6		bra $a1ee			bra 	_PSLoop
.a1f8	60		rts		_PSExit:rts
.a1f9					PrintCharacter:
.a1f9	48		pha				pha
.a1fa	da		phx				phx
.a1fb	5a		phy				phy
.a1fc	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1ff	7a		ply				ply
.a200	fa		plx				plx
.a201	68		pla				pla
.a202	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a203					ExecuteProgram:
.a203	20 45 a4	jsr $a445			jsr 	StackReset 					; reset the CPU stack.
.a206	20 0d a4	jsr $a40d			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a209	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a20b	80 0a		bra $a217			bra 	ExecuteLoop
.a20d					ShortConstant:
.a20d	c8		iny				iny 								; skip short const
.a20e	e8		inx				inx 								; space on stack
.a20f	29 3f		and #$3f			and 	#$3F 						; the value
.a211	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a214	9e 00 07	stz $0700,x			stz 	highStack,x
.a217					ExecuteLoop:
.a217	e6 14		inc $14				inc 	breakCount 					; check break sometimes.
.a219	d0 03		bne $a21e			bne 	_EXNoBreak
.a21b	20 d2 a2	jsr $a2d2			jsr 	ExternCheckBreak
.a21e					_EXNoBreak:
.a21e	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a220	f0 58		beq $a27a			beq 	_ELUnderflow
.a222	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a224	30 07		bmi $a22d			bmi 	_ELNotToken
.a226	c8		iny				iny 								; skip the token
.a227	da		phx				phx 								; save X on the stack
.a228	0a		asl a				asl 	a 							; double the token, put into X
.a229	aa		tax				tax
.a22a	7c 22 a1	jmp ($a122,x)			jmp 	(DispatchHandler,x)
.a22d					_ELNotToken:
.a22d	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a22f	90 dc		bcc $a20d			bcc 	ShortConstant 				; yes, it's a short constant
.a231	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a233	90 1e		bcc $a253			bcc 	_ELNotFastVariable
.a235	c8		iny				iny 								; get the next token.
.a236	b1 00		lda ($00),y			lda 	(codePtr),y
.a238	88		dey				dey
.a239	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a23b	f0 16		beq $a253			beq 	_ELNotFastVariable 			; which we can optimise.
.a23d	5a		phy				phy 								; save Y
.a23e	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a240	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a241	a8		tay				tay 								; access via Y
.a242	e8		inx				inx 								; make space on the stack.
.a243	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a246	9d 00 06	sta $0600,x			sta 	lowStack,x
.a249	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a24c	9d 00 07	sta $0700,x			sta 	highStack,x
.a24f	7a		ply				ply 								; restore code pointer
.a250	c8		iny				iny 								; skip variable.
.a251	80 c4		bra $a217			bra 	ExecuteLoop
.a253					_ELNotFastVariable:
.a253	18		clc				clc									; do not autocreate if not found.
.a254	20 68 a5	jsr $a568			jsr 	VariableFind				; find the variable.
.a257	90 14		bcc $a26d			bcc 	_ELUnknown
.a259	20 b3 a3	jsr $a3b3			jsr 	IndexCheck
.a25c	5a		phy				phy 								; copy to stack
.a25d	e8		inx				inx
.a25e	b2 02		lda ($02)			lda 	(zTemp0)
.a260	9d 00 06	sta $0600,x			sta 	lowStack,x
.a263	a0 01		ldy #$01			ldy 	#1
.a265	b1 02		lda ($02),y			lda 	(zTemp0),y
.a267	9d 00 07	sta $0700,x			sta 	highStack,x
.a26a	7a		ply				ply
.a26b	80 aa		bra $a217			bra 	ExecuteLoop
.a26d					_ELUnknown:
>a26d	ff						.byte 	$FF
.a26e	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a271	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a279	00
.a27a					_ELUnderflow:
.a27a	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a27d	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a284					ExecuteNextLine:
.a284					ExecuteComment:
.a284	fa		plx				plx
.a285	18		clc				clc 								; skip forward
.a286	b2 00		lda ($00)			lda 	(codePtr)
.a288	18		clc				clc
.a289	65 00		adc $00				adc 	codePtr
.a28b	85 00		sta $00				sta 	codePtr
.a28d	90 02		bcc $a291			bcc 	_ENLNoCarry
.a28f	e6 01		inc $01				inc 	codePtr+1
.a291					_ENLNoCarry:
.a291	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a293	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a295	d0 80		bne $a217			bne 	ExecuteLoop
.a297	4c c5 a9	jmp $a9c5			jmp	 	Command_End 				; if zero end program.
.a29a					LongConstant:
.a29a	fa		plx				plx
.a29b	e8		inx				inx 								; space for constant
.a29c	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a29e	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2a1	c8		iny				iny
.a2a2	b1 00		lda ($00),y			lda 	(codePtr),y
.a2a4	9d 00 07	sta $0700,x			sta 	highStack,x
.a2a7	c8		iny				iny
.a2a8	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a2ab					StringConstant:
.a2ab	fa		plx				plx
.a2ac	e8		inx				inx
.a2ad	18		clc				clc 								; copy Y + codePtr in.
.a2ae	98		tya				tya
.a2af	65 00		adc $00				adc 	codePtr
.a2b1	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2b4	a5 01		lda $01				lda 	codePtr+1
.a2b6	69 00		adc #$00			adc 	#0
.a2b8	9d 00 07	sta $0700,x			sta 	highStack,x
.a2bb	98		tya				tya 								; add 1 + length to Y
.a2bc	38		sec				sec
.a2bd	71 00		adc ($00),y			adc 	(codePtr),y
.a2bf	a8		tay				tay
.a2c0	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a2c3					ExternInitialise:
.a2c3	a9 07		lda #$07			lda 	#$07 						; set colour
.a2c5	8d 86 02	sta $0286			sta 	646
.a2c8	a9 93		lda #$93			lda 	#147 						; clear screen
.a2ca	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2cd	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a2cf	4c f0 a2	jmp $a2f0			jmp 	ExternColour
.a2d2					ExternCheckBreak:
.a2d2	da		phx				phx 								; make sure we keep XY
.a2d3	5a		phy				phy
.a2d4	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a2d7	f0 03		beq $a2dc			beq		_ECBExit 					; stopped
.a2d9	7a		ply				ply 								; restore and exit.
.a2da	fa		plx				plx
.a2db	60		rts				rts
.a2dc					_ECBExit:
.a2dc	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a2df	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a2e6					ExternPrint:
.a2e6	48		pha				pha
.a2e7	da		phx				phx
.a2e8	5a		phy				phy
.a2e9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2ec	7a		ply				ply
.a2ed	fa		plx				plx
.a2ee	68		pla				pla
.a2ef	60		rts				rts
.a2f0					ExternColour:
.a2f0	48		pha				pha
.a2f1	da		phx				phx
.a2f2	48		pha				pha
.a2f3	29 08		and #$08			and 	#8
.a2f5	0a		asl a				asl 	a
.a2f6	0a		asl a				asl 	a
.a2f7	0a		asl a				asl 	a
.a2f8	0a		asl a				asl 	a
.a2f9	49 92		eor #$92			eor 	#$92
.a2fb	20 e6 a2	jsr $a2e6			jsr 	ExternPrint
.a2fe	a9 0e		lda #$0e			lda 	#14							; lower case
.a300	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a303	68		pla				pla
.a304	29 07		and #$07			and 	#7
.a306	aa		tax				tax
.a307	bd 10 a3	lda $a310,x			lda 	_ECTable,x
.a30a	20 e6 a2	jsr $a2e6			jsr 	ExternPrint
.a30d	fa		plx				plx
.a30e	68		pla				pla
.a30f	60		rts				rts
.a310					_ECTable:
>a310	90						.byte 	144
>a311	1c						.byte 	28
>a312	1e						.byte 	30
>a313	9e						.byte 	158
>a314	1f						.byte 	31
>a315	9c						.byte 	156
>a316	9f						.byte 	159
>a317	05						.byte 	5
.a318					ExternInput:
.a318	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a31a	85 02		sta $02				sta 	zTemp0
.a31c	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a31e	85 03		sta $03				sta 	zTemp0+1
.a320	a9 07		lda #$07			lda 	#COL_WHITE
.a322	20 f0 a2	jsr $a2f0			jsr 	ExternColour
.a325	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a328	29 7f		and #$7f			and 	#$7F
.a32a	c9 0d		cmp #$0d			cmp 	#13
.a32c	f0 0a		beq $a338			beq 	_EIExit
.a32e	92 02		sta ($02)			sta 	(zTemp0)
.a330	e6 02		inc $02				inc 	zTemp0
.a332	d0 f1		bne $a325			bne 	_EIRead
.a334	e6 03		inc $03				inc 	zTemp0+1
.a336	80 ed		bra $a325			bra 	_EIRead
.a338	a9 00		lda #$00	_EIExit:lda 	#0
.a33a	92 02		sta ($02)			sta 	(zTemp0)
.a33c	a9 0d		lda #$0d			lda 	#13
.a33e	20 e6 a2	jsr $a2e6			jsr 	ExternPrint
.a341	60		rts				rts
.a342					ExternSave:
.a342	da		phx				phx
.a343	5a		phy				phy
.a344	85 06		sta $06				sta 	zTemp2 						; save start
.a346	84 07		sty $07				sty 	zTemp2+1
.a348	20 aa a3	jsr $a3aa			jsr 	EXGetLength 				; get length of file into A
.a34b	a6 02		ldx $02				ldx 	zTemp0
.a34d	a4 03		ldy $03				ldy 	zTemp0+1
.a34f	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a352	a9 01		lda #$01			lda 	#1
.a354	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a356	a0 00		ldy #$00			ldy 	#0
.a358	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a35b	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a35d	a4 05		ldy $05				ldy 	zTemp1+1
.a35f	a9 06		lda #$06			lda 	#zTemp2
.a361	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a364	b0 03		bcs $a369			bcs 	_ESSave
.a366	7a		ply				ply
.a367	fa		plx				plx
.a368	60		rts				rts
.a369					_ESSave:
.a369	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a36c	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a374	4c 45 44 00
.a378					ExternLoad:
.a378	da		phx				phx 								; save XY
.a379	5a		phy				phy
.a37a	48		pha				pha 								; save target
.a37b	5a		phy				phy
.a37c	20 aa a3	jsr $a3aa			jsr 	EXGetLength 				; get length of file into A
.a37f	a6 02		ldx $02				ldx 	zTemp0
.a381	a4 03		ldy $03				ldy 	zTemp0+1
.a383	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a386	a9 01		lda #$01			lda 	#1
.a388	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a38a	a0 00		ldy #$00			ldy 	#0
.a38c	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a38f	7a		ply				ply 								; restore target to YX and call load
.a390	fa		plx				plx
.a391	a9 00		lda #$00			lda 	#0 							; load command
.a393	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a396	b0 03		bcs $a39b			bcs 	_ESLoad
.a398	7a		ply				ply
.a399	fa		plx				plx
.a39a	60		rts				rts
.a39b					_ESLoad:
.a39b	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a39e	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a3a6	4c 45 44 00
.a3aa					EXGetLength:
.a3aa	a0 ff		ldy #$ff			ldy 	#255
.a3ac	c8		iny		_EXGL:	iny
.a3ad	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3af	d0 fb		bne $a3ac			bne 	_EXGL
.a3b1	98		tya				tya
.a3b2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a3b3					IndexCheck:
.a3b3	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a3b5	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a3b7	f0 01		beq $a3ba			beq 	_ICFound
.a3b9	60		rts				rts
.a3ba					_ICFound:
.a3ba	c8		iny				iny 							; get next
.a3bb	b1 00		lda ($00),y			lda 	(codePtr),y
.a3bd	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a3bf	f0 2b		beq $a3ec			beq 	_ICStackIndex
.a3c1	38		sec				sec
.a3c2	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a3c4	c9 40		cmp #$40			cmp 	#$40
.a3c6	b0 1a		bcs $a3e2			bcs 	_ICError
.a3c8	0a		asl a				asl 	a 						; double index clear carry
.a3c9	5a		phy				phy 							; put into Y
.a3ca	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a3cc	48		pha				pha
.a3cd	a0 01		ldy #$01			ldy 	#1
.a3cf	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3d1	69 00		adc #$00			adc 	#0
.a3d3	85 03		sta $03				sta 	zTemp0+1
.a3d5	68		pla				pla
.a3d6	85 02		sta $02				sta 	zTemp0
.a3d8	7a		ply				ply 							; restore position.
.a3d9	c8		iny				iny								; skip index
.a3da	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a3dc	c8		iny				iny
.a3dd	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a3df	d0 01		bne $a3e2			bne 	_ICError
.a3e1	60		rts				rts
.a3e2					_ICError:
.a3e2	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a3e5	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a3ec					_ICStackIndex:
.a3ec	c8		iny				iny 							; skip the ]
.a3ed	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a3f0	0a		asl a				asl 	a
.a3f1	85 04		sta $04				sta 	zTemp1
.a3f3	bd 00 07	lda $0700,x			lda 	highStack,x
.a3f6	2a		rol a				rol 	a
.a3f7	85 05		sta $05				sta 	zTemp1+1
.a3f9	ca		dex				dex 							; throw TOS.
.a3fa	5a		phy				phy
.a3fb	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a3fd	b2 02		lda ($02)			lda 	(zTemp0)
.a3ff	65 04		adc $04				adc 	zTemp1
.a401	48		pha				pha
.a402	b1 02		lda ($02),y			lda 	(zTemp0),y
.a404	65 05		adc $05				adc 	zTemp1+1
.a406	85 03		sta $03				sta 	zTemp0+1
.a408	68		pla				pla
.a409	85 02		sta $02				sta 	zTemp0
.a40b	7a		ply				ply 							; restore pos and exit.
.a40c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a40d					ResetMemory:
.a40d	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a40f	85 0d		sta $0d				sta 	allocPtr
.a411	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a413	85 0e		sta $0e				sta 	allocPtr+1
.a415	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a417	85 0f		sta $0f				sta 	memVarPtr
.a419	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a41b	85 10		sta $10				sta 	memVarPtr+1
.a41d					_RMFindEnd:
.a41d	b2 0f		lda ($0f)			lda 	(memVarPtr)					; offset 0, found end.
.a41f	f0 0b		beq $a42c			beq 	_RMFoundEnd 				; advance to next.
.a421	18		clc				clc
.a422	65 0f		adc $0f				adc 	memVarPtr
.a424	85 0f		sta $0f				sta 	memVarPtr
.a426	90 f5		bcc $a41d			bcc 	_RMFindEnd
.a428	e6 10		inc $10				inc 	memVarPtr+1
.a42a	80 f1		bra $a41d			bra 	_RMFindEnd
.a42c					_RMFoundEnd:
.a42c	e6 0f		inc $0f				inc 	memVarPtr 					; advance past last offset $00
.a42e	d0 02		bne $a432			bne 	_RMNoCarry
.a430	e6 10		inc $10				inc 	memVarPtr+1
.a432					_RMNoCarry:
.a432	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a434					_RMEraseHash:
.a434	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a437	ca		dex				dex
.a438	10 fa		bpl $a434			bpl 	_RMEraseHash
.a43a	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a43c	85 00		sta $00				sta 	codePtr
.a43e	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a440	85 01		sta $01				sta 	codePtr+1
.a442	a0 03		ldy #$03			ldy 	#3
.a444	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a445					StackReset:
.a445	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a447	85 0a		sta $0a				sta 	iStack
.a449	a9 09		lda #$09			lda 	#IntStack >> 8
.a44b	85 0b		sta $0b				sta 	iStack+1
.a44d	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a44f	92 0a		sta ($0a)			sta 	(iStack)
.a451	60		rts				rts
.a452					StackPushByte:
.a452	c6 0a		dec $0a				dec 	iStack
.a454	92 0a		sta ($0a)			sta 	(iStack)
.a456	f0 01		beq $a459			beq 	_SPBUnderflow
.a458	60		rts				rts
.a459					_SPBUnderflow:
.a459	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a45c	53 54 41 43 4b 00				.text 	"STACK",0
.a462					StackPushPosition:
.a462	98		tya				tya
.a463	20 52 a4	jsr $a452			jsr 	StackPushByte
.a466	a5 01		lda $01				lda 	codePtr+1
.a468	20 52 a4	jsr $a452			jsr 	StackPushByte
.a46b	a5 00		lda $00				lda 	codePtr
.a46d	20 52 a4	jsr $a452			jsr 	StackPushByte
.a470	60		rts				rts
.a471					StackCheckTop:
.a471	d2 0a		cmp ($0a)			cmp 	(iStack)
.a473	f0 02		beq $a477			beq 	_SCTOk
.a475	18		clc				clc
.a476	60		rts				rts
.a477	38		sec		_SCTOk:	sec
.a478	60		rts				rts
.a479					StackPop:
.a479	18		clc				clc
.a47a	65 0a		adc $0a				adc 	iStack
.a47c	85 0a		sta $0a				sta 	iStack
.a47e	60		rts				rts
.a47f					StackRestorePosition:
.a47f	b1 0a		lda ($0a),y			lda 	(iStack),y
.a481	85 00		sta $00				sta 	codePtr
.a483	c8		iny				iny
.a484	b1 0a		lda ($0a),y			lda 	(iStack),y
.a486	85 01		sta $01				sta 	codePtr+1
.a488	c8		iny				iny
.a489	b1 0a		lda ($0a),y			lda 	(iStack),y
.a48b	a8		tay				tay
.a48c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a48d					StringToInt:
.a48d	86 08		stx $08				stx 	zTemp3 						; save string
.a48f	84 09		sty $09				sty 	zTemp3+1
.a491	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a493	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a495	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a497	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a499	f0 1b		beq $a4b6			beq 	_STIConvert 				; convert from character 1, base 16.
.a49b	88		dey				dey 								; from character 0
.a49c	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a49e	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a4a0	d0 14		bne $a4b6			bne 	_STIConvert 				; no, convert as +ve decimal
.a4a2	c8		iny				iny 								; skip the minus
.a4a3	20 b6 a4	jsr $a4b6			jsr 	_STIConvert 				; convert the unsigned part.
.a4a6	90 0d		bcc $a4b5			bcc 	_STIExit 					; failed
.a4a8	8a		txa				txa 								; 1's complement YX
.a4a9	49 ff		eor #$ff			eor 	#$FF
.a4ab	aa		tax				tax
.a4ac	98		tya				tya
.a4ad	49 ff		eor #$ff			eor 	#$FF
.a4af	a8		tay				tay
.a4b0	e8		inx				inx 								; +1 to make it negative
.a4b1	38		sec				sec
.a4b2	d0 01		bne $a4b5			bne 	_STIExit
.a4b4	c8		iny				iny
.a4b5					_STIExit:
.a4b5	60		rts				rts
.a4b6					_STIConvert:
.a4b6	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a4b8	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a4ba	f0 5f		beq $a51b			beq 	_STIFail 					; if zero, then it has failed anyway.
.a4bc	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a4be	64 03		stz $03				stz 	zTemp0+1
.a4c0					_STILoop:
.a4c0	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a4c2	85 06		sta $06				sta 	zTemp2
.a4c4	a5 03		lda $03				lda 	zTemp0+1
.a4c6	85 07		sta $07				sta 	zTemp2+1
.a4c8	64 02		stz $02				stz 	zTemp0 						; clear result
.a4ca	64 03		stz $03				stz 	zTemp0+1
.a4cc	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a4ce					_STIMultiply:
.a4ce	8a		txa				txa 								; shift Y right into carry.
.a4cf	4a		lsr a				lsr 	a
.a4d0	aa		tax				tax
.a4d1	90 0d		bcc $a4e0			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a4d3	18		clc				clc
.a4d4	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a4d6	65 02		adc $02				adc 	zTemp0
.a4d8	85 02		sta $02				sta 	zTemp0
.a4da	a5 07		lda $07				lda 	zTemp2+1
.a4dc	65 03		adc $03				adc 	zTemp0+1
.a4de	85 03		sta $03				sta 	zTemp0+1
.a4e0					_STINoAdd:
.a4e0	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a4e2	26 07		rol $07				rol 	zTemp2+1
.a4e4	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a4e6	d0 e6		bne $a4ce			bne 	_STIMultiply
.a4e8	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a4ea	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a4ec	c9 30		cmp #$30			cmp 	#"0"
.a4ee	90 2b		bcc $a51b			bcc 	_STIFail
.a4f0	c9 3a		cmp #$3a			cmp 	#"9"+1
.a4f2	90 0b		bcc $a4ff			bcc 	_STIOkay
.a4f4	c9 41		cmp #$41			cmp 	#"A"
.a4f6	90 23		bcc $a51b			bcc 	_STIFail
.a4f8	c9 47		cmp #$47			cmp 	#"F"+1
.a4fa	b0 1f		bcs $a51b			bcs 	_STIFail
.a4fc	38		sec				sec 								; hex adjust
.a4fd	e9 07		sbc #$07			sbc 	#7
.a4ff					_STIOkay:
.a4ff	38		sec				sec
.a500	e9 30		sbc #$30			sbc 	#48
.a502	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a504	b0 15		bcs $a51b			bcs 	_STIFail
.a506	d8		cld				cld
.a507	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a509	85 02		sta $02				sta 	zTemp0
.a50b	90 02		bcc $a50f			bcc 	_STINoCarry
.a50d	e6 03		inc $03				inc 	zTemp0+1
.a50f					_STINoCarry:
.a50f	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a511	c8		iny				iny 								; point to next
.a512	0a		asl a				asl 	a 							; shift bit 7 into carry
.a513	90 ab		bcc $a4c0			bcc 	_STILoop 					; not reached the end.
.a515	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a517	a4 03		ldy $03				ldy 	zTemp0+1
.a519	38		sec				sec
.a51a	60		rts				rts
.a51b					_STIFail:
.a51b	18		clc				clc
.a51c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a51d					IntToString:
.a51d	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a51f	84 03		sty $03				sty 	zTemp0+1
.a521	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a523	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a525					_ITSLoop:
.a525	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a527					_ITSSubtractLoop:
.a527	38		sec				sec
.a528	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a52a	fd 60 a5	sbc $a560,x			sbc 	_ITSWords,x
.a52d	48		pha				pha
.a52e	a5 03		lda $03				lda 	zTemp0+1
.a530	fd 61 a5	sbc $a561,x			sbc 	_ITSWords+1,x
.a533	90 09		bcc $a53e			bcc 	_ITSEndSub 					; can't subtract any more.
.a535	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a537	68		pla				pla
.a538	85 02		sta $02				sta 	zTemp0
.a53a	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a53c	80 e9		bra $a527			bra 	_ITSSubtractLoop
.a53e					_ITSEndSub:
.a53e	68		pla				pla 								; throw away the interim result
.a53f	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a541	d0 04		bne $a547			bne 	_ITSWriteOut 				; always write it out
.a543	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a545	f0 06		beq $a54d			beq 	_ITSNext 					; suppressing leading zeros.
.a547					_ITSWriteOut:
.a547	09 30		ora #$30			ora 	#48 						; output digit.
.a549	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a54c	c8		iny				iny
.a54d					_ITSNext:
.a54d	e8		inx				inx
.a54e	e8		inx				inx
.a54f	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a551	d0 d2		bne $a525			bne 	_ITSLoop 					; do the new digits
.a553	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a555	09 30		ora #$30			ora 	#48
.a557	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a55a	a9 00		lda #$00			lda 	#0
.a55c	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a55f	60		rts				rts
.a560					_ITSWords:
>a560	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a568					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a568					VariableFind:
.a568	da		phx				phx 								; save the stack position
.a569	08		php				php 								; save the create flag
.a56a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a56c	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a56e	90 10		bcc $a580			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a570	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a572	0a		asl a				asl 	a 							; double clear carry
.a573	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a575	85 02		sta $02				sta 	zTemp0
.a577	a9 0f		lda #$0f			lda		#FastVariables >>8
.a579	85 03		sta $03				sta 	zTemp0+1
.a57b	28		plp				plp 								; create flag is irrelevant.
.a57c	fa		plx				plx									; restore the old stack position
.a57d	c8		iny				iny 								; skip over the single identifier character
.a57e	38		sec				sec 								; return with CS
.a57f	60		rts				rts
.a580					_VFIsNotFastVariable:
.a580	20 43 a6	jsr $a643			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a583	20 ad a5	jsr $a5ad			jsr 	VFSearch 					; try to find the variable.
.a586	b0 0d		bcs $a595			bcs 	_VFEndSearch 				; found it, so exit
.a588	28		plp				plp 								; do we want autocreate
.a589	b0 03		bcs $a58e			bcs 	_VFCreate
.a58b	fa		plx				plx 								; restore stack position and return CC
.a58c	18		clc				clc
.a58d	60		rts				rts
.a58e					_VFCreate:
.a58e	20 43 a6	jsr $a643			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a591	20 e9 a5	jsr $a5e9			jsr 	VFCreate 					; create a new record and link it in.
.a594	08		php				php 								; save a dummy P to be popped.
.a595					_VFEndSearch:
.a595	18		clc				clc 								; the data is at offset + 4
.a596	a5 04		lda $04				lda 	zTemp1
.a598	69 04		adc #$04			adc 	#4
.a59a	85 02		sta $02				sta 	zTemp0
.a59c	a5 05		lda $05				lda 	zTemp1+1
.a59e	69 00		adc #$00			adc 	#0
.a5a0	85 03		sta $03				sta 	zTemp0+1
.a5a2	28		plp				plp 								; dump the create flag
.a5a3					_VFSkipExit:
.a5a3	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a5a5	c8		iny				iny
.a5a6	c9 e0		cmp #$e0			cmp 	#$E0
.a5a8	90 f9		bcc $a5a3			bcc 	_VFSkipExit
.a5aa	fa		plx				plx 								; restore X
.a5ab	38		sec				sec
.a5ac	60		rts				rts
.a5ad					VFSearch:
.a5ad	48		pha				pha 								; save AXY.
.a5ae	da		phx				phx
.a5af	5a		phy				phy
.a5b0	98		tya				tya									; add Y to codePtr, put in zTemp2
.a5b1	18		clc				clc 								; so it points to the identifier.
.a5b2	65 00		adc $00				adc 	codePtr
.a5b4	85 06		sta $06				sta 	zTemp2
.a5b6	a5 01		lda $01				lda 	codePtr+1
.a5b8	69 00		adc #$00			adc 	#0
.a5ba	85 07		sta $07				sta 	zTemp2+1
.a5bc					_VFSLoop:
.a5bc	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a5be	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a5c0	f0 22		beq $a5e4			beq 	_VFSFailed 					; failed.
.a5c2	aa		tax				tax 								; MSB in X
.a5c3	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a5c5	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a5c7	86 05		stx $05				stx 	zTemp1+1
.a5c9	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a5cb	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5cd	85 08		sta $08				sta 	zTemp3
.a5cf	c8		iny				iny
.a5d0	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5d2	85 09		sta $09				sta 	zTemp3+1
.a5d4	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a5d6					_VFSCheckName:
.a5d6	c8		iny				iny
.a5d7	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a5d9	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a5db	d0 df		bne $a5bc			bne 	_VFSLoop
.a5dd	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a5df	90 f5		bcc $a5d6			bcc 	_VFSCheckName
.a5e1	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a5e2	80 01		bra $a5e5			bra		_VFSExit
.a5e4					_VFSFailed:
.a5e4	18		clc				clc
.a5e5					_VFSExit:
.a5e5	7a		ply				ply 								; restore registers and exit.
.a5e6	fa		plx				plx
.a5e7	68		pla				pla
.a5e8	60		rts				rts
.a5e9					VFCreate:
.a5e9	48		pha				pha 								; save registers
.a5ea	da		phx				phx
.a5eb	5a		phy				phy
.a5ec	18		clc				clc 								; add 6 to memVarPtr, saving its
.a5ed	a5 0f		lda $0f				lda 	memVarPtr 					; address in zTemp0 as we go.
.a5ef	85 02		sta $02				sta 	zTemp0
.a5f1	69 06		adc #$06			adc 	#6
.a5f3	85 0f		sta $0f				sta 	memVarPtr
.a5f5	a5 10		lda $10				lda 	memVarPtr+1
.a5f7	85 03		sta $03				sta 	zTemp0+1
.a5f9	69 00		adc #$00			adc 	#0
.a5fb	85 10		sta $10				sta 	memVarPtr+1
.a5fd	c5 0e		cmp $0e				cmp 	allocPtr+1 					; out of memory ?
.a5ff	f0 37		beq $a638			beq 	_VFCMemory
.a601	98		tya				tya 								; work out identifier address
.a602	18		clc				clc
.a603	65 00		adc $00				adc 	codePtr
.a605	48		pha				pha
.a606	c8		iny				iny
.a607	a5 01		lda $01				lda 	codePtr+1
.a609	69 00		adc #$00			adc 	#0
.a60b	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a60d	91 02		sta ($02),y			sta 	(zTemp0),y
.a60f	88		dey				dey
.a610	68		pla				pla
.a611	91 02		sta ($02),y			sta 	(zTemp0),y
.a613	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a615	a9 00		lda #$00			lda 	#0
.a617	91 02		sta ($02),y			sta 	(zTemp0),y
.a619	c8		iny				iny
.a61a	91 02		sta ($02),y			sta 	(zTemp0),y
.a61c	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a61e	b2 04		lda ($04)			lda 	(zTemp1)
.a620	92 02		sta ($02)			sta 	(zTemp0)
.a622	b1 04		lda ($04),y			lda 	(zTemp1),y
.a624	91 02		sta ($02),y			sta 	(zTemp0),y
.a626	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a628	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a62a	a5 03		lda $03				lda 	zTemp0+1
.a62c	91 04		sta ($04),y			sta 	(zTemp1),y
.a62e	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a630	a5 02		lda $02				lda 	zTemp0
.a632	85 04		sta $04				sta 	zTemp1
.a634	7a		ply				ply
.a635	fa		plx				plx
.a636	68		pla				pla
.a637	60		rts				rts
.a638					_VFCMemory:
.a638	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a63b	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a643					VFSetupHashPointer:
.a643	48		pha				pha
.a644	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a646	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a648	0a		asl a				asl 	a 							; double it, also clears carry
.a649	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a64b	85 04		sta $04				sta 	zTemp1
.a64d	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a64f	85 05		sta $05				sta 	zTemp1+1
.a651	68		pla				pla
.a652	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.a653					TokeniseInputBuffer:
.a653	48		pha				pha
.a654	da		phx				phx
.a655	5a		phy				phy
.a656	64 15		stz $15				stz 	TokenOffset					; reset index into TokenBuffer
.a658	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.a65b	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.a65d					_TIBForward:
.a65d	e8		inx				inx
.a65e	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a661	d0 fa		bne $a65d			bne 	_TIBForward
.a663					_TIBBackward:
.a663	ca		dex				dex 								; back one.
.a664	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.a666	f0 18		beq $a680			beq 	_TIBExit					; return empty buffer
.a668	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a66b	c9 20		cmp #$20			cmp 	#" "
.a66d	f0 f4		beq $a663			beq 	_TIBBackward
.a66f	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.a672	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
>a674	ff						.byte 	$FF
.a675					_TIBMainLoop:
.a675	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.a678	f0 06		beq $a680			beq 	_TIBExit 					; done the buffer if zero.
.a67a	e8		inx				inx
.a67b	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.a67d	f0 f6		beq $a675			beq 	_TIBMainLoop
.a67f	ca		dex				dex 								; undo the last inx.
.a680					_TIBExit:
.a680	7a		ply				ply
.a681	fa		plx				plx
.a682	68		pla				pla
.a683	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a684					Cmd_List:
.a684	fa		plx				plx
.a685	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a687	64 07		stz $07				stz 	zTemp2+1
.a689	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.a68b	f0 0b		beq $a698			beq 	_CLNoStart
.a68d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.a690	85 06		sta $06				sta 	zTemp2
.a692	bd 00 07	lda $0700,x			lda 	highStack,x
.a695	85 07		sta $07				sta 	zTemp2+1
.a697	ca		dex				dex
.a698					_CLNoStart:
.a698	a9 02		lda #$02			lda 	#COL_GREEN
.a69a	20 f0 a2	jsr $a2f0			jsr 	ExternColour
.a69d					_CLNoStartLine:
.a69d	a9 00		lda #$00			lda 	#(programStart) & $FF
.a69f	85 00		sta $00				sta 	codePtr
.a6a1	a9 10		lda #$10			lda 	#(programStart) >> 8
.a6a3	85 01		sta $01				sta 	codePtr+1
.a6a5					_CLILoop:
.a6a5	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a6a7	f0 24		beq $a6cd			beq 	_CLIEnd
.a6a9	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a6ab	38		sec				sec
.a6ac	b1 00		lda ($00),y			lda 	(codePtr),y
.a6ae	e5 06		sbc $06				sbc 	zTemp2
.a6b0	c8		iny				iny
.a6b1	b1 00		lda ($00),y			lda 	(codePtr),y
.a6b3	e5 07		sbc $07				sbc 	zTemp2+1
.a6b5	90 09		bcc $a6c0			bcc 	_CLISkip
.a6b7	da		phx				phx
.a6b8	20 d0 a6	jsr $a6d0			jsr 	ListCurrent 				; list the line.
.a6bb	fa		plx				plx
.a6bc	c6 08		dec $08				dec 	zTemp3 						; done all lines
.a6be	f0 0d		beq $a6cd			beq 	_CLIEnd
.a6c0					_CLISkip:
.a6c0	18		clc				clc
.a6c1	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a6c3	65 00		adc $00				adc 	codePtr
.a6c5	85 00		sta $00				sta 	codePtr
.a6c7	90 dc		bcc $a6a5			bcc 	_CLILoop
.a6c9	e6 01		inc $01				inc 	codePtr+1
.a6cb	80 d8		bra $a6a5			bra 	_CLILoop
.a6cd					_CLIEnd:
.a6cd	4c 2a a0	jmp $a02a			jmp 	WarmStart
.a6d0					ListCurrent:
.a6d0	a0 01		ldy #$01			ldy 	#1							; print line#
.a6d2	b1 00		lda ($00),y			lda 	(codePtr),y
.a6d4	aa		tax				tax
.a6d5	c8		iny				iny
.a6d6	b1 00		lda ($00),y			lda 	(codePtr),y
.a6d8	a8		tay				tay
.a6d9	20 dc a1	jsr $a1dc			jsr 	PrintIntegerUnsigned
.a6dc	a8		tay				tay
.a6dd					_LCPadOut:
.a6dd	a9 20		lda #$20			lda 	#' '
.a6df	20 e6 a2	jsr $a2e6			jsr 	ExternPrint
.a6e2	c8		iny				iny
.a6e3	c0 06		cpy #$06			cpy 	#6
.a6e5	d0 f6		bne $a6dd			bne 	_LCPadOut
.a6e7	a0 03		ldy #$03			ldy 	#3 							; start here
.a6e9	64 13		stz $13				stz 	PrefixCharacter				; no prefix
.a6eb					_LCLoop:
.a6eb	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.a6ed	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a6ef	f0 0b		beq $a6fc			beq 	_LCNoPrefix
.a6f1	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.a6f3	f0 07		beq $a6fc			beq 	_LCNoPrefix
.a6f5	a5 13		lda $13				lda 	PrefixCharacter 			; output prefix, reset to space
.a6f7	f0 03		beq $a6fc			beq		_LCNoPrefix
.a6f9	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a6fc					_LCNoPrefix:
.a6fc	a9 20		lda #$20			lda 	#32
.a6fe	85 13		sta $13				sta 	PrefixCharacter
.a700	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.a702	f0 13		beq $a717			beq 	_LCExit
.a704	10 4d		bpl $a753			bpl 	_LCIsToken 					; +ve goto token.
.a706	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.a708	b0 13		bcs $a71d			bcs 	_LCIsIdentifier
.a70a	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.a70c	aa		tax				tax
.a70d	c8		iny				iny
.a70e	5a		phy				phy 								; push pos
.a70f	a0 00		ldy #$00			ldy 	#0
.a711	20 dc a1	jsr $a1dc			jsr 	PrintIntegerUnsigned
.a714	7a		ply				ply
.a715	80 d4		bra $a6eb			bra 	_LCLoop
.a717					_LCExit:
.a717	a9 0d		lda #$0d			lda 	#13
.a719	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a71c	60		rts				rts
.a71d					_LCIsIdentifier:
.a71d					_LCIdentLoop:
.a71d	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.a71f	20 09 a8	jsr $a809			jsr 	ListPrintIDChar
.a722	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.a724	c8		iny				iny
.a725	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.a727	b0 c2		bcs $a6eb			bcs 	_LCLoop 					; if so, do next
.a729	80 f2		bra $a71d			bra 	_LCIdentLoop				; if not loop round
.a72b					_LCConstant:
.a72b	c8		iny				iny
.a72c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.a72e	aa		tax				tax
.a72f	c8		iny				iny 								; get MSB into Y
.a730	b1 00		lda ($00),y			lda 	(codePtr),y
.a732	c8		iny				iny
.a733	5a		phy				phy
.a734	a8		tay				tay
.a735	5a		phy				phy 								; save sign
.a736	10 0c		bpl $a744			bpl 	_LCNotNegative
.a738	98		tya				tya 								; YX = |YX|
.a739	49 ff		eor #$ff			eor 	#$FF
.a73b	a8		tay				tay
.a73c	8a		txa				txa
.a73d	49 ff		eor #$ff			eor 	#$FF
.a73f	aa		tax				tax
.a740	e8		inx				inx
.a741	d0 01		bne $a744			bne 	_LCNotNegative
.a743	c8		iny				iny
.a744					_LCNotNegative:
.a744					_LCPrintYX:
.a744	20 dc a1	jsr $a1dc			jsr 	PrintIntegerUnsigned
.a747	68		pla				pla 								; restore sign
.a748	10 05		bpl $a74f			bpl 	_LCNoTrail
.a74a	a9 2d		lda #$2d			lda 	#"-"
.a74c	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a74f					_LCNoTrail:
.a74f	7a		ply				ply 								; restore Y
.a750	4c eb a6	jmp $a6eb			jmp 	_LCLoop
.a753					_LCIsToken:
.a753	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.a755	f0 d4		beq $a72b			beq 	_LCConstant
.a757	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.a759	90 3e		bcc $a799			bcc 	_LCControl
.a75b					_LCIsKeywordToken:
.a75b	85 02		sta $02				sta 	zTemp0 						; save token #
.a75d	a9 2d		lda #$2d			lda 	#(KeywordText) & $FF
.a75f	85 04		sta $04				sta 	zTemp1
.a761	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a763	85 05		sta $05				sta 	zTemp1+1
.a765	5a		phy				phy 								; save code offset
.a766					_LCForward:
.a766	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.a768	f0 0f		beq $a779			beq 	_LCFoundToken
.a76a	c6 02		dec $02				dec 	zTemp0						; dec count.
.a76c	38		sec				sec 								; go to next keyword.
.a76d	b2 04		lda ($04)			lda 	(zTemp1)
.a76f	65 04		adc $04				adc 	zTemp1
.a771	85 04		sta $04				sta 	zTemp1
.a773	90 f1		bcc $a766			bcc 	_LCForward
.a775	e6 05		inc $05				inc 	zTemp1+1
.a777	80 ed		bra $a766			bra 	_LCForward
.a779					_LCFoundToken:
.a779	a0 01		ldy #$01			ldy 	#1 							; output the token.
.a77b					_LCOutToken:
.a77b	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.a77d	29 7f		and #$7f			and 	#$7F
.a77f	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a782	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.a784	c8		iny				iny
.a785	0a		asl a				asl 	a
.a786	90 f3		bcc $a77b			bcc 	_LCOutToken
.a788	7a		ply				ply 								; restore code offset
.a789	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.a78b	c8		iny				iny
.a78c	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.a78e	f0 04		beq $a794			beq 	_LCCancelPrefix
.a790	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a792	d0 02		bne $a796			bne 	_LCGoLoop
.a794					_LCCancelPrefix:
.a794	64 13		stz $13				stz 	PrefixCharacter
.a796					_LCGoLoop:
.a796	4c eb a6	jmp $a6eb			jmp 	_LCLoop
.a799					_LCControl:
.a799	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.a79b	f0 2c		beq $a7c9			beq 	_LCDecodeCall
.a79d	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a79f	f0 1d		beq $a7be			beq 	_LCDecodeDefine
.a7a1	5a		phy				phy 								; save Y
.a7a2	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.a7a4	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.a7a6	f0 02		beq $a7aa			beq 	_LCDecodeString
.a7a8	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.a7aa					_LCDecodeString
.a7aa	98		tya				tya
.a7ab	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a7ae	7a		ply				ply 								; restore Y pos
.a7af	48		pha				pha 								; save end character on stack.
.a7b0	20 e9 a7	jsr $a7e9			jsr 	ListPrintCodeIdentifier
.a7b3	68		pla				pla 								; last character
.a7b4	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.a7b6	f0 03		beq $a7bb			beq 	_LCEDNoQuote
.a7b8	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a7bb					_LCEDNoQuote:
.a7bb	4c eb a6	jmp $a6eb			jmp 	_LCLoop
.a7be					_LCDecodeDefine:
.a7be	a9 3a		lda #$3a			lda 	#":"
.a7c0	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a7c3	20 e9 a7	jsr $a7e9			jsr 	ListPrintCodeIdentifier
.a7c6	4c eb a6	jmp $a6eb			jmp 	_LCLoop
.a7c9					_LCDecodeCall:
.a7c9	c8		iny				iny 								; get line number into XA
.a7ca	b1 00		lda ($00),y			lda 	(codePtr),y
.a7cc	48		pha				pha
.a7cd	c8		iny				iny
.a7ce	b1 00		lda ($00),y			lda 	(codePtr),y
.a7d0	c8		iny				iny
.a7d1	aa		tax				tax
.a7d2	68		pla				pla
.a7d3	20 1b a8	jsr $a81b			jsr 	ListFindLine 				; find that line.
.a7d6	90 10		bcc $a7e8			bcc 	_LCNoDefinition
.a7d8	5a		phy				phy
.a7d9	a0 03		ldy #$03			ldy 	#3 							; look at first character
.a7db	b1 02		lda ($02),y			lda 	(zTemp0),y
.a7dd	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a7df	d0 07		bne $a7e8			bne 	_LCNoDefinition 			; not define
.a7e1	20 f3 a7	jsr $a7f3			jsr 	ListPrintIdentifier
.a7e4	7a		ply				ply
.a7e5	4c eb a6	jmp $a6eb			jmp 	_LCLoop
.a7e8					_LCNoDefinition:
>a7e8	ff						.byte 	$FF 						; definition is missing.
.a7e9					ListPrintCodeIdentifier:
.a7e9	48		pha				pha 								; copy codePtr -> zTemp0
.a7ea	a5 00		lda $00				lda 	codePtr
.a7ec	85 02		sta $02				sta 	zTemp0
.a7ee	a5 01		lda $01				lda 	codePtr+1
.a7f0	85 03		sta $03				sta 	zTemp0+1
.a7f2	68		pla				pla
.a7f3					ListPrintIdentifier:
.a7f3	48		pha				pha
.a7f4	da		phx				phx
.a7f5	c8		iny				iny 								; skip over the type
.a7f6	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.a7f8	aa		tax				tax
.a7f9					_LPILoop:
.a7f9	c8		iny				iny
.a7fa	e0 00		cpx #$00			cpx 	#0
.a7fc	f0 08		beq $a806			beq 	_LPIExit
.a7fe	b1 02		lda ($02),y			lda 	(zTemp0),y
.a800	20 09 a8	jsr $a809			jsr 	ListPrintIDChar
.a803	ca		dex				dex
.a804	80 f3		bra $a7f9			bra 	_LPILoop
.a806					_LPIExit:
.a806	fa		plx				plx
.a807	68		pla				pla
.a808	60		rts				rts
.a809					ListPrintIDChar:
.a809	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.a80b	10 0a		bpl $a817			bpl	 	_LCNotDot
.a80d	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.a80f	09 40		ora #$40			ora 	#$40 						; ASCII except .
.a811	c9 5b		cmp #$5b			cmp 	#$40+27
.a813	d0 02		bne $a817			bne 	_LCNotDot
.a815	a9 2e		lda #$2e			lda 	#"."
.a817					_LCNotDot:
.a817	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.a81a	60		rts				rts
.a81b					ListFindLine:
.a81b	5a		phy				phy
.a81c	86 05		stx $05				stx 	zTemp1+1
.a81e	85 04		sta $04				sta 	zTemp1
.a820	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a822	85 02		sta $02				sta 	zTemp0
.a824	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a826	85 03		sta $03				sta 	zTemp0+1
.a828					_LFLSearch:
.a828	18		clc				clc									; reached the end.
.a829	b2 02		lda ($02)			lda 	(zTemp0)
.a82b	f0 1d		beq $a84a			beq 	_LFLExit 					; exit with CC
.a82d	a0 01		ldy #$01			ldy 	#1
.a82f	a5 04		lda $04				lda 	zTemp1
.a831	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a833	d0 07		bne $a83c			bne 	_LFLNext
.a835	c8		iny				iny
.a836	a5 05		lda $05				lda 	zTemp1+1
.a838	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a83a	f0 0d		beq $a849			beq 	_LFLFound
.a83c					_LFLNext:
.a83c	18		clc				clc
.a83d	b2 02		lda ($02)			lda 	(zTemp0)
.a83f	65 02		adc $02				adc 	zTemp0
.a841	85 02		sta $02				sta 	zTemp0
.a843	90 e3		bcc $a828			bcc 	_LFLSearch
.a845	e6 03		inc $03				inc 	zTemp0+1
.a847	80 df		bra $a828			bra 	_LFLSearch
.a849					_LFLFound:
.a849	38		sec				sec
.a84a					_LFLExit:
.a84a	7a		ply				ply
.a84b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.a84c					Mem_Peek:
.a84c	fa		plx				plx
.a84d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a850	85 02		sta $02				sta 	zTemp0
.a852	bd 00 07	lda $0700,x			lda 	highStack,x
.a855	85 03		sta $03				sta 	zTemp0+1
.a857	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a859	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a85c	9e 00 07	stz $0700,x			stz 	highStack,x
.a85f	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a862					Mem_WPeek:
.a862	fa		plx				plx
.a863	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a866	85 02		sta $02				sta 	zTemp0
.a868	bd 00 07	lda $0700,x			lda 	highStack,x
.a86b	85 03		sta $03				sta 	zTemp0+1
.a86d	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a86f	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a872	5a		phy				phy 								; read msb
.a873	a0 01		ldy #$01			ldy 	#1
.a875	b1 02		lda ($02),y			lda 	(zTemp0),y
.a877	7a		ply				ply
.a878	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.a87b	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a87e					Mem_Poke:
.a87e	fa		plx				plx
.a87f	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a882	85 02		sta $02				sta 	zTemp0
.a884	bd 00 07	lda $0700,x			lda 	highStack,x
.a887	85 03		sta $03				sta 	zTemp0+1
.a889	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a88c	92 02		sta ($02)			sta 	(zTemp0)
.a88e	ca		dex				dex
.a88f	ca		dex				dex
.a890	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a893					Mem_WPoke:
.a893	fa		plx				plx
.a894	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a897	85 02		sta $02				sta 	zTemp0
.a899	bd 00 07	lda $0700,x			lda 	highStack,x
.a89c	85 03		sta $03				sta 	zTemp0+1
.a89e	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a8a1	92 02		sta ($02)			sta 	(zTemp0)
.a8a3	5a		phy				phy
.a8a4	a0 01		ldy #$01			ldy 	#1
.a8a6	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.a8a9	91 02		sta ($02),y			sta 	(zTemp0),y
.a8ab	7a		ply				ply
.a8ac	ca		dex				dex
.a8ad	ca		dex				dex
.a8ae	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a8b1					Mem_DWPoke:
.a8b1	fa		plx				plx
.a8b2	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a8b5	85 02		sta $02				sta 	zTemp0
.a8b7	bd 00 07	lda $0700,x			lda 	highStack,x
.a8ba	85 03		sta $03				sta 	zTemp0+1
.a8bc	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a8bf	92 02		sta ($02)			sta 	(zTemp0)
.a8c1	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.a8c4	92 02		sta ($02)			sta 	(zTemp0)
.a8c6	ca		dex				dex
.a8c7	ca		dex				dex
.a8c8	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a8cb					Mem_Alloc:
.a8cb	fa		plx				plx
.a8cc	38		sec				sec 								; subtract count from alloc ptr
.a8cd	a5 0d		lda $0d				lda 	allocPtr
.a8cf	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.a8d2	85 0d		sta $0d				sta 	allocPtr
.a8d4	48		pha				pha 								; save low.
.a8d5	a5 0e		lda $0e				lda 	allocPtr+1
.a8d7	fd 00 07	sbc $0700,x			sbc 	highStack,x
.a8da	85 0e		sta $0e				sta 	allocPtr+1
.a8dc	90 10		bcc $a8ee			bcc 	_MAError 					; borrow ?
.a8de	c5 10		cmp $10				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.a8e0	90 0c		bcc $a8ee			bcc 	_MAError
.a8e2	f0 0a		beq $a8ee			beq 	_MAError
.a8e4	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.a8e7	68		pla				pla
.a8e8	9d 00 06	sta $0600,x			sta 	lowStack,x
.a8eb	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a8ee					_MAError:
.a8ee	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a8f1	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.a8f9					Stack_Empty:
.a8f9	fa		plx				plx
.a8fa	a2 00		ldx #$00			ldx 	#0
.a8fc	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a8ff					Stack_Drop:
.a8ff	fa		plx				plx
.a900	ca		dex				dex
.a901	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a904					Stack_Dup:
.a904	fa		plx				plx
.a905	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.a908	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.a90b	bd 00 07	lda $0700,x			lda 	highStack,x
.a90e	9d 01 07	sta $0701,x			sta 	highStack+1,x
.a911	e8		inx				inx 								; bump stack pointer
.a912	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a915					Stack_Nip:
.a915	fa		plx				plx
.a916	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.a919	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.a91c	bd 00 07	lda $0700,x			lda 	highStack,x
.a91f	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.a922	ca		dex				dex 								; drop tos
.a923	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a926					Stack_Over:
.a926	fa		plx				plx
.a927	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.a92a	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.a92d	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.a930	9d 01 07	sta $0701,x			sta 	highStack+1,x
.a933	e8		inx				inx 							; bump stack pointer
.a934	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a937					Stack_Swap:
.a937	fa		plx				plx
.a938	5a		phy				phy
.a939	bd 00 06	lda $0600,x			lda 	lowStack,x
.a93c	a8		tay				tay
.a93d	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.a940	9d 00 06	sta $0600,x			sta 	lowStack,x
.a943	98		tya				tya
.a944	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.a947	bd 00 07	lda $0700,x			lda 	highStack,x
.a94a	a8		tay				tay
.a94b	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.a94e	9d 00 07	sta $0700,x			sta 	highStack,x
.a951	98		tya				tya
.a952	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.a955	7a		ply				ply
.a956	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.a959					Command_Store:
.a959	fa		plx				plx
.a95a	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.a95c	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.a95e	90 1f		bcc $a97f			bcc 	_CSLongVariable
.a960	c8		iny				iny 								; get the next
.a961	b1 00		lda ($00),y			lda 	(codePtr),y
.a963	88		dey				dey
.a964	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.a966	f0 17		beq $a97f			beq 	_CSLongVariable
.a968	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.a96a	c8		iny				iny 								; skip over it and push on stack
.a96b	5a		phy				phy
.a96c	0a		asl a				asl 	a 							; double it, now C0-FE
.a96d	a8		tay				tay 								; put in Y
.a96e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.a971	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.a974	bd 00 07	lda $0700,x			lda 	highStack,x
.a977	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.a97a	ca		dex				dex 								; pop off stack
.a97b	7a		ply				ply 								; restore position and do next
.a97c	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a97f					_CSLongVariable:
.a97f	38		sec				sec 								; create variable if not found.
.a980	20 68 a5	jsr $a568			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.a983	20 b3 a3	jsr $a3b3			jsr 	IndexCheck 					; check indexing.
.a986	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.a989	92 02		sta ($02)			sta 	(zTemp0)
.a98b	5a		phy				phy
.a98c	a0 01		ldy #$01			ldy 	#1
.a98e	bd 00 07	lda $0700,x			lda 	highStack,x
.a991	91 02		sta ($02),y			sta 	(zTemp0),y
.a993	7a		ply				ply
.a994	ca		dex				dex 								; pop off stack
.a995	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.a998					Command_New:
.a998	fa		plx				plx
.a999	9c 00 10	stz $1000			stz 	ProgramStart
.a99c	4c 2a a0	jmp $a02a			jmp 	WarmStart
.a99f					Command_Old:
.a99f	fa		plx				plx
.a9a0	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a9a2	85 00		sta $00				sta 	codePtr
.a9a4	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a9a6	85 01		sta $01				sta 	codePtr+1
.a9a8	a0 03		ldy #$03			ldy 	#3
.a9aa					_COAdvance:
.a9aa	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.a9ac	b0 0e		bcs $a9bc			bcs		_COFail
.a9ae	20 d0 ad	jsr $add0			jsr 	AdvanceInCode
.a9b1	b1 00		lda ($00),y			lda 	(codePtr),y
.a9b3	d0 f5		bne $a9aa			bne 	_COAdvance
.a9b5	c8		iny				iny 								; byte after end of line
.a9b6	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.a9b9					_CONotDeleted:
.a9b9	4c 2a a0	jmp $a02a			jmp 	WarmStart
.a9bc					_COFail:
.a9bc	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a9bf	43 41 4e 54 3f 00				.text 	"CANT?",0
.a9c5					Command_End:
.a9c5	fa		plx				plx
.a9c6	4c 2a a0	jmp $a02a			jmp 	WarmStart
.a9c9					Command_Stop:
>a9c9	ff						.byte 	$FF
.a9ca	fa		plx				plx
.a9cb	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a9ce	53 54 4f 50 00					.text 	"STOP",0
.a9d3					Command_Assert:
.a9d3	fa		plx				plx
.a9d4	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.a9d7	1d 00 07	ora $0700,x			ora 	highStack,x
.a9da	f0 04		beq $a9e0			beq 	_CAFail
.a9dc	ca		dex				dex 								; throw if not.
.a9dd	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.a9e0					_CAFail:
.a9e0	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>a9e3	41 53 53 45 52 54 00				.text 	"ASSERT",0
.a9ea					Command_Sys:
.a9ea	fa		plx				plx
.a9eb	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.a9ee	85 02		sta $02				sta 	zTemp0
.a9f0	bd 00 07	lda $0700,x			lda 	highStack,x
.a9f3	85 03		sta $03				sta 	zTemp0+1
.a9f5	ca		dex				dex 								; pop tos
.a9f6	da		phx				phx 								; save XY
.a9f7	5a		phy				phy
.a9f8	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.a9fb	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.a9fe	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.aa01	20 09 aa	jsr $aa09			jsr 	_CSCallInd
.aa04	7a		ply				ply 								; restore XY
.aa05	fa		plx				plx
.aa06	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aa09					_CSCallInd:
.aa09	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.aa0c					Command_DumpStack:
.aa0c	fa		plx				plx
.aa0d	da		phx				phx 								; save pos and sp
.aa0e	5a		phy				phy
.aa0f	86 0c		stx $0c				stx 	SignCount
.aa11	a2 ff		ldx #$ff			ldx 	#$FF
.aa13					_CDSLoop:
.aa13	e4 0c		cpx $0c				cpx 	SignCount 					; done all ?
.aa15	f0 2a		beq $aa41			beq 	_CDSExit
.aa17	e8		inx				inx
.aa18	da		phx				phx 								; save SP
.aa19	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.aa1c	a8		tay				tay
.aa1d	bd 00 06	lda $0600,x			lda 	lowStack,x
.aa20	aa		tax				tax
.aa21	c0 00		cpy #$00			cpy 	#0
.aa23	10 11		bpl $aa36			bpl 	_CDSPositive
.aa25	a9 2d		lda #$2d			lda 	#"-" 						; minus
.aa27	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.aa2a	98		tya				tya 								; negate YX
.aa2b	49 ff		eor #$ff			eor 	#$FF
.aa2d	a8		tay				tay
.aa2e	8a		txa				txa
.aa2f	49 ff		eor #$ff			eor 	#$FF
.aa31	aa		tax				tax
.aa32	e8		inx				inx
.aa33	d0 01		bne $aa36			bne 	_CDSPositive
.aa35	c8		iny				iny
.aa36					_CDSPositive:
.aa36	20 dc a1	jsr $a1dc			jsr 	PrintIntegerUnsigned
.aa39	a9 20		lda #$20			lda 	#" " 						; space
.aa3b	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.aa3e	fa		plx				plx
.aa3f	80 d2		bra $aa13			bra 	_CDSLoop
.aa41					_CDSExit:
.aa41	a9 3c		lda #$3c			lda 	#"<"
.aa43	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.aa46	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.aa49	a9 0d		lda #$0d			lda 	#13 						; CR
.aa4b	20 f9 a1	jsr $a1f9			jsr 	PrintCharacter
.aa4e	7a		ply				ply
.aa4f	fa		plx				plx
.aa50	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.aa53					Stack_Add:
.aa53	fa		plx				plx
.aa54	ca		dex				dex
.aa55	18		clc				clc
.aa56	bd 00 06	lda $0600,x			lda		lowStack,x
.aa59	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.aa5c	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa5f	bd 00 07	lda $0700,x			lda		highStack,x
.aa62	7d 01 07	adc $0701,x			adc 	highStack+1,x
.aa65	9d 00 07	sta $0700,x			sta 	highStack,x
.aa68	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aa6b					Stack_Sub:
.aa6b	fa		plx				plx
.aa6c	ca		dex				dex
.aa6d	38		sec				sec
.aa6e	bd 00 06	lda $0600,x			lda		lowStack,x
.aa71	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.aa74	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa77	bd 00 07	lda $0700,x			lda		highStack,x
.aa7a	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.aa7d	9d 00 07	sta $0700,x			sta 	highStack,x
.aa80	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aa83					Stack_And:
.aa83	fa		plx				plx
.aa84	ca		dex				dex
.aa85	bd 00 06	lda $0600,x			lda		lowStack,x
.aa88	3d 01 06	and $0601,x			and		lowStack+1,x
.aa8b	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa8e	bd 00 07	lda $0700,x			lda		highStack,x
.aa91	3d 01 07	and $0701,x			and 	highStack+1,x
.aa94	9d 00 07	sta $0700,x			sta 	highStack,x
.aa97	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aa9a					Stack_Xor:
.aa9a	fa		plx				plx
.aa9b	ca		dex				dex
.aa9c	bd 00 06	lda $0600,x			lda		lowStack,x
.aa9f	5d 01 06	eor $0601,x			eor		lowStack+1,x
.aaa2	9d 00 06	sta $0600,x			sta 	lowStack,x
.aaa5	bd 00 07	lda $0700,x			lda		highStack,x
.aaa8	5d 01 07	eor $0701,x			eor 	highStack+1,x
.aaab	9d 00 07	sta $0700,x			sta 	highStack,x
.aaae	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aab1					Stack_Or:
.aab1	fa		plx				plx
.aab2	ca		dex				dex
.aab3	bd 00 06	lda $0600,x			lda		lowStack,x
.aab6	1d 01 06	ora $0601,x			ora		lowStack+1,x
.aab9	9d 00 06	sta $0600,x			sta 	lowStack,x
.aabc	bd 00 07	lda $0700,x			lda		highStack,x
.aabf	1d 01 07	ora $0701,x			ora 	highStack+1,x
.aac2	9d 00 07	sta $0700,x			sta 	highStack,x
.aac5	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aac8					Stack_Shl:
.aac8	fa		plx				plx
.aac9	38		sec				sec
.aaca	80 02		bra $aace			bra 	StackShift
.aacc					Stack_Shr:
.aacc	fa		plx				plx
.aacd	18		clc				clc
.aace					StackShift:
.aace	08		php				php
.aacf	ca		dex				dex
.aad0	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.aad3	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.aad5	1d 01 07	ora $0701,x			ora 	highStack+1,x
.aad8	d0 19		bne $aaf3			bne 	_SSZero
.aada					_SSLoop:
.aada	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.aadd	30 1a		bmi $aaf9			bmi 	_SSDone 					; completed ?
.aadf	28		plp				plp 								; restore flag
.aae0	08		php				php
.aae1	b0 08		bcs $aaeb			bcs 	_SSLeft 					; do either shift.
.aae3	5e 00 07	lsr $0700,x			lsr 	highStack,x
.aae6	7e 00 06	ror $0600,x			ror 	lowStack,x
.aae9	80 ef		bra $aada			bra 	_SSLoop
.aaeb					_SSLeft:
.aaeb	1e 00 06	asl $0600,x			asl 	lowStack,x
.aaee	3e 00 07	rol $0700,x			rol 	highStack,x
.aaf1	80 e7		bra $aada			bra 	_SSLoop
.aaf3					_SSZero:
.aaf3	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.aaf6	9e 00 07	stz $0700,x			stz 	highStack,x
.aaf9					_SSDone:
.aaf9	28		plp				plp 								; throw flag.
.aafa	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.aafd					Comp_Equal:
.aafd	fa		plx				plx
.aafe	38		sec				sec
.aaff	80 02		bra $ab03			bra 	Comp_CheckEqual
.ab01					Comp_NotEqual:
.ab01	fa		plx				plx
.ab02	18		clc				clc
.ab03					Comp_CheckEqual:
.ab03	08		php				php
.ab04	ca		dex				dex
.ab05	bd 00 06	lda $0600,x			lda		lowStack,x
.ab08	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.ab0b	d0 06		bne $ab13			bne 	_CCENonZero
.ab0d	bd 00 07	lda $0700,x			lda		highStack,x
.ab10	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ab13					_CCENonZero:
.ab13	f0 02		beq $ab17			beq 	_CCENotSet
.ab15	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.ab17					_CCENotSet:
.ab17					CompCheckFlip:
.ab17	28		plp				plp 								; if carry set, we want $FF if equal
.ab18	90 02		bcc $ab1c			bcc 	CompReturn
.ab1a	49 ff		eor #$ff			eor 	#$FF
.ab1c					CompReturn:
.ab1c	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.ab1f	9d 00 07	sta $0700,x			sta 	highStack,x
.ab22	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ab25					Comp_Less:
.ab25	fa		plx				plx
.ab26	18		clc				clc
.ab27	80 02		bra $ab2b			bra 	Comp_LessCont
.ab29					Comp_GreaterEqual:
.ab29	fa		plx				plx
.ab2a	38		sec				sec
.ab2b					Comp_LessCont:
.ab2b	08		php				php
.ab2c	ca		dex				dex
.ab2d	38		sec				sec
.ab2e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.ab31	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ab34	bd 00 07	lda $0700,x			lda 	highStack,x
.ab37	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ab3a	50 02		bvc $ab3e			bvc 	_CLNoFlip 					; unsigned -> signed
.ab3c	49 80		eor #$80			eor 	#$80
.ab3e					_CLNoFlip:
.ab3e	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ab40	f0 d5		beq $ab17			beq 	CompCheckFlip
.ab42	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ab44	80 d1		bra $ab17			bra 	CompCheckFlip
.ab46					Comp_LessEqual:
.ab46	fa		plx				plx
.ab47	38		sec				sec
.ab48	80 02		bra $ab4c			bra 	Comp_LessEqualCont
.ab4a					Comp_Greater:
.ab4a	fa		plx				plx
.ab4b	18		clc				clc
.ab4c					Comp_LessEqualCont:
.ab4c	08		php				php
.ab4d	ca		dex				dex
.ab4e	38		sec				sec
.ab4f	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.ab52	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ab55	bd 01 07	lda $0701,x			lda 	highStack+1,x
.ab58	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ab5b	50 02		bvc $ab5f			bvc 	_CLENoFlip 					; unsigned -> signed
.ab5d	49 80		eor #$80			eor 	#$80
.ab5f					_CLENoFlip:
.ab5f	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ab61	f0 b4		beq $ab17			beq 	CompCheckFlip
.ab63	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ab65	80 b0		bra $ab17			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.ab67					DivInteger16:
.ab67	fa		plx				plx
.ab68	20 6e ab	jsr $ab6e			jsr 	IntegerDivide
.ab6b	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ab6e					IntegerDivide:
.ab6e	ca		dex				dex
.ab6f	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.ab72	1d 01 07	ora $0701,x			ora 	highStack+1,x
.ab75	d0 14		bne $ab8b			bne 	_BFDOkay
.ab77	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>ab7a	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ab82	20 42 59 20 5a 45 52 4f 00
.ab8b					_BFDOkay:
.ab8b	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.ab8d	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.ab8f	64 0c		stz $0c				stz 	SignCount 					; Count of signs.
.ab91	20 cd ab	jsr $abcd			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ab94	e8		inx				inx
.ab95	20 cd ab	jsr $abcd			jsr 	CheckIntegerNegate
.ab98	ca		dex				dex
.ab99	5a		phy				phy 								; Y is the counter
.ab9a	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.ab9c					_BFDLoop:
.ab9c	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.ab9f	3e 00 07	rol $0700,x			rol 	highStack,x
.aba2	26 04		rol $04				rol 	zTemp1
.aba4	26 05		rol $05				rol 	zTemp1+1
.aba6	38		sec				sec
.aba7	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.aba9	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.abac	48		pha				pha
.abad	a5 05		lda $05				lda 	zTemp1+1
.abaf	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.abb2	90 0f		bcc $abc3			bcc 	_BFDNoAdd
.abb4	85 05		sta $05				sta 	zTemp1+1
.abb6	68		pla				pla
.abb7	85 04		sta $04				sta 	zTemp1+0
.abb9	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.abbc	09 01		ora #$01			ora 	#1
.abbe	9d 00 06	sta $0600,x			sta 	lowStack,x
.abc1	80 01		bra $abc4			bra 	_BFDNext
.abc3					_BFDNoAdd:
.abc3	68		pla				pla 								; Throw away the intermediate calculations
.abc4					_BFDNext:
.abc4	88		dey				dey
.abc5	d0 d5		bne $ab9c			bne 	_BFDLoop
.abc7	7a		ply				ply 								; restore Y
.abc8	46 0c		lsr $0c				lsr 	SignCount 					; if sign count odd,
.abca	b0 07		bcs $abd3			bcs		IntegerNegateAlways 		; negate the result
.abcc	60		rts				rts
.abcd					CheckIntegerNegate:
.abcd	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.abd0	30 01		bmi $abd3			bmi 	IntegerNegateAlways 		; if so negate it
.abd2	60		rts				rts
.abd3					IntegerNegateAlways:
.abd3	e6 0c		inc $0c				inc 	SignCount 					; bump the count of signs
.abd5	4c 30 ac	jmp $ac30			jmp 	Unary_Negate
.abd8					ModInteger16:
.abd8	fa		plx				plx
.abd9	20 6e ab	jsr $ab6e			jsr 	IntegerDivide
.abdc	a5 04		lda $04				lda 	zTemp1
.abde	9d 00 06	sta $0600,x			sta 	lowStack,x
.abe1	a5 05		lda $05				lda 	zTemp1+1
.abe3	9d 00 07	sta $0700,x			sta 	highStack,x
.abe6	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.abe9					MulInteger16:
.abe9	fa		plx				plx
.abea	ca		dex				dex
.abeb	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.abee	85 04		sta $04				sta 	zTemp1
.abf0	bd 00 07	lda $0700,x			lda 	highStack,x
.abf3	85 05		sta $05				sta 	zTemp1+1
.abf5	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.abf8	9e 00 07	stz $0700,x			stz 	highStack,x
.abfb					_BFMMultiply:
.abfb	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.abfd	29 01		and #$01			and 	#1
.abff	f0 13		beq $ac14			beq 	_BFMNoAdd
.ac01	18		clc				clc 								; add old tos to current tos.
.ac02	bd 00 06	lda $0600,x			lda		lowStack,x
.ac05	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ac08	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac0b	bd 00 07	lda $0700,x			lda		highStack,x
.ac0e	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ac11	9d 00 07	sta $0700,x			sta 	highStack,x
.ac14					_BFMNoAdd:
.ac14	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.ac17	3e 01 07	rol $0701,x			rol 	highStack+1,x
.ac1a	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.ac1c	66 04		ror $04				ror 	zTemp1+0
.ac1e	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.ac20	05 05		ora $05				ora 	zTemp1+1
.ac22	d0 d7		bne $abfb			bne 	_BFMMultiply
.ac24	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.ac27					Unary_Absolute:
.ac27	fa		plx				plx
.ac28	bd 00 07	lda $0700,x			lda 	highStack,x
.ac2b	30 04		bmi $ac31			bmi 	Unary_Negate_Code
.ac2d	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac30					Unary_Negate:
.ac30	fa		plx				plx
.ac31					Unary_Negate_Code:
.ac31	38		sec				sec
.ac32	a9 00		lda #$00			lda		#0
.ac34	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ac37	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac3a	a9 00		lda #$00			lda		#0
.ac3c	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ac3f	9d 00 07	sta $0700,x			sta 	highStack,x
.ac42	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac45					Unary_Not:
.ac45	fa		plx				plx
.ac46	bd 00 06	lda $0600,x			lda 	lowStack,x
.ac49	49 ff		eor #$ff			eor 	#$FF
.ac4b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac4e	bd 00 07	lda $0700,x			lda 	highStack,x
.ac51	49 ff		eor #$ff			eor 	#$FF
.ac53	9d 00 07	sta $0700,x			sta 	highStack,x
.ac56	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac59					Unary_Increment:
.ac59	fa		plx				plx
.ac5a	fe 00 06	inc $0600,x			inc 	lowStack,x
.ac5d	d0 03		bne $ac62			bne 	_UIExit
.ac5f	fe 00 07	inc $0700,x			inc 	highStack,x
.ac62					_UIExit:
.ac62	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac65					Unary_Decrement:
.ac65	fa		plx				plx
.ac66	bd 00 06	lda $0600,x			lda 	lowStack,x
.ac69	d0 03		bne $ac6e			bne 	_UDNoBorrow
.ac6b	de 00 07	dec $0700,x			dec 	highStack,x
.ac6e					_UDNoBorrow:
.ac6e	de 00 06	dec $0600,x			dec 	lowStack,x
.ac71	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac74					Unary_BSwap:
.ac74	fa		plx				plx
.ac75	bd 00 06	lda $0600,x			lda 	lowStack,x
.ac78	48		pha				pha
.ac79	bd 00 07	lda $0700,x			lda 	highStack,x
.ac7c	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac7f	68		pla				pla
.ac80	9d 00 07	sta $0700,x			sta 	highStack,x
.ac83	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac86					Unary_Shl:
.ac86	fa		plx				plx
.ac87	1e 00 06	asl $0600,x			asl 	lowStack,x
.ac8a	3e 00 07	rol $0700,x			rol 	highStack,x
.ac8d	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac90					Unary_Shr:
.ac90	fa		plx				plx
.ac91	5e 00 07	lsr $0700,x			lsr 	highStack,x
.ac94	7e 00 06	ror $0600,x			ror 	lowStack,x
.ac97	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ac9a					Unary_Sgn:
.ac9a	fa		plx				plx
.ac9b	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.ac9e	10 0a		bpl $acaa			bpl 	_USNotNeg
.aca0	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.aca2	9d 00 06	sta $0600,x			sta 	lowStack,x
.aca5	9d 00 07	sta $0700,x			sta 	highStack,x
.aca8	80 10		bra $acba			bra 	_USExit
.acaa					_USNotNeg:
.acaa	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.acad	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.acb0	9e 00 07	stz $0700,x			stz 	highStack,x
.acb3	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.acb5	f0 03		beq $acba			beq 	_USExit
.acb7	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.acba					_USExit:
.acba	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.acbd					Random_Handler:
.acbd	fa		plx				plx
.acbe	a5 11		lda $11				lda 	randomSeed
.acc0	05 12		ora $12				ora 	randomSeed+1
.acc2	d0 08		bne $accc			bne 	_RH_NoInit
.acc4	a9 7c		lda #$7c			lda 	#$7C
.acc6	85 11		sta $11				sta 	randomSeed
.acc8	a9 a1		lda #$a1			lda 	#$A1
.acca	85 12		sta $12				sta 	randomSeed+1
.accc					_RH_NoInit:
.accc	a5 11		lda $11				lda 	randomSeed
.acce	4a		lsr a		        lsr		a
.accf	26 12		rol $12		        rol 	randomSeed+1
.acd1	90 02		bcc $acd5	        bcc 	_RH_NoEor
.acd3	49 b4		eor #$b4	        eor 	#$B4
.acd5					_RH_NoEor:
.acd5	85 11		sta $11		        sta 	randomSeed
.acd7	45 12		eor $12		        eor 	randomSeed+1
.acd9	e8		inx		        inx
.acda	9d 00 07	sta $0700,x	        sta 	highStack,x
.acdd	a5 11		lda $11		        lda 	randomSeed
.acdf	9d 00 06	sta $0600,x	        sta 	lowStack,x
.ace2	4c 17 a2	jmp $a217			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.ace5					Command_Call:
.ace5	fa		plx				plx
.ace6	20 62 a4	jsr $a462			jsr 	StackPushPosition 				; save stack position
.ace9	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.aceb	20 52 a4	jsr $a452			jsr 	StackPushByte
.acee	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.acf0	85 02		sta $02				sta 	zTemp0
.acf2	c8		iny				iny
.acf3	b1 00		lda ($00),y			lda 	(codePtr),y
.acf5	85 03		sta $03				sta 	zTemp0+1
.acf7	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.acf9	85 00		sta $00				sta 	codePtr
.acfb	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.acfd	85 01		sta $01				sta 	codePtr+1
.acff	a0 01		ldy #$01			ldy 	#1
.ad01					_CCSearch:
.ad01	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.ad03	f0 2d		beq $ad32			beq		_CCFail
.ad05	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.ad07	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.ad09	f0 0d		beq $ad18			beq 	_CCCheckMSB
.ad0b	18		clc				clc 									; forward to next line.
.ad0c	b2 00		lda ($00)			lda 	(codePtr)
.ad0e	65 00		adc $00				adc 	codePtr
.ad10	85 00		sta $00				sta 	codePtr
.ad12	90 ed		bcc $ad01			bcc 	_CCSearch
.ad14	e6 01		inc $01				inc 	codePtr+1
.ad16	80 e9		bra $ad01			bra 	_CCSearch
.ad18					_CCCheckMSB:
.ad18	c8		iny				iny 									; get MSB, keeping Y as 1
.ad19	b1 00		lda ($00),y			lda 	(codePtr),y
.ad1b	88		dey				dey
.ad1c	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.ad1e	d0 e1		bne $ad01			bne 	_CCSearch
.ad20	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.ad22	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.ad24	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ad26	d0 0a		bne $ad32			bne 	_CCFail
.ad28	c8		iny				iny 									; get the length of this.
.ad29	b1 00		lda ($00),y			lda 	(codePtr),y
.ad2b	18		clc				clc
.ad2c	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.ad2e	a8		tay				tay
.ad2f	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ad32					_CCFail:
.ad32	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>ad35	43 41 4c 4c 3f 00				.text 	"CALL?",0
.ad3b					Command_Return:
.ad3b	fa		plx				plx
.ad3c	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.ad3e	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ad41	90 0f		bcc $ad52			bcc 	_CRFail
.ad43	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.ad45	20 7f a4	jsr $a47f			jsr 	StackRestorePosition
.ad48	c8		iny				iny
.ad49	c8		iny				iny
.ad4a	a9 04		lda #$04			lda 	#4 								; pop off stack
.ad4c	20 79 a4	jsr $a479			jsr 	StackPop
.ad4f	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ad52					_CRFail:
.ad52	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>ad55	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.ad5b					Structure_If:
.ad5b	fa		plx				plx
.ad5c	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.ad5e	20 52 a4	jsr $a452			jsr 	StackPushByte
.ad61	18		clc				clc
.ad62	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.ad65	1d 00 07	ora $0700,x			ora 	highStack,x
.ad68	ca		dex				dex 									; drop TOS
.ad69	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.ad6b	d0 0e		bne $ad7b			bne 	_SIFNoSkip 						; at this level.
.ad6d	da		phx				phx
.ad6e	a9 37		lda #$37			lda 	#KWD_ELSE
.ad70	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.ad72	20 a8 ad	jsr $ada8			jsr 	StructSkipForward
.ad75	fa		plx				plx 									; restore X
.ad76	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.ad78	d0 01		bne $ad7b			bne 	_SIFNoSkip 						; clause.
.ad7a	c8		iny				iny
.ad7b					_SIFNoSkip:
.ad7b	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ad7e					Structure_Else:
.ad7e	fa		plx				plx
.ad7f	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ad81	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ad84	90 0b		bcc $ad91			bcc 	SIFail
.ad86	da		phx				phx 									; got here by executing IF clause so skip
.ad87	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.ad89	aa		tax				tax
.ad8a	20 a8 ad	jsr $ada8			jsr 	StructSkipForward
.ad8d	fa		plx				plx
.ad8e	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ad91					SIFail:
.ad91	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>ad94	49 46 3f 00					.text 	"IF?",0
.ad98					Structure_Endif:
.ad98	fa		plx				plx
.ad99	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ad9b	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ad9e	90 f1		bcc $ad91			bcc 	SIFail
.ada0	a9 01		lda #$01			lda 	#1 								; throw it.
.ada2	20 79 a4	jsr $a479			jsr 	StackPop
.ada5	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ada8					StructSkipForward:
.ada8	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.adaa	86 03		stx $03				stx 	zTemp0+1
.adac	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.adae					_SSFLoop:
.adae	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.adb0	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.adb2	d0 08		bne $adbc			bne		_SSFFail
.adb4	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.adb6	f0 17		beq $adcf			beq 	_SSFEnd
.adb8	c5 03		cmp $03				cmp 	zTemp0+1
.adba	f0 13		beq $adcf			beq 	_SSFEnd
.adbc					_SSFFail:
.adbc	20 d0 ad	jsr $add0			jsr 	AdvanceInCode 					; skip over in code.
.adbf	b0 ed		bcs $adae			bcs 	_SSFLoop 						; if not end of program, keep going.
.adc1	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>adc4	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>adcc	45 3f 00
.adcf					_SSFEnd:
.adcf	60		rts				rts
.add0					AdvanceInCode:
.add0	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.add2	f0 28		beq $adfc			beq 	_AICEndOfLine 					; end of line.
.add4	c8		iny				iny 									; advance one.
.add5	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.add7	90 10		bcc $ade9			bcc 	_AICControl
.add9	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.addb	b0 0a		bcs $ade7			bcs 	_AICExit
.addd	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.addf	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.ade1	90 04		bcc $ade7			bcc 	_AICExit
.ade3	c6 04		dec $04				dec 	zTemp1
.ade5	c6 04		dec $04				dec 	zTemp1
.ade7					_AICExit:
.ade7	38		sec				sec
.ade8	60		rts				rts
.ade9					_AICControl:
.ade9	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.adeb	f0 0b		beq $adf8			beq 	_AICThree
.aded	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.adef	f0 07		beq $adf8			beq 	_AICThree
.adf1	98		tya				tya										; skip over a string/comment/define.
.adf2	38		sec				sec
.adf3	71 00		adc ($00),y			adc 	(codePtr),y
.adf5	a8		tay				tay
.adf6	38		sec				sec
.adf7	60		rts				rts
.adf8					_AICThree:
.adf8	c8		iny				iny
.adf9	c8		iny				iny
.adfa	38		sec				sec
.adfb	60		rts				rts
.adfc					_AICEndOfLine:
.adfc	18		clc				clc 									; forward to next line.
.adfd	b2 00		lda ($00)			lda 	(codePtr)
.adff	65 00		adc $00				adc 	codePtr
.ae01	85 00		sta $00				sta 	codePtr
.ae03	90 02		bcc $ae07			bcc 	_AICNoCarry
.ae05	e6 01		inc $01				inc 	codePtr+1
.ae07					_AICNoCarry:
.ae07	a0 03		ldy #$03			ldy 	#3 								; start of new line
.ae09	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.ae0b	d0 da		bne $ade7			bne 	_AICExit
.ae0d	18		clc				clc 									; program end.
.ae0e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.ae0f					Struct_Repeat:
.ae0f	fa		plx				plx
.ae10	20 62 a4	jsr $a462			jsr 	StackPushPosition 				; save stack position
.ae13	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.ae15	20 52 a4	jsr $a452			jsr 	StackPushByte
.ae18	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ae1b					Struct_Until:
.ae1b	fa		plx				plx
.ae1c	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.ae1e	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ae21	90 1b		bcc $ae3e			bcc 	_SUFail
.ae23	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.ae26	1d 00 07	ora $0700,x			ora 	highStack,x
.ae29	ca		dex				dex
.ae2a	09 00		ora #$00			ora 	#0
.ae2c	f0 08		beq $ae36			beq 	_SULoopBack 					; if so keep going.
.ae2e	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.ae30	20 79 a4	jsr $a479			jsr 	StackPop
.ae33	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ae36					_SULoopBack:
.ae36	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.ae38	20 7f a4	jsr $a47f			jsr 	StackRestorePosition
.ae3b	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ae3e					_SUFail:
.ae3e	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>ae41	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>ae49	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.ae4b					Struct_For:
.ae4b	fa		plx				plx
.ae4c	18		clc				clc
.ae4d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.ae50	49 ff		eor #$ff			eor 	#$FF
.ae52	69 01		adc #$01			adc 	#1
.ae54	08		php				php
.ae55	20 52 a4	jsr $a452			jsr 	StackPushByte
.ae58	bd 00 07	lda $0700,x			lda 	highStack,x
.ae5b	49 ff		eor #$ff			eor 	#$FF
.ae5d	28		plp				plp
.ae5e	69 00		adc #$00			adc 	#0
.ae60	20 52 a4	jsr $a452			jsr 	StackPushByte
.ae63	ca		dex				dex 									; throw TOS
.ae64	20 62 a4	jsr $a462			jsr 	StackPushPosition 				; save stack position
.ae67	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.ae69	20 52 a4	jsr $a452			jsr 	StackPushByte
.ae6c	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ae6f					Struct_Index:
.ae6f	fa		plx				plx
.ae70	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.ae72	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ae75	90 43		bcc $aeba			bcc 	SNFail
.ae77	e8		inx				inx 									; new stack entry
.ae78	5a		phy				phy
.ae79	a0 04		ldy #$04			ldy 	#4 								; access index value
.ae7b	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae7d	49 ff		eor #$ff			eor 	#$FF
.ae7f	9d 00 07	sta $0700,x			sta 	highStack,x
.ae82	c8		iny				iny
.ae83	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae85	49 ff		eor #$ff			eor 	#$FF
.ae87	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae8a	7a		ply				ply 									; restore code pointer
.ae8b	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.ae8e					Struct_Next:
.ae8e	fa		plx				plx
.ae8f	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.ae91	20 71 a4	jsr $a471			jsr 	StackCheckTop
.ae94	90 24		bcc $aeba			bcc 	SNFail
.ae96	5a		phy				phy 									; save code position
.ae97	a0 05		ldy #$05			ldy 	#5 								; bump the count
.ae99	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae9b	1a		inc a				inc 	a
.ae9c	91 0a		sta ($0a),y			sta 	(iStack),y
.ae9e	d0 11		bne $aeb1			bne 	_SNLoopBack
.aea0	88		dey				dey
.aea1	b1 0a		lda ($0a),y			lda 	(iStack),y
.aea3	1a		inc a				inc 	a
.aea4	91 0a		sta ($0a),y			sta 	(iStack),y
.aea6	d0 09		bne $aeb1			bne 	_SNLoopBack  					; non-zero loop back.
.aea8	7a		ply				ply 									; restore code position.
.aea9	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.aeab	20 79 a4	jsr $a479			jsr 	StackPop
.aeae	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aeb1					_SNLoopBack:
.aeb1	7a		ply				ply 									; restore code position, being junked anyway.
.aeb2	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.aeb4	20 7f a4	jsr $a47f			jsr 	StackRestorePosition
.aeb7	4c 17 a2	jmp $a217			jmp 	ExecuteLoop
.aeba					SNFail:
.aeba	20 b2 a1	jsr $a1b2			jsr 	ErrorHandler
>aebd	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
