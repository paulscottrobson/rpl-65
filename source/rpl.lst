
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Sun Jan 05 16:22:26 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$8000					BuildAddress = $8000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$7f00					HighMemory = $7F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer (must be on a page boundary)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					zTemp4:			.word ?
>000c					zTemp5:			.word ?
>000e					iStack:			.word ?						; stack pointer
>0010					signCount:		.byte ? 					; divide sign count.
>0011					allocPtr:		.word ? 					; memory allocation pointer (down)
>0013					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0015					randomSeed:		.word ? 					; random number seed
>0017					prefixCharacter:.byte ?						; char to print before listed element.
>0018					breakCount:		.byte ? 					; counter avoids repeated break checks
>0019					tokenOffset:	.byte ? 					; position in output token buffer.
>001a					assemblerMode:	.byte ? 					; in assembler mode ?
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 80	jmp $8000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	13 e8 03 03 0d 54 48 45			.byte	$13,$e8,$03,$03,$0d,$54,$48,$45,$20,$42,$41,$4c,$4c,$20,$44,$45,$4d,$4f,$00,$07,$f2,$03,$02,$ec,$04,$00,$10,$fc,$03,$01,$00,$04,$21,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$90,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$56,$04,$0b,$00,$05,$24,$04,$07,$00,$12,$2e,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$9c,$04,$0b,$00,$06,$38,$04,$80,$0a,$00,$05,$42,$04,$41,$00,$23,$4c,$04,$05,$0b,$c2,$c1,$cc,$cc,$db,$d3,$c5,$cc,$c5,$c3,$f4,$2e,$2e,$2e,$2e,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$3a,$00,$29,$56,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$31,$28,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$31,$28,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$60,$04,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$31,$87,$11,$2b,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$74,$04,$3a,$00,$1c,$6a,$04,$05,$0b,$d2,$c1,$ce,$c4,$cf,$cd,$db,$d3,$c9,$c7,$ee,$31,$81,$11,$06,$81,$38,$01,$ff,$ff,$09,$3a,$00,$0f,$74,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$7e,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2e,$01,$20,$9f,$1d,$00,$0f,$88,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$92,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$3a,$00,$0f,$9c,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$a6,$04,$a0,$02,$74,$04,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ba,$04,$34,$01,$50,$00,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ce,$04,$34,$bc,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$d8,$04,$01,$51,$00,$02,$74,$04,$00,$05,$e2,$04,$3a,$00,$15,$ec,$04,$05,$05,$c3,$cc,$c5,$c1,$f2,$80,$01,$20,$9f,$1f,$90,$01,$22,$9f,$1d,$00,$0a,$f6,$04,$01,$80,$00,$bc,$0c,$08,$00,$0e,$00,$05,$a0,$01,$23,$9f,$1d,$81,$01,$23,$9f,$1d,$00,$06,$0a,$05,$0b,$3a,$00
>1008	20 42 41 4c 4c 20 44 45 4d 4f 00 07 f2 03 02 ec
>1018	04 00 10 fc 03 01 00 04 21 22 c2 c1 cc cc cd c5
>1028	ed 00 0b 06 04 90 22 c3 cf d5 ce f4 00 0d 10 04
>1038	01 8e 00 22 e1 01 d2 ff 25 00 12 1a 04 c3 cf d5
>1048	ce f4 08 39 02 4c 04 02 56 04 0b 00 05 24 04 07
>1058	00 12 2e 04 c3 cf d5 ce f4 08 39 02 4c 04 02 9c
>1068	04 0b 00 06 38 04 80 0a 00 05 42 04 41 00 23 4c
>1078	04 05 0b c2 c1 cc cc db d3 c5 cc c5 c3 f4 2e 2e
>1088	2e 2e c2 c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 3a
>1098	00 29 56 04 05 09 c2 c1 cc cc db c9 ce c9 f4 31
>10a8	28 01 50 00 0e 22 c2 c1 cc ec 23 80 24 31 28 bc
>10b8	0e 22 c2 c1 cc ec 23 81 24 00 2d 60 04 02 6a 04
>10c8	22 c2 c1 cc ec 23 82 24 02 6a 04 22 c2 c1 cc ec
>10d8	23 83 24 31 87 11 2b 22 c2 c1 cc ec 23 84 24 01
>10e8	51 00 02 74 04 3a 00 1c 6a 04 05 0b d2 c1 ce c4
>10f8	cf cd db d3 c9 c7 ee 31 81 11 06 81 38 01 ff ff
>1108	09 3a 00 0f 74 04 05 09 c2 c1 cc cc db c4 d2 c1
>1118	f7 00 10 7e 04 c2 c1 cc ec 23 80 24 2e 01 20 9f
>1128	1d 00 0f 88 04 c2 c1 cc ec 23 81 24 01 21 9f 1d
>1138	00 19 92 04 90 01 22 9f 1d 01 23 9f 1d c2 c1 cc
>1148	ec 23 84 24 01 23 9f 1d 3a 00 0f 9c 04 05 09 c2
>1158	c1 cc cc db cd cf d6 e5 00 08 a6 04 a0 02 74 04
>1168	00 1c b0 04 c2 c1 cc ec 23 80 24 c2 c1 cc ec 23
>1178	82 24 0f 34 22 c2 c1 cc ec 23 80 24 00 1f ba 04
>1188	34 01 50 00 1a 37 80 19 12 06 c2 c1 cc ec 23 82
>1198	24 29 22 c2 c1 cc ec 23 82 24 09 00 1c c4 04 c2
>11a8	c1 cc ec 23 81 24 c2 c1 cc ec 23 83 24 0f 34 22
>11b8	c2 c1 cc ec 23 81 24 00 1d ce 04 34 bc 1a 37 80
>11c8	19 12 06 c2 c1 cc ec 23 83 24 29 22 c2 c1 cc ec
>11d8	23 83 24 09 00 0a d8 04 01 51 00 02 74 04 00 05
>11e8	e2 04 3a 00 15 ec 04 05 05 c3 cc c5 c1 f2 80 01
>11f8	20 9f 1f 90 01 22 9f 1d 00 0a f6 04 01 80 00 bc
>1208	0c 08 00 0e 00 05 a0 01 23 9f 1d 81 01 23 9f 1d
>1218	00 06 0a 05 0b 3a 00

;******  Return to file: main.asm

.8000					Start:
.8000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.8002	9a		txs				txs
.8003	20 c8 85	jsr $85c8			jsr 	ExternInitialise			; set up external stuff.
.8006	a2 60		ldx #$60			ldx 	#BootPrompt & $FF 			; print start up.
.8008	a0 80		ldy #$80			ldy 	#BootPrompt >> 8
.800a	20 d3 84	jsr $84d3			jsr 	PrintStringXY
.800d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.800f	a0 6f		ldy #$6f			ldy 	#(HighMemory-ProgramStart) >> 8
.8011	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.8014	a2 7d		ldx #$7d			ldx 	#BootPrompt2 & $FF
.8016	a0 80		ldy #$80			ldy 	#BootPrompt2 >> 8
.8018	20 d3 84	jsr $84d3			jsr 	PrintStringXY
.801b					WarmStart:
.801b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.801d	9a		txs				txs
.801e	20 22 86	jsr $8622			jsr 	ExternInput					; input a line.
.8021	48		pha				pha
.8022	20 44 8a	jsr $8a44			jsr 	TokeniseInputBuffer 		; tokenise it
.8025	68		pla				pla
.8026	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.8028	f0 0d		beq $8037			beq 	ExecuteLine
.802a	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.802d	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.802f	f0 0d		beq $803e			beq 	LineNumber
.8031	29 c0		and #$c0			and 	#$C0
.8033	c9 80		cmp #$80			cmp 	#$80
.8035	f0 07		beq $803e			beq 	LineNumber
.8037					ExecuteLine:
.8037	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.8039	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.803b	4c f2 84	jmp $84f2			jmp 	ExecuteFromXY
.803e					LineNumber:
.803e	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.8041	a2 00		ldx #$00			ldx 	#0
.8043	a0 04		ldy #$04			ldy 	#4
.8045	38		sec				sec
.8046	e9 80		sbc #$80			sbc 	#$80
.8048	c9 40		cmp #$40			cmp 	#$40
.804a	90 08		bcc $8054			bcc 	_HaveLineNumber
.804c	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.804f	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.8052	a0 06		ldy #$06			ldy 	#6
.8054					_HaveLineNumber:
.8054	48		pha				pha 								; a fudge. Because you use
.8055	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.8058	c9 3c		cmp #$3c			cmp 	#KWD_LIST 					; this to be executed and not
.805a	f0 db		beq $8037			beq 	ExecuteLine 				; to be code.
.805c	68		pla				pla
.805d	4c 17 87	jmp $8717			jmp 	EditProgram
.8060					BootPrompt:
>8060	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (19-NOV-19) ***",13,13
>8068	36 35 20 28 31 39 2d 4e 4f 56 2d 31 39 29 20 2a
>8078	2a 2a 0d 0d
>807c	00						.byte 	0
.807d					BootPrompt2:
>807d	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>8085	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_HASH                       = $0027 ; #
=$0028					KWD_ABS                        = $0028 ; abs
=$0029					KWD_NEGATE                     = $0029 ; negate
=$002a					KWD_NOT                        = $002a ; not
=$002b					KWD_PLUSPLUS                   = $002b ; ++
=$002c					KWD_MINUSMINUS                 = $002c ; --
=$002d					KWD_BSWAP                      = $002d ; bswap
=$002e					KWD_LESSLESS                   = $002e ; <<
=$002f					KWD_GREATERGREATER             = $002f ; >>
=$0030					KWD_SGN                        = $0030 ; sgn
=$0031					KWD_RND                        = $0031 ; rnd
=$0032					KWD_CLR                        = $0032 ; clr
=$0033					KWD_DROP                       = $0033 ; drop
=$0034					KWD_DUP                        = $0034 ; dup
=$0035					KWD_NIP                        = $0035 ; nip
=$0036					KWD_OVER                       = $0036 ; over
=$0037					KWD_SWAP                       = $0037 ; swap
=$0038					KWD_ELSE                       = $0038 ; else
=$0039					KWD_INDEX                      = $0039 ; index
=$003a					KWD_SEMICOLON                  = $003a ; ;
=$003b					KWD_ASSERT                     = $003b ; assert
=$003c					KWD_LIST                       = $003c ; list
=$003d					KWD_NEW                        = $003d ; new
=$003e					KWD_OLD                        = $003e ; old
=$003f					KWD_STOP                       = $003f ; stop
=$0040					KWD_RUN                        = $0040 ; run
=$0041					KWD_END                        = $0041 ; end
=$0042					KWD_SAVE                       = $0042 ; save
=$0043					KWD_LOAD                       = $0043 ; load
.8091					KeywordText:
>8091	01 ff					.text $01,$ff                          ; $0000 %eol
>8093	01 ff					.text $01,$ff                          ; $0001 %const
>8095	01 ff					.text $01,$ff                          ; $0002 %call
>8097	01 ff					.text $01,$ff                          ; $0003 %comment
>8099	01 ff					.text $01,$ff                          ; $0004 %qstring
>809b	01 ff					.text $01,$ff                          ; $0005 %define
>809d	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>80a0	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>80a7	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>80ab	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>80b1	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>80b7	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>80bc	01 aa					.text $01,$aa                          ; $000c *
>80be	01 af					.text $01,$af                          ; $000d /
>80c0	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>80c4	01 ab					.text $01,$ab                          ; $000f +
>80c6	01 ad					.text $01,$ad                          ; $0010 -
>80c8	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>80cc	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>80cf	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>80d3	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>80d7	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>80db	01 bd					.text $01,$bd                          ; $0016 =
>80dd	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>80e0	01 be					.text $01,$be                          ; $0018 >
>80e2	01 bc					.text $01,$bc                          ; $0019 <
>80e4	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>80e7	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>80ea	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>80ed	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>80f0	01 c0					.text $01,$c0                          ; $001e @
>80f2	01 a1					.text $01,$a1                          ; $001f !
>80f4	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>80f7	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>80fd	01 de					.text $01,$de                          ; $0022 ^
>80ff	01 db					.text $01,$db                          ; $0023 [
>8101	01 dd					.text $01,$dd                          ; $0024 ]
>8103	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>8107	01 bf					.text $01,$bf                          ; $0026 ?
>8109	01 a3					.text $01,$a3                          ; $0027 #
>810b	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0028 abs
>810f	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0029 negate
>8116	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $002a not
>811a	02 2b ab				.text $02,$2b,$ab                      ; $002b ++
>811d	02 2d ad				.text $02,$2d,$ad                      ; $002c --
>8120	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002d bswap
>8126	02 3c bc				.text $02,$3c,$bc                      ; $002e <<
>8129	02 3e be				.text $02,$3e,$be                      ; $002f >>
>812c	03 53 47 ce				.text $03,$53,$47,$ce                  ; $0030 sgn
>8130	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0031 rnd
>8134	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0032 clr
>8138	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0033 drop
>813d	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0034 dup
>8141	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0035 nip
>8145	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0036 over
>814a	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0037 swap
>814f	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0038 else
>8154	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0039 index
>815a	01 bb					.text $01,$bb                          ; $003a ;
>815c	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003b assert
>8163	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003c list
>8168	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003d new
>816c	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003e old
>8170	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003f stop
>8175	03 52 55 ce				.text $03,$52,$55,$ce                  ; $0040 run
>8179	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0041 end
>817d	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0042 save
>8182	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0043 load
>8187	00					.byte 0
>8188						.align 2
.8188					DispatchHandler:
>8188	68 85					.word ExecuteNextLine          ; $0000 %eol
>818a	9f 85					.word LongConstant             ; $0001 %const
>818c	98 93					.word Command_Call             ; $0002 %call
>818e	68 85					.word ExecuteComment           ; $0003 %comment
>8190	b0 85					.word StringConstant           ; $0004 %qstring
>8192	90 84					.word SyntaxError              ; $0005 %define
>8194	0e 94					.word Structure_If             ; $0006 if
>8196	c2 94					.word Struct_Repeat            ; $0007 repeat
>8198	fe 94					.word Struct_For               ; $0008 for
>819a	4b 94					.word Structure_Endif          ; $0009 endif
>819c	ce 94					.word Struct_Until             ; $000a until
>819e	41 95					.word Struct_Next              ; $000b next
>81a0	9c 92					.word MulInteger16             ; $000c *
>81a2	1a 92					.word DivInteger16             ; $000d /
>81a4	8b 92					.word ModInteger16             ; $000e mod
>81a6	06 91					.word Stack_Add                ; $000f +
>81a8	1e 91					.word Stack_Sub                ; $0010 -
>81aa	36 91					.word Stack_And                ; $0011 and
>81ac	64 91					.word Stack_Or                 ; $0012 or
>81ae	4d 91					.word Stack_Xor                ; $0013 xor
>81b0	7b 91					.word Stack_Shl                ; $0014 shl
>81b2	7f 91					.word Stack_Shr                ; $0015 shr
>81b4	b0 91					.word Comp_Equal               ; $0016 =
>81b6	b4 91					.word Comp_NotEqual            ; $0017 <>
>81b8	fd 91					.word Comp_Greater             ; $0018 >
>81ba	d8 91					.word Comp_Less                ; $0019 <
>81bc	dc 91					.word Comp_GreaterEqual        ; $001a >=
>81be	f9 91					.word Comp_LessEqual           ; $001b <=
>81c0	70 8e					.word Mem_Peek                 ; $001c c@
>81c2	a2 8e					.word Mem_Poke                 ; $001d c!
>81c4	86 8e					.word Mem_WPeek                ; $001e @
>81c6	b7 8e					.word Mem_WPoke                ; $001f !
>81c8	d5 8e					.word Mem_DWPoke               ; $0020 d!
>81ca	ef 8e					.word Mem_Alloc                ; $0021 alloc
>81cc	0c 90					.word Command_Store            ; $0022 ^
>81ce	91 85					.word CommandAssemblerOn       ; $0023 [
>81d0	99 85					.word CommandAssemblerOff      ; $0024 ]
>81d2	9d 90					.word Command_Sys              ; $0025 sys
>81d4	bf 90					.word Command_DumpStack        ; $0026 ?
>81d6	90 84					.word SyntaxError              ; $0027 #
>81d8	da 92					.word Unary_Absolute           ; $0028 abs
>81da	e3 92					.word Unary_Negate             ; $0029 negate
>81dc	f8 92					.word Unary_Not                ; $002a not
>81de	0c 93					.word Unary_Increment          ; $002b ++
>81e0	18 93					.word Unary_Decrement          ; $002c --
>81e2	27 93					.word Unary_BSwap              ; $002d bswap
>81e4	39 93					.word Unary_Shl                ; $002e <<
>81e6	43 93					.word Unary_Shr                ; $002f >>
>81e8	4d 93					.word Unary_Sgn                ; $0030 sgn
>81ea	70 93					.word Random_Handler           ; $0031 rnd
>81ec	ac 8f					.word Stack_Empty              ; $0032 clr
>81ee	b2 8f					.word Stack_Drop               ; $0033 drop
>81f0	b7 8f					.word Stack_Dup                ; $0034 dup
>81f2	c8 8f					.word Stack_Nip                ; $0035 nip
>81f4	d9 8f					.word Stack_Over               ; $0036 over
>81f6	ea 8f					.word Stack_Swap               ; $0037 swap
>81f8	31 94					.word Structure_Else           ; $0038 else
>81fa	22 95					.word Struct_Index             ; $0039 index
>81fc	ee 93					.word Command_Return           ; $003a ;
>81fe	86 90					.word Command_Assert           ; $003b assert
>8200	81 8c					.word Cmd_List                 ; $003c list
>8202	4b 90					.word Command_New              ; $003d new
>8204	52 90					.word Command_Old              ; $003e old
>8206	7c 90					.word Command_Stop             ; $003f stop
>8208	ee 84					.word ExecuteProgram           ; $0040 run
>820a	78 90					.word Command_End              ; $0041 end
>820c	1d 8f					.word System_Save              ; $0042 save
>820e	38 8f					.word System_Load              ; $0043 load

;******  Return to file: main.asm


;******  Processing file: generated/assembler.inc

=2					ASM_FIRST_2BYTE = 2
=10					ASM_FIRST_3BYTE = 10
=0					ASM_MODE_IMP = 0
=1					ASM_MODE_A = 1
=2					ASM_MODE_IMM = 2
=3					ASM_MODE_RL = 3
=4					ASM_MODE_ZP = 4
=5					ASM_MODE_ZX = 5
=6					ASM_MODE_ZY = 6
=7					ASM_MODE_IX = 7
=8					ASM_MODE_IY = 8
=9					ASM_MODE_IN = 9
=10					ASM_MODE_AB = 10
=11					ASM_MODE_AX = 11
=12					ASM_MODE_AY = 12
=13					ASM_MODE_IA = 13
=14					ASM_MODE_IAX = 14
.8210					LowBytes:
>8210	2b 21 00 00 42 21 4c 00			.byte $2b,$21,$00,$00,$42,$21,$4c,$00,$f0,$21,$4c,$00,$42,$21,$4c,$00,$ec,$21,$21,$00,$22,$21,$4c,$00,$63,$21,$a3,$00,$22,$21,$4c,$00,$52,$a4,$00,$00,$14,$a4,$cc,$00,$70,$a4,$cc,$00,$14,$a4,$cc,$00,$89,$a4,$a4,$00,$14,$a4,$cc,$00,$83,$a4,$83,$00,$14,$a4,$cc,$00,$69,$d2,$00,$00,$00,$d2,$52,$00,$e1,$d2,$52,$00,$90,$d2,$52,$00,$a3,$d2,$d2,$00,$00,$d2,$52,$00,$69,$d2,$f9,$00,$00,$d2,$52,$00,$73,$63,$00,$00,$7a,$63,$d2,$00,$61,$63,$d2,$00,$90,$63,$d2,$00,$b3,$63,$63,$00,$7a,$63,$d2,$00,$89,$63,$79,$00,$90,$63,$d2,$00,$21,$61,$00,$00,$79,$61,$78,$00,$99,$14,$e1,$00,$79,$61,$78,$00,$43,$61,$61,$00,$79,$61,$78,$00,$01,$61,$f3,$00,$7a,$61,$7a,$00,$79,$61,$78,$00,$79,$61,$78,$00,$19,$61,$18,$00,$79,$61,$78,$00,$53,$61,$61,$00,$79,$61,$78,$00,$76,$61,$58,$00,$79,$61,$78,$00,$f9,$90,$00,$00,$f9,$90,$83,$00,$b9,$90,$98,$00,$f9,$90,$83,$00,$a5,$90,$90,$00,$00,$90,$83,$00,$64,$90,$f8,$00,$00,$90,$83,$00,$f8,$23,$00,$00,$f8,$23,$a3,$00,$b8,$23,$d0,$00,$f8,$23,$a3,$00,$91,$23,$23,$00,$00,$23,$a3,$00,$84,$23,$78,$00,$00,$23,$a3,$00
>8218	f0 21 4c 00 42 21 4c 00 ec 21 21 00 22 21 4c 00
>8228	63 21 a3 00 22 21 4c 00 52 a4 00 00 14 a4 cc 00
>8238	70 a4 cc 00 14 a4 cc 00 89 a4 a4 00 14 a4 cc 00
>8248	83 a4 83 00 14 a4 cc 00 69 d2 00 00 00 d2 52 00
>8258	e1 d2 52 00 90 d2 52 00 a3 d2 d2 00 00 d2 52 00
>8268	69 d2 f9 00 00 d2 52 00 73 63 00 00 7a 63 d2 00
>8278	61 63 d2 00 90 63 d2 00 b3 63 63 00 7a 63 d2 00
>8288	89 63 79 00 90 63 d2 00 21 61 00 00 79 61 78 00
>8298	99 14 e1 00 79 61 78 00 43 61 61 00 79 61 78 00
>82a8	01 61 f3 00 7a 61 7a 00 79 61 78 00 79 61 78 00
>82b8	19 61 18 00 79 61 78 00 53 61 61 00 79 61 78 00
>82c8	76 61 58 00 79 61 78 00 f9 90 00 00 f9 90 83 00
>82d8	b9 90 98 00 f9 90 83 00 a5 90 90 00 00 90 83 00
>82e8	64 90 f8 00 00 90 83 00 f8 23 00 00 f8 23 a3 00
>82f8	b8 23 d0 00 f8 23 a3 00 91 23 23 00 00 23 a3 00
>8308	84 23 78 00 00 23 a3 00
.8310					HighBytes:
>8310	0b 3f 00 00 53 3f 07 00			.byte $0b,$3f,$00,$00,$53,$3f,$07,$00,$41,$3f,$07,$00,$53,$3f,$07,$00,$0a,$3f,$3f,$00,$53,$3f,$07,$00,$0e,$3f,$26,$00,$53,$3f,$07,$00,$2b,$06,$00,$00,$0a,$06,$4a,$00,$42,$06,$4a,$00,$0a,$06,$4a,$00,$0a,$06,$06,$00,$0a,$06,$4a,$00,$4d,$06,$11,$00,$0a,$06,$4a,$00,$4b,$16,$00,$00,$00,$16,$33,$00,$41,$16,$33,$00,$2a,$16,$33,$00,$0b,$16,$16,$00,$00,$16,$33,$00,$0e,$16,$41,$00,$00,$16,$33,$00,$4b,$05,$00,$00,$4f,$05,$4a,$00,$42,$05,$4a,$00,$2a,$05,$4a,$00,$0b,$05,$05,$00,$4f,$05,$4a,$00,$4d,$05,$42,$00,$2a,$05,$4a,$00,$0b,$4f,$00,$00,$4f,$4f,$4f,$00,$11,$0a,$53,$00,$4f,$4f,$4f,$00,$09,$4f,$4f,$00,$4f,$4f,$4f,$00,$54,$4f,$53,$00,$4f,$4f,$4f,$00,$31,$31,$31,$00,$31,$31,$31,$00,$51,$31,$51,$00,$31,$31,$31,$00,$09,$31,$31,$00,$31,$31,$31,$00,$0e,$31,$53,$00,$31,$31,$31,$00,$0e,$0e,$00,$00,$0e,$0e,$11,$00,$26,$0e,$11,$00,$0e,$0e,$11,$00,$0a,$0e,$0e,$00,$00,$0e,$11,$00,$0e,$0e,$41,$00,$00,$0e,$11,$00,$0e,$4d,$00,$00,$0e,$4d,$26,$00,$26,$4d,$3a,$00,$0e,$4d,$26,$00,$09,$4d,$4d,$00,$00,$4d,$26,$00,$4d,$4d,$42,$00,$00,$4d,$26,$00
>8318	41 3f 07 00 53 3f 07 00 0a 3f 3f 00 53 3f 07 00
>8328	0e 3f 26 00 53 3f 07 00 2b 06 00 00 0a 06 4a 00
>8338	42 06 4a 00 0a 06 4a 00 0a 06 06 00 0a 06 4a 00
>8348	4d 06 11 00 0a 06 4a 00 4b 16 00 00 00 16 33 00
>8358	41 16 33 00 2a 16 33 00 0b 16 16 00 00 16 33 00
>8368	0e 16 41 00 00 16 33 00 4b 05 00 00 4f 05 4a 00
>8378	42 05 4a 00 2a 05 4a 00 0b 05 05 00 4f 05 4a 00
>8388	4d 05 42 00 2a 05 4a 00 0b 4f 00 00 4f 4f 4f 00
>8398	11 0a 53 00 4f 4f 4f 00 09 4f 4f 00 4f 4f 4f 00
>83a8	54 4f 53 00 4f 4f 4f 00 31 31 31 00 31 31 31 00
>83b8	51 31 51 00 31 31 31 00 09 31 31 00 31 31 31 00
>83c8	0e 31 53 00 31 31 31 00 0e 0e 00 00 0e 0e 11 00
>83d8	26 0e 11 00 0e 0e 11 00 0a 0e 0e 00 00 0e 11 00
>83e8	0e 0e 41 00 00 0e 11 00 0e 4d 00 00 0e 4d 26 00
>83f8	26 4d 3a 00 0e 4d 26 00 09 4d 4d 00 00 4d 26 00
>8408	4d 4d 42 00 00 4d 26 00
.8410					ModeNibbles:
>8410	07 ff 44 4f 02 1f aa af			.byte $07,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$45,$5f,$0c,$1f,$ab,$bf,$17,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$55,$5f,$0c,$1f,$bb,$bf,$07,$ff,$f4,$4f,$02,$1f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$07,$ff,$44,$4f,$02,$1f,$da,$af,$38,$9f,$55,$5f,$0c,$0f,$eb,$bf,$37,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$ab,$bf,$27,$2f,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$bb,$cf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf
>8418	38 9f 45 5f 0c 1f ab bf 17 ff 44 4f 02 1f aa af
>8428	38 9f 55 5f 0c 1f bb bf 07 ff f4 4f 02 1f aa af
>8438	38 9f f5 5f 0c 0f fb bf 07 ff 44 4f 02 1f da af
>8448	38 9f 55 5f 0c 0f eb bf 37 ff 44 4f 02 0f aa af
>8458	38 9f 55 6f 0c 0f ab bf 27 2f 44 4f 02 0f aa af
>8468	38 9f 55 6f 0c 0f bb cf 27 ff 44 4f 02 0f aa af
>8478	38 9f f5 5f 0c 0f fb bf 27 ff 44 4f 02 0f aa af
>8488	38 9f f5 5f 0c 0f fb bf

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.8490					SyntaxError:
.8490	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8493	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.849a					ErrorHandler:
.849a	fa		plx				plx 								; pull address off.
.849b	7a		ply				ply
.849c	e8		inx				inx 								; point to message
.849d	d0 01		bne $84a0			bne 	_EHNoCarry
.849f	c8		iny				iny
.84a0					_EHNoCarry:
.84a0	20 d3 84	jsr $84d3			jsr 	PrintStringXY 				; print string at XY
.84a3	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.84a5	f0 13		beq $84ba			beq 	_EHNoLine
.84a7	a2 c2		ldx #$c2			ldx 	#_EHMessage & $FF 			; print " AT "
.84a9	a0 84		ldy #$84			ldy 	#_EHMessage >> 8
.84ab	20 d3 84	jsr $84d3			jsr 	PrintStringXY
.84ae	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.84b0	b1 00		lda ($00),y			lda 	(codePtr),y
.84b2	aa		tax				tax
.84b3	c8		iny				iny
.84b4	b1 00		lda ($00),y			lda 	(codePtr),y
.84b6	a8		tay				tay
.84b7	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.84ba					_EHNoLine:
.84ba	a9 0d		lda #$0d			lda 	#13
.84bc	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.84bf	4c 1b 80	jmp $801b			jmp 	WarmStart
.84c2					_EHMessage:
>84c2	20 41 54 20 00					.text	" AT ",0
.84c7					PrintIntegerUnsigned:
.84c7	20 ff 88	jsr $88ff			jsr 	IntToString
.84ca	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.84cc	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.84ce	20 d3 84	jsr $84d3			jsr 	PrintStringXY
.84d1	98		tya				tya
.84d2	60		rts				rts
.84d3					PrintStringXY:
.84d3	86 02		stx $02				stx 	zTemp0
.84d5	84 03		sty $03				sty 	zTemp0+1
.84d7	a0 00		ldy #$00			ldy 	#0
.84d9	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.84db	f0 06		beq $84e3			beq 	_PSExit
.84dd	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.84e0	c8		iny				iny
.84e1	80 f6		bra $84d9			bra 	_PSLoop
.84e3	60		rts		_PSExit:rts
.84e4					PrintCharacter:
.84e4	48		pha				pha
.84e5	da		phx				phx
.84e6	5a		phy				phy
.84e7	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.84ea	7a		ply				ply
.84eb	fa		plx				plx
.84ec	68		pla				pla
.84ed	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.84ee					ExecuteProgram:
.84ee	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.84f0	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.84f2					ExecuteFromXY:
.84f2	20 f6 87	jsr $87f6			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.84f5	20 32 88	jsr $8832			jsr 	StackReset 					; reset the CPU stack.
.84f8	64 1a		stz $1a				stz 	assemblerMode 				; not in assembler mode.
.84fa	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.84fc	80 0a		bra $8508			bra 	ExecuteLoop
.84fe					ShortConstant:
.84fe	c8		iny				iny 								; skip short const
.84ff	e8		inx				inx 								; space on stack
.8500	29 3f		and #$3f			and 	#$3F 						; the value
.8502	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.8505	9e 00 07	stz $0700,x			stz 	highStack,x
.8508					ExecuteLoop:
.8508	e6 18		inc $18				inc 	breakCount 					; check break sometimes.
.850a	d0 03		bne $850f			bne 	_EXNoBreak
.850c	20 e1 85	jsr $85e1			jsr 	ExternCheckBreak
.850f					_EXNoBreak:
.850f	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.8511	f0 4b		beq $855e			beq 	_ELUnderflow
.8513	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.8515	30 07		bmi $851e			bmi 	_ELNotToken
.8517	c8		iny				iny 								; skip the token
.8518	da		phx				phx 								; save X on the stack
.8519	0a		asl a				asl 	a 							; double the token, put into X
.851a	aa		tax				tax
.851b	7c 88 81	jmp ($8188,x)			jmp 	(DispatchHandler,x)
.851e					_ELNotToken:
.851e	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.8520	90 dc		bcc $84fe			bcc 	ShortConstant 				; yes, it's a short constant
.8522	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.8524	90 1e		bcc $8544			bcc 	_ELNotFastVariable
.8526	c8		iny				iny 								; get the next token.
.8527	b1 00		lda ($00),y			lda 	(codePtr),y
.8529	88		dey				dey
.852a	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.852c	f0 16		beq $8544			beq 	_ELNotFastVariable 			; which we can optimise.
.852e	5a		phy				phy 								; save Y
.852f	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.8531	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.8532	a8		tay				tay 								; access via Y
.8533	e8		inx				inx 								; make space on the stack.
.8534	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.8537	9d 00 06	sta $0600,x			sta 	lowStack,x
.853a	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.853d	9d 00 07	sta $0700,x			sta 	highStack,x
.8540	7a		ply				ply 								; restore code pointer
.8541	c8		iny				iny 								; skip variable.
.8542	80 c4		bra $8508			bra 	ExecuteLoop
.8544					_ELNotFastVariable:
.8544	18		clc				clc									; do not autocreate if not found.
.8545	20 4a 89	jsr $894a			jsr 	VariableFind				; find the variable.
.8548	90 34		bcc $857e			bcc 	ELUnknown
.854a	20 bd 86	jsr $86bd			jsr 	IndexCheck
.854d	5a		phy				phy 								; copy to stack
.854e	e8		inx				inx
.854f	b2 02		lda ($02)			lda 	(zTemp0)
.8551	9d 00 06	sta $0600,x			sta 	lowStack,x
.8554	a0 01		ldy #$01			ldy 	#1
.8556	b1 02		lda ($02),y			lda 	(zTemp0),y
.8558	9d 00 07	sta $0700,x			sta 	highStack,x
.855b	7a		ply				ply
.855c	80 aa		bra $8508			bra 	ExecuteLoop
.855e					_ELUnderflow:
.855e	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8561	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.8568					ExecuteNextLine:
.8568					ExecuteComment:
.8568	fa		plx				plx
.8569	18		clc				clc 								; skip forward
.856a	b2 00		lda ($00)			lda 	(codePtr)
.856c	18		clc				clc
.856d	65 00		adc $00				adc 	codePtr
.856f	85 00		sta $00				sta 	codePtr
.8571	90 02		bcc $8575			bcc 	_ENLNoCarry
.8573	e6 01		inc $01				inc 	codePtr+1
.8575					_ENLNoCarry:
.8575	a0 03		ldy #$03			ldy 	#3 							; start of next line
.8577	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.8579	d0 8d		bne $8508			bne 	ExecuteLoop
.857b	4c 78 90	jmp $9078			jmp	 	Command_End 				; if zero end program.
.857e					ELUnknown:
.857e	a5 1a		lda $1a				lda 	assemblerMode 				; error if not in assembler mode.
.8580	d0 0c		bne $858e			bne 	_ELCheckAssembler
.8582					_ELUnknown:
.8582	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8585	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>858d	00
.858e					_ELCheckAssembler:
>858e	ff						.byte 	$FF
.858f	80 f1		bra $8582			bra 	_ELUnknown
.8591					CommandAssemblerOn:
.8591	fa		plx				plx
.8592	a9 01		lda #$01			lda 	#1
.8594	85 1a		sta $1a				sta 	assemblerMode
.8596	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8599					CommandAssemblerOff:
.8599	fa		plx				plx
.859a	64 1a		stz $1a				stz 	assemblerMode
.859c	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.859f					LongConstant:
.859f	fa		plx				plx
.85a0	e8		inx				inx 								; space for constant
.85a1	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.85a3	9d 00 06	sta $0600,x			sta 	lowStack,x
.85a6	c8		iny				iny
.85a7	b1 00		lda ($00),y			lda 	(codePtr),y
.85a9	9d 00 07	sta $0700,x			sta 	highStack,x
.85ac	c8		iny				iny
.85ad	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.85b0					StringConstant:
.85b0	fa		plx				plx
.85b1	e8		inx				inx
.85b2	18		clc				clc 								; copy Y + codePtr in.
.85b3	98		tya				tya
.85b4	65 00		adc $00				adc 	codePtr
.85b6	9d 00 06	sta $0600,x			sta 	lowStack,x
.85b9	a5 01		lda $01				lda 	codePtr+1
.85bb	69 00		adc #$00			adc 	#0
.85bd	9d 00 07	sta $0700,x			sta 	highStack,x
.85c0	98		tya				tya 								; add 1 + length to Y
.85c1	38		sec				sec
.85c2	71 00		adc ($00),y			adc 	(codePtr),y
.85c4	a8		tay				tay
.85c5	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.85c8					ExternInitialise:
.85c8	a9 90		lda #$90			lda 	#144 						; set colour
.85ca	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85cd	a9 01		lda #$01			lda 	#$01
.85cf	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85d2	a9 0e		lda #$0e			lda 	#14							; lower case
.85d4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85d7	a9 93		lda #$93			lda 	#147 						; clear screen
.85d9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85dc	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.85de	4c ff 85	jmp $85ff			jmp 	ExternColour
.85e1					ExternCheckBreak:
.85e1	da		phx				phx 								; make sure we keep XY
.85e2	5a		phy				phy
.85e3	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.85e6	f0 03		beq $85eb			beq		_ECBExit 					; stopped
.85e8	7a		ply				ply 								; restore and exit.
.85e9	fa		plx				plx
.85ea	60		rts				rts
.85eb					_ECBExit:
.85eb	20 9a 84	jsr $849a			jsr 	ErrorHandler
>85ee	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.85f5					ExternPrint:
.85f5	48		pha				pha
.85f6	da		phx				phx
.85f7	5a		phy				phy
.85f8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85fb	7a		ply				ply
.85fc	fa		plx				plx
.85fd	68		pla				pla
.85fe	60		rts				rts
.85ff					ExternColour:
.85ff	48		pha				pha
.8600	da		phx				phx
.8601	48		pha				pha
.8602	29 08		and #$08			and 	#8
.8604	0a		asl a				asl 	a
.8605	0a		asl a				asl 	a
.8606	0a		asl a				asl 	a
.8607	0a		asl a				asl 	a
.8608	49 92		eor #$92			eor 	#$92
.860a	20 f5 85	jsr $85f5			jsr 	ExternPrint
.860d	68		pla				pla
.860e	29 07		and #$07			and 	#7
.8610	aa		tax				tax
.8611	bd 1a 86	lda $861a,x			lda 	_ECTable,x
.8614	20 f5 85	jsr $85f5			jsr 	ExternPrint
.8617	fa		plx				plx
.8618	68		pla				pla
.8619	60		rts				rts
.861a					_ECTable:
>861a	90						.byte 	144
>861b	1c						.byte 	28
>861c	1e						.byte 	30
>861d	9e						.byte 	158
>861e	1f						.byte 	31
>861f	9c						.byte 	156
>8620	9f						.byte 	159
>8621	05						.byte 	5
.8622					ExternInput:
.8622	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.8624	85 02		sta $02				sta 	zTemp0
.8626	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.8628	85 03		sta $03				sta 	zTemp0+1
.862a	a9 07		lda #$07			lda 	#COL_WHITE
.862c	20 ff 85	jsr $85ff			jsr 	ExternColour
.862f	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.8632	29 7f		and #$7f			and 	#$7F
.8634	c9 0d		cmp #$0d			cmp 	#13
.8636	f0 0a		beq $8642			beq 	_EIExit
.8638	92 02		sta ($02)			sta 	(zTemp0)
.863a	e6 02		inc $02				inc 	zTemp0
.863c	d0 f1		bne $862f			bne 	_EIRead
.863e	e6 03		inc $03				inc 	zTemp0+1
.8640	80 ed		bra $862f			bra 	_EIRead
.8642	a9 00		lda #$00	_EIExit:lda 	#0
.8644	92 02		sta ($02)			sta 	(zTemp0)
.8646	a9 0d		lda #$0d			lda 	#13
.8648	20 f5 85	jsr $85f5			jsr 	ExternPrint
.864b	60		rts				rts
.864c					ExternSave:
.864c	da		phx				phx
.864d	5a		phy				phy
.864e	85 06		sta $06				sta 	zTemp2 						; save start
.8650	84 07		sty $07				sty 	zTemp2+1
.8652	20 b4 86	jsr $86b4			jsr 	EXGetLength 				; get length of file into A
.8655	a6 02		ldx $02				ldx 	zTemp0
.8657	a4 03		ldy $03				ldy 	zTemp0+1
.8659	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.865c	a9 01		lda #$01			lda 	#1
.865e	a2 08		ldx #$08			ldx 	#8	 						; device #8
.8660	a0 00		ldy #$00			ldy 	#0
.8662	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.8665	a6 04		ldx $04				ldx 	zTemp1 						; end address
.8667	a4 05		ldy $05				ldy 	zTemp1+1
.8669	a9 06		lda #$06			lda 	#zTemp2
.866b	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.866e	b0 03		bcs $8673			bcs 	_ESSave
.8670	7a		ply				ply
.8671	fa		plx				plx
.8672	60		rts				rts
.8673					_ESSave:
.8673	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8676	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>867e	4c 45 44 00
.8682					ExternLoad:
.8682	da		phx				phx 								; save XY
.8683	5a		phy				phy
.8684	48		pha				pha 								; save target
.8685	5a		phy				phy
.8686	20 b4 86	jsr $86b4			jsr 	EXGetLength 				; get length of file into A
.8689	a6 02		ldx $02				ldx 	zTemp0
.868b	a4 03		ldy $03				ldy 	zTemp0+1
.868d	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.8690	a9 01		lda #$01			lda 	#1
.8692	a2 08		ldx #$08			ldx 	#8	 						; device #8
.8694	a0 00		ldy #$00			ldy 	#0
.8696	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.8699	7a		ply				ply 								; restore target to YX and call load
.869a	fa		plx				plx
.869b	a9 00		lda #$00			lda 	#0 							; load command
.869d	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.86a0	b0 03		bcs $86a5			bcs 	_ESLoad
.86a2	7a		ply				ply
.86a3	fa		plx				plx
.86a4	60		rts				rts
.86a5					_ESLoad:
.86a5	20 9a 84	jsr $849a			jsr 	ErrorHandler
>86a8	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>86b0	4c 45 44 00
.86b4					EXGetLength:
.86b4	b2 02		lda ($02)			lda 	(zTemp0) 					; get name length
.86b6	e6 02		inc $02				inc 	zTemp0 						; bump ptr past it
.86b8	d0 02		bne $86bc			bne 	_EXGLExit
.86ba	e6 03		inc $03				inc 	zTemp0+1
.86bc					_EXGLExit:
.86bc	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.86bd					IndexCheck:
.86bd	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.86bf	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.86c1	f0 01		beq $86c4			beq 	_ICFound
.86c3	60		rts				rts
.86c4					_ICFound:
.86c4	c8		iny				iny 							; get next
.86c5	b1 00		lda ($00),y			lda 	(codePtr),y
.86c7	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.86c9	f0 2b		beq $86f6			beq 	_ICStackIndex
.86cb	38		sec				sec
.86cc	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.86ce	c9 40		cmp #$40			cmp 	#$40
.86d0	b0 1a		bcs $86ec			bcs 	_ICError
.86d2	0a		asl a				asl 	a 						; double index clear carry
.86d3	5a		phy				phy 							; put into Y
.86d4	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.86d6	48		pha				pha
.86d7	a0 01		ldy #$01			ldy 	#1
.86d9	b1 02		lda ($02),y			lda 	(zTemp0),y
.86db	69 00		adc #$00			adc 	#0
.86dd	85 03		sta $03				sta 	zTemp0+1
.86df	68		pla				pla
.86e0	85 02		sta $02				sta 	zTemp0
.86e2	7a		ply				ply 							; restore position.
.86e3	c8		iny				iny								; skip index
.86e4	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.86e6	c8		iny				iny
.86e7	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.86e9	d0 01		bne $86ec			bne 	_ICError
.86eb	60		rts				rts
.86ec					_ICError:
.86ec	20 9a 84	jsr $849a			jsr 	ErrorHandler
>86ef	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.86f6					_ICStackIndex:
.86f6	c8		iny				iny 							; skip the ]
.86f7	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.86fa	0a		asl a				asl 	a
.86fb	85 04		sta $04				sta 	zTemp1
.86fd	bd 00 07	lda $0700,x			lda 	highStack,x
.8700	2a		rol a				rol 	a
.8701	85 05		sta $05				sta 	zTemp1+1
.8703	ca		dex				dex 							; throw TOS.
.8704	5a		phy				phy
.8705	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.8707	b2 02		lda ($02)			lda 	(zTemp0)
.8709	65 04		adc $04				adc 	zTemp1
.870b	48		pha				pha
.870c	b1 02		lda ($02),y			lda 	(zTemp0),y
.870e	65 05		adc $05				adc 	zTemp1+1
.8710	85 03		sta $03				sta 	zTemp0+1
.8712	68		pla				pla
.8713	85 02		sta $02				sta 	zTemp0
.8715	7a		ply				ply 							; restore pos and exit.
.8716	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/program.asm

.8717					EditProgram:
.8717	86 0d		stx $0d				stx 	zTemp5+1 					; save line number.
.8719	85 0c		sta $0c				sta 	zTemp5
.871b	5a		phy				phy 								; save token buffer offset
.871c	20 3f 87	jsr $873f			jsr 	EDFindLine					; find line address -> zTemp1
.871f	90 0f		bcc $8730			bcc 	_EPNotFound 				; if missing don't delete it.
.8721	a5 04		lda $04				lda 	zTemp1 						; save line address
.8723	48		pha				pha
.8724	a5 05		lda $05				lda 	zTemp1+1
.8726	48		pha				pha
.8727	20 74 87	jsr $8774			jsr 	EDDeleteLine 				; delete the line
.872a	68		pla				pla 								; restore line address
.872b	85 05		sta $05				sta 	zTemp1+1
.872d	68		pla				pla
.872e	85 04		sta $04				sta 	zTemp1
.8730					_EPNotFound:
.8730	7a		ply				ply 								; get offset
.8731	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; if something after line#
.8734	f0 03		beq $8739			beq 	_EPNoInsert
.8736	20 97 87	jsr $8797			jsr 	EDInsertLine 				; insert line back in.
.8739					_EPNoInsert:
.8739	20 f6 87	jsr $87f6			jsr 	ResetMemory
.873c	4c 1b 80	jmp $801b			jmp 	WarmStart
.873f					EDFindLine:
.873f	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.8741	85 04		sta $04				sta 	zTemp1
.8743	a9 10		lda #$10			lda 	#ProgramStart >> 8
.8745	85 05		sta $05				sta 	zTemp1+1
.8747					_EDFLLoop:
.8747	a0 00		ldy #$00			ldy 	#0 							; reached the end
.8749	b1 04		lda ($04),y			lda 	(zTemp1),y
.874b	f0 23		beq $8770			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.874d	c8		iny				iny
.874e	38		sec				sec
.874f	a5 0c		lda $0c				lda 	zTemp5						; subtract the current from the target
.8751	f1 04		sbc ($04),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.8753	aa		tax				tax	 								; this will return 10.
.8754	a5 0d		lda $0d				lda 	zTemp5+1
.8756	c8		iny				iny
.8757	f1 04		sbc ($04),y			sbc 	(zTemp1),y
.8759	90 15		bcc $8770			bcc 	_EDFLFail					; if target < current then failed.
.875b	d0 04		bne $8761			bne 	_EDFLNext 					; if non-zero then goto next
.875d	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.875f	f0 11		beq $8772			beq 	_EDFLFound
.8761					_EDFLNext:
.8761	a0 00		ldy #$00			ldy 	#0 							; get offset
.8763	18		clc				clc
.8764	b1 04		lda ($04),y			lda 	(zTemp1),y
.8766	65 04		adc $04				adc 	zTemp1 						; add to pointer
.8768	85 04		sta $04				sta 	zTemp1
.876a	90 db		bcc $8747			bcc 	_EDFLLoop
.876c	e6 05		inc $05				inc 	zTemp1+1 					; carry out.
.876e	80 d7		bra $8747			bra 	_EDFLLoop
.8770					_EDFLFail:
.8770	18		clc				clc
.8771	60		rts				rts
.8772					_EDFLFound:
.8772	38		sec				sec
.8773	60		rts				rts
.8774					EDDeleteLine:
.8774	20 14 88	jsr $8814			jsr 	ResetVarMemory
.8777	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.8779	a2 00		ldx #$00			ldx 	#0
.877b	b1 04		lda ($04),y			lda 	(zTemp1),y
.877d	a8		tay				tay 								; put in Y
.877e					_EDDelLoop:
.877e	b1 04		lda ($04),y			lda 	(zTemp1),y 					; get it
.8780	81 04		sta ($04,x)			sta 	(zTemp1,x) 					; write it.
.8782	a5 04		lda $04				lda 	zTemp1 						; check if pointer has reached the end of
.8784	c5 13		cmp $13				cmp		memVarPtr 					; low memory. We will have copied down an
.8786	d0 06		bne $878e			bne 	_EDDelNext 					; extra pile of stuff - technically should
.8788	a5 05		lda $05				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.878a	c5 14		cmp $14				cmp 	memVarPtr+1					; doesn't really matter.
.878c	f0 08		beq $8796			beq		_EDDelExit
.878e					_EDDelNext:
.878e	e6 04		inc $04				inc 	zTemp1 						; go to next byte.
.8790	d0 ec		bne $877e			bne 	_EDDelLoop
.8792	e6 05		inc $05				inc 	zTemp1+1
.8794	80 e8		bra $877e			bra 	_EDDelLoop
.8796					_EDDelExit:
.8796	60		rts				rts
.8797					EDInsertLine:
.8797	84 02		sty $02				sty 	zTemp0						; zTemp0 = address of code.
.8799	a9 0a		lda #$0a			lda 	#TokenBuffer >> 8
.879b	85 03		sta $03				sta 	zTemp0+1
.879d	20 14 88	jsr $8814			jsr 	ResetVarMemory
.87a0	a5 13		lda $13				lda 	memVarPtr 					; copy high memory to zTemp3
.87a2	85 08		sta $08				sta 	zTemp3
.87a4	a5 14		lda $14				lda 	memVarPtr+1
.87a6	85 09		sta $09				sta 	zTemp3+1
.87a8	a5 19		lda $19				lda 	TokenOffset 				; work out the space needed.
.87aa	38		sec				sec
.87ab	e5 02		sbc $02				sbc 	zTemp0
.87ad	18		clc				clc
.87ae	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.87b0	48		pha				pha 								; save total size (e.g. offset)
.87b1	85 0a		sta $0a				sta 	zTemp4 						; save for copying
.87b3	a8		tay				tay 								; in Y
.87b4	a2 00		ldx #$00			ldx 	#0
.87b6					_EDInsLoop:
.87b6	a1 08		lda ($08,x)			lda 	(zTemp3,x)					; copy it up
.87b8	91 08		sta ($08),y			sta 	(zTemp3),y
.87ba	a5 08		lda $08				lda 	zTemp3 						; reached the insert point (zTemp1)
.87bc	c5 04		cmp $04				cmp 	zTemp1
.87be	d0 06		bne $87c6			bne 	_EDINextShift
.87c0	a5 09		lda $09				lda 	zTemp3+1
.87c2	c5 05		cmp $05				cmp 	zTemp1+1
.87c4	f0 0a		beq $87d0			beq 	_EDIShiftOver
.87c6					_EDINextShift:
.87c6	a5 08		lda $08				lda 	zTemp3 					; decrement the copy pointer.
.87c8	d0 02		bne $87cc			bne 	_EDINoBorrow
.87ca	c6 09		dec $09				dec 	zTemp3+1
.87cc					_EDINoBorrow:
.87cc	c6 08		dec $08				dec 	zTemp3
.87ce	80 e6		bra $87b6			bra 	_EDInsLoop
.87d0					_EDIShiftOver:
.87d0	68		pla				pla 								; this is the size + others, e.g. offset
.87d1	a0 00		ldy #$00			ldy 	#0
.87d3	91 08		sta ($08),y			sta 	(zTemp3),y 					; write that out.
.87d5	a5 0c		lda $0c				lda 	zTemp5 						; write Line# out
.87d7	c8		iny				iny
.87d8	91 08		sta ($08),y			sta 	(zTemp3),y
.87da	a5 0d		lda $0d				lda 	zTemp5+1
.87dc	c8		iny				iny
.87dd	91 08		sta ($08),y			sta 	(zTemp3),y
.87df	c8		iny				iny 								; where the code goes.
.87e0	a2 00		ldx #$00			ldx 	#0 							; comes from
.87e2					_EDICopyCode:
.87e2	a1 02		lda ($02,x)			lda 	(zTemp0,x)					; read from the current line
.87e4	91 08		sta ($08),y			sta 	(zTemp3),y 					; write out
.87e6	c8		iny				iny 								; bump pointers
.87e7	e6 02		inc $02				inc 	zTemp0
.87e9	d0 02		bne $87ed			bne 	_EDINoCarry
.87eb	e6 03		inc $03				inc 	zTemp0+1
.87ed					_EDINoCarry:
.87ed	c6 0a		dec $0a				dec 	zTemp4 						; copy data in
.87ef	a5 0a		lda $0a				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.87f1	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.87f3	d0 ed		bne $87e2			bne 	_EDICopyCode
.87f5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.87f6					ResetMemory:
.87f6	da		phx				phx									; save run address
.87f7	5a		phy				phy
.87f8	a9 00		lda #$00			lda 	#(highMemory) & $FF
.87fa	85 11		sta $11				sta 	allocPtr
.87fc	a9 7f		lda #$7f			lda 	#(highMemory) >> 8
.87fe	85 12		sta $12				sta 	allocPtr+1
.8800	20 14 88	jsr $8814			jsr 	ResetVarMemory
.8803	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.8805					_RMEraseHash:
.8805	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.8808	ca		dex				dex
.8809	10 fa		bpl $8805			bpl 	_RMEraseHash
.880b	7a		ply				ply 								; restore and set run address
.880c	fa		plx				plx
.880d	84 01		sty $01				sty 	codePtr+1
.880f	86 00		stx $00				stx 	codePtr
.8811	a0 03		ldy #$03			ldy 	#3
.8813	60		rts				rts
.8814					ResetVarMemory:
.8814	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8816	85 13		sta $13				sta 	memVarPtr
.8818	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.881a	85 14		sta $14				sta 	memVarPtr+1
.881c					_RMFindEnd:
.881c	b2 13		lda ($13)			lda 	(memVarPtr)					; offset 0, found end.
.881e	f0 0b		beq $882b			beq 	_RMFoundEnd 				; advance to next.
.8820	18		clc				clc
.8821	65 13		adc $13				adc 	memVarPtr
.8823	85 13		sta $13				sta 	memVarPtr
.8825	90 f5		bcc $881c			bcc 	_RMFindEnd
.8827	e6 14		inc $14				inc 	memVarPtr+1
.8829	80 f1		bra $881c			bra 	_RMFindEnd
.882b					_RMFoundEnd:
.882b	e6 13		inc $13				inc 	memVarPtr 					; advance past last offset $00
.882d	d0 02		bne $8831			bne 	_RMNoCarry
.882f	e6 14		inc $14				inc 	memVarPtr+1
.8831					_RMNoCarry:
.8831	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.8832					StackReset:
.8832	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.8834	85 0e		sta $0e				sta 	iStack
.8836	a9 09		lda #$09			lda 	#IntStack >> 8
.8838	85 0f		sta $0f				sta 	iStack+1
.883a	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.883c	92 0e		sta ($0e)			sta 	(iStack)
.883e	60		rts				rts
.883f					StackPushByte:
.883f	c6 0e		dec $0e				dec 	iStack
.8841	92 0e		sta ($0e)			sta 	(iStack)
.8843	f0 01		beq $8846			beq 	_SPBUnderflow
.8845	60		rts				rts
.8846					_SPBUnderflow:
.8846	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8849	53 54 41 43 4b 00				.text 	"STACK",0
.884f					StackPushPosition:
.884f	98		tya				tya
.8850	20 3f 88	jsr $883f			jsr 	StackPushByte
.8853	a5 01		lda $01				lda 	codePtr+1
.8855	20 3f 88	jsr $883f			jsr 	StackPushByte
.8858	a5 00		lda $00				lda 	codePtr
.885a	20 3f 88	jsr $883f			jsr 	StackPushByte
.885d	60		rts				rts
.885e					StackCheckTop:
.885e	d2 0e		cmp ($0e)			cmp 	(iStack)
.8860	f0 02		beq $8864			beq 	_SCTOk
.8862	18		clc				clc
.8863	60		rts				rts
.8864	38		sec		_SCTOk:	sec
.8865	60		rts				rts
.8866					StackPop:
.8866	18		clc				clc
.8867	65 0e		adc $0e				adc 	iStack
.8869	85 0e		sta $0e				sta 	iStack
.886b	60		rts				rts
.886c					StackRestorePosition:
.886c	b1 0e		lda ($0e),y			lda 	(iStack),y
.886e	85 00		sta $00				sta 	codePtr
.8870	c8		iny				iny
.8871	b1 0e		lda ($0e),y			lda 	(iStack),y
.8873	85 01		sta $01				sta 	codePtr+1
.8875	c8		iny				iny
.8876	b1 0e		lda ($0e),y			lda 	(iStack),y
.8878	a8		tay				tay
.8879	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.887a					StringToInt:
.887a	86 08		stx $08				stx 	zTemp3 						; save string
.887c	84 09		sty $09				sty 	zTemp3+1
.887e	64 10		stz $10				stz 	signCount 					; signcount is the number of chars copied.
.8880	a2 10		ldx #$10			ldx 	#16 						; base to use.
.8882	a0 01		ldy #$01			ldy 	#1 							; character offset.
.8884	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.8886	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.8888	f0 03		beq $888d			beq 	_STIConvert 				; convert from character 1, base 16.
.888a	88		dey				dey 								; from character 0
.888b	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.888d					_STIConvert:
.888d	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.888f	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.8891	f0 5f		beq $88f2			beq 	_STIFail 					; if zero, then it has failed anyway.
.8893	64 02		stz $02				stz 	zTemp0 						; clear the result.
.8895	64 03		stz $03				stz 	zTemp0+1
.8897					_STILoop:
.8897	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.8899	c9 30		cmp #$30			cmp 	#"0"
.889b	90 55		bcc $88f2			bcc 	_STIFail
.889d	c9 3a		cmp #$3a			cmp 	#"9"+1
.889f	90 08		bcc $88a9			bcc 	_STIOkay
.88a1	c9 41		cmp #$41			cmp 	#"A"
.88a3	90 4d		bcc $88f2			bcc 	_STIFail
.88a5	c9 47		cmp #$47			cmp 	#"F"+1
.88a7	b0 49		bcs $88f2			bcs 	_STIFail
.88a9					_STIOkay:
.88a9	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.88ab	85 06		sta $06				sta 	zTemp2
.88ad	a5 03		lda $03				lda 	zTemp0+1
.88af	85 07		sta $07				sta 	zTemp2+1
.88b1	64 02		stz $02				stz 	zTemp0 						; clear result
.88b3	64 03		stz $03				stz 	zTemp0+1
.88b5	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.88b7					_STIMultiply:
.88b7	8a		txa				txa 								; shift Y right into carry.
.88b8	4a		lsr a				lsr 	a
.88b9	aa		tax				tax
.88ba	90 0d		bcc $88c9			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.88bc	18		clc				clc
.88bd	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.88bf	65 02		adc $02				adc 	zTemp0
.88c1	85 02		sta $02				sta 	zTemp0
.88c3	a5 07		lda $07				lda 	zTemp2+1
.88c5	65 03		adc $03				adc 	zTemp0+1
.88c7	85 03		sta $03				sta 	zTemp0+1
.88c9					_STINoAdd:
.88c9	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.88cb	26 07		rol $07				rol 	zTemp2+1
.88cd	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.88cf	d0 e6		bne $88b7			bne 	_STIMultiply
.88d1	38		sec				sec 								; hex adjust
.88d2	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.88d4	c9 3a		cmp #$3a			cmp 	#58
.88d6	90 03		bcc $88db			bcc 	_STIDecimal
.88d8	38		sec				sec
.88d9	e9 07		sbc #$07			sbc 	#7
.88db					_STIDecimal:
.88db	38		sec				sec
.88dc	e9 30		sbc #$30			sbc 	#48
.88de	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.88e0	b0 10		bcs $88f2			bcs 	_STIFail
.88e2	d8		cld				cld
.88e3	65 02		adc $02				adc 	zTemp0 						; add into the current value
.88e5	85 02		sta $02				sta 	zTemp0
.88e7	90 02		bcc $88eb			bcc 	_STINoCarry
.88e9	e6 03		inc $03				inc 	zTemp0+1
.88eb					_STINoCarry:
.88eb	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.88ed	c8		iny				iny 								; point to next
.88ee	e6 10		inc $10				inc 	SignCount
.88f0	80 a5		bra $8897			bra 	_STILoop 					; and go round again.
.88f2					_STIFail:
.88f2	a5 10		lda $10				lda 	SignCount 					; if converted 0 charactes, fail.
.88f4	f0 07		beq $88fd			beq 	_STINoConvert
.88f6	98		tya				tya 								; convert count in A.
.88f7	a6 02		ldx $02				ldx 	zTemp0 						; return result
.88f9	a4 03		ldy $03				ldy 	zTemp0+1
.88fb	38		sec				sec
.88fc	60		rts				rts
.88fd					_STINoConvert:
.88fd	18		clc				clc
.88fe	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.88ff					IntToString:
.88ff	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.8901	84 03		sty $03				sty 	zTemp0+1
.8903	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.8905	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.8907					_ITSLoop:
.8907	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.8909					_ITSSubtractLoop:
.8909	38		sec				sec
.890a	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.890c	fd 42 89	sbc $8942,x			sbc 	_ITSWords,x
.890f	48		pha				pha
.8910	a5 03		lda $03				lda 	zTemp0+1
.8912	fd 43 89	sbc $8943,x			sbc 	_ITSWords+1,x
.8915	90 09		bcc $8920			bcc 	_ITSEndSub 					; can't subtract any more.
.8917	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.8919	68		pla				pla
.891a	85 02		sta $02				sta 	zTemp0
.891c	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.891e	80 e9		bra $8909			bra 	_ITSSubtractLoop
.8920					_ITSEndSub:
.8920	68		pla				pla 								; throw away the interim result
.8921	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.8923	d0 04		bne $8929			bne 	_ITSWriteOut 				; always write it out
.8925	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.8927	f0 06		beq $892f			beq 	_ITSNext 					; suppressing leading zeros.
.8929					_ITSWriteOut:
.8929	09 30		ora #$30			ora 	#48 						; output digit.
.892b	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.892e	c8		iny				iny
.892f					_ITSNext:
.892f	e8		inx				inx
.8930	e8		inx				inx
.8931	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.8933	d0 d2		bne $8907			bne 	_ITSLoop 					; do the new digits
.8935	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.8937	09 30		ora #$30			ora 	#48
.8939	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.893c	a9 00		lda #$00			lda 	#0
.893e	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.8941	60		rts				rts
.8942					_ITSWords:
>8942	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.894a					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.894a					VariableFind:
.894a	da		phx				phx 								; save the stack position
.894b	08		php				php 								; save the create flag
.894c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.894e	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.8950	90 10		bcc $8962			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.8952	29 1f		and #$1f			and 	#$1F 						; make it an offset
.8954	0a		asl a				asl 	a 							; double clear carry
.8955	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.8957	85 02		sta $02				sta 	zTemp0
.8959	a9 0f		lda #$0f			lda		#FastVariables >>8
.895b	85 03		sta $03				sta 	zTemp0+1
.895d	28		plp				plp 								; create flag is irrelevant.
.895e	fa		plx				plx									; restore the old stack position
.895f	c8		iny				iny 								; skip over the single identifier character
.8960	38		sec				sec 								; return with CS
.8961	60		rts				rts
.8962					_VFIsNotFastVariable:
.8962	20 34 8a	jsr $8a34			jsr 	VFSetupHashPointer 			; set up the hash pointer
.8965	20 8f 89	jsr $898f			jsr 	VFSearch 					; try to find the variable.
.8968	b0 0d		bcs $8977			bcs 	_VFEndSearch 				; found it, so exit
.896a	28		plp				plp 								; do we want autocreate
.896b	b0 03		bcs $8970			bcs 	_VFCreate
.896d	fa		plx				plx 								; restore stack position and return CC
.896e	18		clc				clc
.896f	60		rts				rts
.8970					_VFCreate:
.8970	20 34 8a	jsr $8a34			jsr 	VFSetupHashPointer 			; reset the hash pointer
.8973	20 cb 89	jsr $89cb			jsr 	VFCreate 					; create a new record and link it in.
.8976	08		php				php 								; save a dummy P to be popped.
.8977					_VFEndSearch:
.8977	18		clc				clc 								; the data is at offset + 4
.8978	a5 04		lda $04				lda 	zTemp1
.897a	69 04		adc #$04			adc 	#4
.897c	85 02		sta $02				sta 	zTemp0
.897e	a5 05		lda $05				lda 	zTemp1+1
.8980	69 00		adc #$00			adc 	#0
.8982	85 03		sta $03				sta 	zTemp0+1
.8984	28		plp				plp 								; dump the create flag
.8985					_VFSkipExit:
.8985	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.8987	c8		iny				iny
.8988	c9 e0		cmp #$e0			cmp 	#$E0
.898a	90 f9		bcc $8985			bcc 	_VFSkipExit
.898c	fa		plx				plx 								; restore X
.898d	38		sec				sec
.898e	60		rts				rts
.898f					VFSearch:
.898f	48		pha				pha 								; save AXY.
.8990	da		phx				phx
.8991	5a		phy				phy
.8992	98		tya				tya									; add Y to codePtr, put in zTemp2
.8993	18		clc				clc 								; so it points to the identifier.
.8994	65 00		adc $00				adc 	codePtr
.8996	85 06		sta $06				sta 	zTemp2
.8998	a5 01		lda $01				lda 	codePtr+1
.899a	69 00		adc #$00			adc 	#0
.899c	85 07		sta $07				sta 	zTemp2+1
.899e					_VFSLoop:
.899e	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.89a0	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.89a2	f0 22		beq $89c6			beq 	_VFSFailed 					; failed.
.89a4	aa		tax				tax 								; MSB in X
.89a5	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.89a7	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.89a9	86 05		stx $05				stx 	zTemp1+1
.89ab	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.89ad	b1 04		lda ($04),y			lda 	(zTemp1),y
.89af	85 08		sta $08				sta 	zTemp3
.89b1	c8		iny				iny
.89b2	b1 04		lda ($04),y			lda 	(zTemp1),y
.89b4	85 09		sta $09				sta 	zTemp3+1
.89b6	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.89b8					_VFSCheckName:
.89b8	c8		iny				iny
.89b9	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.89bb	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.89bd	d0 df		bne $899e			bne 	_VFSLoop
.89bf	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.89c1	90 f5		bcc $89b8			bcc 	_VFSCheckName
.89c3	38		sec				sec 								; return with Carry set, and zTemp1 set up
.89c4	80 01		bra $89c7			bra		_VFSExit
.89c6					_VFSFailed:
.89c6	18		clc				clc
.89c7					_VFSExit:
.89c7	7a		ply				ply 								; restore registers and exit.
.89c8	fa		plx				plx
.89c9	68		pla				pla
.89ca	60		rts				rts
.89cb					VFCreate:
.89cb	48		pha				pha 								; save registers
.89cc	da		phx				phx
.89cd	5a		phy				phy
.89ce	18		clc				clc 								; add 6 to memVarPtr, saving its
.89cf	a5 13		lda $13				lda 	memVarPtr 					; address in zTemp0 as we go.
.89d1	85 02		sta $02				sta 	zTemp0
.89d3	69 06		adc #$06			adc 	#6
.89d5	85 13		sta $13				sta 	memVarPtr
.89d7	a5 14		lda $14				lda 	memVarPtr+1
.89d9	85 03		sta $03				sta 	zTemp0+1
.89db	69 00		adc #$00			adc 	#0
.89dd	85 14		sta $14				sta 	memVarPtr+1
.89df	c5 12		cmp $12				cmp 	allocPtr+1 					; out of memory ?
.89e1	f0 46		beq $8a29			beq 	_VFCMemory
.89e3	98		tya				tya 								; work out identifier address
.89e4	18		clc				clc
.89e5	65 00		adc $00				adc 	codePtr
.89e7	48		pha				pha
.89e8	c8		iny				iny
.89e9	a5 01		lda $01				lda 	codePtr+1
.89eb	69 00		adc #$00			adc 	#0
.89ed	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.89ef	b0 0b		bcs $89fc			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.89f1	20 9a 84	jsr $849a			jsr 	ErrorHandler
>89f4	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.89fc					_VFCInProgram:
.89fc	a0 03		ldy #$03			ldy 	#3 							; store in new record
.89fe	91 02		sta ($02),y			sta 	(zTemp0),y
.8a00	88		dey				dey
.8a01	68		pla				pla
.8a02	91 02		sta ($02),y			sta 	(zTemp0),y
.8a04	a0 04		ldy #$04			ldy 	#4 							; clear new data
.8a06	a9 00		lda #$00			lda 	#0
.8a08	91 02		sta ($02),y			sta 	(zTemp0),y
.8a0a	c8		iny				iny
.8a0b	91 02		sta ($02),y			sta 	(zTemp0),y
.8a0d	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.8a0f	b2 04		lda ($04)			lda 	(zTemp1)
.8a11	92 02		sta ($02)			sta 	(zTemp0)
.8a13	b1 04		lda ($04),y			lda 	(zTemp1),y
.8a15	91 02		sta ($02),y			sta 	(zTemp0),y
.8a17	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.8a19	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.8a1b	a5 03		lda $03				lda 	zTemp0+1
.8a1d	91 04		sta ($04),y			sta 	(zTemp1),y
.8a1f	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.8a21	a5 02		lda $02				lda 	zTemp0
.8a23	85 04		sta $04				sta 	zTemp1
.8a25	7a		ply				ply
.8a26	fa		plx				plx
.8a27	68		pla				pla
.8a28	60		rts				rts
.8a29					_VFCMemory:
.8a29	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8a2c	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.8a34					VFSetupHashPointer:
.8a34	48		pha				pha
.8a35	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.8a37	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.8a39	0a		asl a				asl 	a 							; double it, also clears carry
.8a3a	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.8a3c	85 04		sta $04				sta 	zTemp1
.8a3e	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.8a40	85 05		sta $05				sta 	zTemp1+1
.8a42	68		pla				pla
.8a43	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.8a44					TokeniseInputBuffer:
.8a44	48		pha				pha
.8a45	da		phx				phx
.8a46	5a		phy				phy
.8a47	64 19		stz $19				stz 	TokenOffset					; reset index into TokenBuffer
.8a49	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.8a4c	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.8a4e	20 b7 8a	jsr $8ab7			jsr 	TokWriteToken
.8a51	20 b7 8a	jsr $8ab7			jsr 	TokWriteToken
.8a54	20 b7 8a	jsr $8ab7			jsr 	TokWriteToken
.8a57	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.8a59					_TIBForward:
.8a59	e8		inx				inx
.8a5a	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8a5d	d0 fa		bne $8a59			bne 	_TIBForward
.8a5f					_TIBBackward:
.8a5f	ca		dex				dex 								; back one.
.8a60	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.8a62	f0 4f		beq $8ab3			beq 	_TIBExit					; return empty buffer
.8a64	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8a67	c9 20		cmp #$20			cmp 	#" "
.8a69	f0 f4		beq $8a5f			beq 	_TIBBackward
.8a6b	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.8a6e	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.8a70					_TIBMainLoop:
.8a70	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.8a73	f0 3e		beq $8ab3			beq 	_TIBExit 					; done the buffer if zero.
.8a75	e8		inx				inx
.8a76	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.8a78	f0 f6		beq $8a70			beq 	_TIBMainLoop
.8a7a	ca		dex				dex 								; undo the last inx.
.8a7b	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.8a7d	f0 08		beq $8a87			beq 	_TIBConstant
.8a7f	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.8a81	90 09		bcc $8a8c			bcc 	_TIBNotConstant
.8a83	c9 3a		cmp #$3a			cmp 	#"9"+1
.8a85	b0 05		bcs $8a8c			bcs 	_TIBNotConstant
.8a87					_TIBConstant:
.8a87	20 3a 8b	jsr $8b3a			jsr 	TOKConvertConstant
.8a8a	80 e4		bra $8a70			bra 	_TIBMainLoop
.8a8c					_TIBNotConstant:
.8a8c	c9 3a		cmp #$3a			cmp 	#":"						; definition
.8a8e	d0 05		bne $8a95			bne 	_TIBNotDefinition
.8a90	20 8c 8b	jsr $8b8c			jsr 	TOKConvertDefinition
.8a93	80 db		bra $8a70			bra 	_TIBMainLoop
.8a95					_TIBNotDefinition:
.8a95	c9 27		cmp #$27			cmp 	#"'"
.8a97	f0 04		beq $8a9d			beq 	_TIBIsCommentString
.8a99	c9 22		cmp #$22			cmp 	#'"'
.8a9b	d0 05		bne $8aa2			bne 	_TIBNotCommentString
.8a9d					_TIBIsCommentString:
.8a9d	20 f0 8b	jsr $8bf0			jsr 	TOKConvertCommentString
.8aa0	80 ce		bra $8a70			bra 	_TIBMainLoop
.8aa2					_TIBNotCommentString:
.8aa2	20 37 8c	jsr $8c37			jsr 	TOKCheckIsToken 			; check if a token.
.8aa5	b0 c9		bcs $8a70			bcs 	_TIBMainLoop
.8aa7	a5 19		lda $19				lda 	TokenOffset 				; save token offset.
.8aa9	48		pha				pha
.8aaa	20 cb 8b	jsr $8bcb			jsr 	TOKCopyIdentifier 			; copy identifier.
.8aad	68		pla				pla
.8aae	20 e8 8a	jsr $8ae8			jsr 	TOKCheckIdentifierIsCall 	; convert if call.
.8ab1	80 bd		bra $8a70			bra 	_TIBMainLoop
.8ab3					_TIBExit:
.8ab3	7a		ply				ply
.8ab4	fa		plx				plx
.8ab5	68		pla				pla
.8ab6	60		rts				rts
.8ab7					TOKWriteToken:
.8ab7	da		phx				phx
.8ab8	a6 19		ldx $19				ldx 	TokenOffset
.8aba	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.8abd	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.8ac0	e6 19		inc $19				inc 	TokenOffset
.8ac2	fa		plx				plx
.8ac3	60		rts				rts
.8ac4					TOKFixUpLast:
.8ac4	da		phx				phx
.8ac5	a6 19		ldx $19				ldx 	TokenOffset
.8ac7	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.8aca	09 e0		ora #$e0			ora 	#$E0
.8acc	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.8acf	fa		plx				plx
.8ad0	60		rts				rts
.8ad1					TOKConvertIdentifier:
.8ad1	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.8ad3	f0 0f		beq $8ae4			beq 	_TKCIDot
.8ad5	38		sec				sec 								; A-Z -> 1-27
.8ad6	e9 40		sbc #$40			sbc 	#64
.8ad8	f0 08		beq $8ae2			beq 	_TKCIFail
.8ada	c9 1b		cmp #$1b			cmp 	#27
.8adc	b0 04		bcs $8ae2			bcs 	_TKCIFail
.8ade	09 c0		ora #$c0			ora 	#$C0 						; fix up
.8ae0	38		sec				sec
.8ae1	60		rts				rts
.8ae2					_TKCIFail:
.8ae2	18		clc				clc
.8ae3	60		rts				rts
.8ae4					_TKCIDot:
.8ae4	a9 db		lda #$db			lda 	#$C0+27
.8ae6	38		sec				sec
.8ae7	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_check_call.asm

.8ae8					TOKCheckIdentifierIsCall:
.8ae8	48		pha				pha
.8ae9	da		phx				phx
.8aea	5a		phy				phy
.8aeb	85 04		sta $04				sta 	zTemp1
.8aed	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8aef	85 02		sta $02				sta 	zTemp0
.8af1	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.8af3	85 03		sta $03				sta 	zTemp0+1
.8af5					_TKCIILoop:
.8af5	b2 02		lda ($02)			lda 	(zTemp0) 					; reached the end
.8af7	f0 3d		beq $8b36			beq 	_TKCIIExit
.8af9	a0 03		ldy #$03			ldy 	#3							; check if definition
.8afb	b1 02		lda ($02),y			lda 	(zTemp0),y
.8afd	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8aff	d0 28		bne $8b29			bne 	_TKCIINext 					; if not skip.
.8b01	a6 04		ldx $04				ldx 	zTemp1 						; position of identifier.
.8b03	c8		iny				iny 								; skip count
.8b04					_TKCIICheck:
.8b04	c8		iny				iny
.8b05	bd 00 0a	lda $0a00,x			lda 	TokenBuffer,x 				; compare identifiers
.8b08	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8b0a	d0 1d		bne $8b29			bne 	_TKCIINext
.8b0c	e8		inx				inx
.8b0d	c9 e0		cmp #$e0			cmp 	#$E0						; go back if not end identifier.
.8b0f	90 f3		bcc $8b04			bcc 	_TKCIICheck
.8b11	a5 04		lda $04				lda 	zTemp1 						; get identifier position
.8b13	85 19		sta $19				sta 	TokenOffset 				; reset it.
.8b15	a9 02		lda #$02			lda 	#KWD_SYS_CALL 				; write call
.8b17	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b1a	a0 01		ldy #$01			ldy 	#1
.8b1c	b1 02		lda ($02),y			lda 	(zTemp0),y
.8b1e	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b21	c8		iny				iny
.8b22	b1 02		lda ($02),y			lda 	(zTemp0),y
.8b24	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b27	80 0d		bra $8b36			bra 	_TKCIIExit 					; and exit.
.8b29					_TKCIINext:
.8b29	18		clc				clc
.8b2a	b2 02		lda ($02)			lda 	(zTemp0)
.8b2c	65 02		adc $02				adc 	zTemp0
.8b2e	85 02		sta $02				sta 	zTemp0
.8b30	90 c3		bcc $8af5			bcc 	_TKCIILoop
.8b32	e6 03		inc $03				inc 	zTemp0+1
.8b34	80 bf		bra $8af5			bra 	_TKCIILoop
.8b36					_TKCIIExit:
.8b36	7a		ply				ply
.8b37	fa		plx				plx
.8b38	68		pla				pla
.8b39	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.8b3a					TOKConvertConstant:
.8b3a	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.8b3c	da		phx				phx 								; save X position
.8b3d	20 7a 88	jsr $887a			jsr 	StringToInt 				; try to convert
.8b40	90 40		bcc $8b82			bcc 	_TKCCError
.8b42	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.8b44	86 02		stx $02				stx 	zTemp0
.8b46	85 04		sta $04				sta 	zTemp1 						; save count
.8b48	68		pla				pla 								; restore X position, add the count
.8b49	18		clc				clc
.8b4a	65 04		adc $04				adc 	zTemp1
.8b4c	aa		tax				tax
.8b4d	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.8b50	c9 2d		cmp #$2d			cmp 	#"-"
.8b52	d0 0e		bne $8b62			bne 	_TKCCNotNegative
.8b54	e8		inx				inx 								; consume the -
.8b55	38		sec				sec
.8b56	a9 00		lda #$00			lda 	#0 							; negate the constant.
.8b58	e5 02		sbc $02				sbc 	zTemp0
.8b5a	85 02		sta $02				sta 	zTemp0
.8b5c	a9 00		lda #$00			lda 	#0
.8b5e	e5 03		sbc $03				sbc 	zTemp0+1
.8b60	85 03		sta $03				sta 	zTemp0+1
.8b62					_TKCCNotNegative:
.8b62	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.8b64	d0 0c		bne $8b72			bne 	_TKCCLongConstant
.8b66	a5 02		lda $02				lda 	zTemp0
.8b68	c9 40		cmp #$40			cmp 	#$40
.8b6a	b0 06		bcs $8b72			bcs 	_TKCCLongConstant
.8b6c	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.8b6e	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b71	60		rts				rts
.8b72					_TKCCLongConstant:
.8b72	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.8b74	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b77	a5 02		lda $02				lda 	zTemp0
.8b79	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b7c	a5 03		lda $03				lda 	zTemp0+1
.8b7e	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b81	60		rts				rts
.8b82					_TKCCError:
.8b82	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8b85	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.8b8c					TOKConvertDefinition:
.8b8c	e8		inx				inx 								; skip over :
.8b8d	a9 05		lda #$05			lda 	#KWD_SYS_DEFINE 			; output define token
.8b8f	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8b92					TOKConvertIdentifierOnly:
.8b92	64 02		stz $02				stz 	zTemp0 						; count how many identifiers.
.8b94	da		phx				phx
.8b95					_TKCDCount:
.8b95	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8b98	20 d1 8a	jsr $8ad1			jsr 	TOKConvertIdentifier
.8b9b	90 05		bcc $8ba2			bcc 	_TKCDCounted
.8b9d	e8		inx				inx
.8b9e	e6 02		inc $02				inc 	zTemp0
.8ba0	80 f3		bra $8b95			bra 	_TKCDCount
.8ba2					_TKCDCounted:
.8ba2	a5 02		lda $02				lda 	zTemp0 						; get count
.8ba4	f0 16		beq $8bbc			beq 	_TKCDFail 					; can't be none
.8ba6	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken 				; write count
.8ba9	fa		plx				plx 								; restore X
.8baa					_TKCDLoop:
.8baa	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; output that many tokens.
.8bad	e8		inx				inx
.8bae	20 d1 8a	jsr $8ad1			jsr 	TOKConvertIdentifier
.8bb1	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8bb4	c6 02		dec $02				dec 	zTemp0
.8bb6	d0 f2		bne $8baa			bne 	_TKCDLoop
.8bb8	20 c4 8a	jsr $8ac4			jsr 	TOKFixUpLast 				; set bit for last character.
.8bbb	60		rts				rts
.8bbc					_TKCDFail:
.8bbc	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8bbf	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>8bc7	45 52 3f 00
.8bcb					TOKCopyIdentifier:
.8bcb	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8bce	20 d1 8a	jsr $8ad1			jsr 	TOKConvertIdentifier
.8bd1	90 13		bcc $8be6			bcc 	_TKCIError
.8bd3					_TKCILoop:
.8bd3	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get and output token till not found
.8bd6	e8		inx				inx
.8bd7	20 d1 8a	jsr $8ad1			jsr 	TOKConvertIdentifier
.8bda	90 05		bcc $8be1			bcc 	_TKCIEnd
.8bdc	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8bdf	80 f2		bra $8bd3			bra 	_TKCILoop
.8be1					_TKCIEnd:
.8be1	ca		dex				dex
.8be2	20 c4 8a	jsr $8ac4			jsr 	TOKFixUpLast 				; set bit for last character.
.8be5	60		rts				rts
.8be6					_TKCIError:
.8be6	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8be9	50 41 52 53 45 3f 00				.text 	"PARSE?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.8bf0					TOKConvertCommentString:
.8bf0	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.8bf2	f0 06		beq $8bfa			beq 	_TKCCSComment
.8bf4	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.8bf6	a0 22		ldy #$22			ldy 	#'"'						; match character
.8bf8	80 04		bra $8bfe			bra 	_TKCCSContinue
.8bfa					_TKCCSComment:
.8bfa	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.8bfc	a0 00		ldy #$00			ldy 	#0 							; match character
.8bfe					_TKCCSContinue:
.8bfe	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken 				; write initial token
.8c01	e8		inx				inx 								; skip over ' or "
.8c02	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.8c04	a0 00		ldy #$00			ldy 	#0 							; count of characters
.8c06	da		phx				phx 								; save start position
.8c07					_TKCCSFindSize:
.8c07	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.8c0a	c5 02		cmp $02				cmp 	zTemp0
.8c0c	f0 10		beq $8c1e			beq 	_TKCCSFoundEnd
.8c0e	e8		inx				inx 								; bump pos, count
.8c0f	c8		iny				iny
.8c10	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.8c12	d0 f3		bne $8c07			bne 	_TKCCSFindSize
.8c14	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8c17	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.8c1e					_TKCCSFoundEnd:
.8c1e	98		tya				tya 								; length of element in Y
.8c1f	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8c22	fa		plx				plx 								; restore start position and copy out
.8c23					_TKCCSCopyOut:
.8c23	c0 00		cpy #$00			cpy 	#0 							; complete ?
.8c25	f0 0a		beq $8c31			beq 	_TKCCSExit
.8c27	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8c2a	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken
.8c2d	e8		inx				inx
.8c2e	88		dey				dey
.8c2f	80 f2		bra $8c23			bra 	_TKCCSCopyOut
.8c31					_TKCCSExit:
.8c31	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.8c33	f0 01		beq $8c36			beq 	_TKCSSNotComment
.8c35	e8		inx				inx
.8c36					_TKCSSNotComment:
.8c36	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.8c37					TOKCheckIsToken:
.8c37	a9 91		lda #$91			lda 	#(KeywordText) & $FF
.8c39	85 02		sta $02				sta 	zTemp0
.8c3b	a9 80		lda #$80			lda 	#(KeywordText) >> 8
.8c3d	85 03		sta $03				sta 	zTemp0+1
.8c3f	64 04		stz $04				stz 	zTemp1 						; best match length
.8c41	64 06		stz $06				stz 	zTemp2 						; current token.
.8c43					_TCTLoop:
.8c43	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.8c45	da		phx				phx 								; save start
.8c46					_TCTCompare:
.8c46	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.8c48	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.8c4b	e8		inx				inx 								; bump both pointers.
.8c4c	c8		iny				iny
.8c4d	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.8c4e	d0 0e		bne $8c5e			bne 	_TCTNext 					; different, go to next.
.8c50	90 f4		bcc $8c46			bcc 	_TCTCompare 				; still comparing.
.8c52	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.8c54	c5 04		cmp $04				cmp 	zTemp1						; best so far
.8c56	90 06		bcc $8c5e			bcc 	_TCTNext 					; if not, skip to next.
.8c58	85 04		sta $04				sta 	zTemp1 						; new best score
.8c5a	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.8c5c	85 07		sta $07				sta 	zTemp2+1
.8c5e					_TCTNext:
.8c5e	fa		plx				plx 								; restore start position.
.8c5f	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.8c61	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.8c63	38		sec				sec
.8c64	65 02		adc $02				adc 	zTemp0
.8c66	85 02		sta $02				sta 	zTemp0
.8c68	90 02		bcc $8c6c			bcc		_TCTNoCarry
.8c6a	e6 03		inc $03				inc 	zTemp0+1
.8c6c					_TCTNoCarry:
.8c6c	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.8c6e	d0 d3		bne $8c43			bne 	_TCTLoop 					; no, check the next keyword.
.8c70	18		clc				clc
.8c71	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.8c73	f0 0b		beq $8c80			beq 	_TCTExit
.8c75	8a		txa				txa 								; add that length to the input index.
.8c76	18		clc				clc
.8c77	65 04		adc $04				adc 	zTemp1
.8c79	aa		tax				tax
.8c7a	a5 07		lda $07				lda 	zTemp2+1 					; token number
.8c7c	20 b7 8a	jsr $8ab7			jsr 	TOKWriteToken 				; write it out.
.8c7f	38		sec				sec 								; set carry and exit
.8c80					_TCTExit:
.8c80	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.8c81					Cmd_List:
.8c81	fa		plx				plx
.8c82	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.8c84	64 07		stz $07				stz 	zTemp2+1
.8c86	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.8c88	f0 0b		beq $8c95			beq 	_CLNoStart
.8c8a	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.8c8d	85 06		sta $06				sta 	zTemp2
.8c8f	bd 00 07	lda $0700,x			lda 	highStack,x
.8c92	85 07		sta $07				sta 	zTemp2+1
.8c94	ca		dex				dex
.8c95					_CLNoStart:
.8c95					_CLNoStartLine:
.8c95	a9 00		lda #$00			lda 	#(programStart) & $FF
.8c97	85 00		sta $00				sta 	codePtr
.8c99	a9 10		lda #$10			lda 	#(programStart) >> 8
.8c9b	85 01		sta $01				sta 	codePtr+1
.8c9d					_CLILoop:
.8c9d	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.8c9f	f0 24		beq $8cc5			beq 	_CLIEnd
.8ca1	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.8ca3	38		sec				sec
.8ca4	b1 00		lda ($00),y			lda 	(codePtr),y
.8ca6	e5 06		sbc $06				sbc 	zTemp2
.8ca8	c8		iny				iny
.8ca9	b1 00		lda ($00),y			lda 	(codePtr),y
.8cab	e5 07		sbc $07				sbc 	zTemp2+1
.8cad	90 09		bcc $8cb8			bcc 	_CLISkip
.8caf	da		phx				phx
.8cb0	20 c8 8c	jsr $8cc8			jsr 	ListCurrent 				; list the line.
.8cb3	fa		plx				plx
.8cb4	c6 08		dec $08				dec 	zTemp3 						; done all lines
.8cb6	f0 0d		beq $8cc5			beq 	_CLIEnd
.8cb8					_CLISkip:
.8cb8	18		clc				clc
.8cb9	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.8cbb	65 00		adc $00				adc 	codePtr
.8cbd	85 00		sta $00				sta 	codePtr
.8cbf	90 dc		bcc $8c9d			bcc 	_CLILoop
.8cc1	e6 01		inc $01				inc 	codePtr+1
.8cc3	80 d8		bra $8c9d			bra 	_CLILoop
.8cc5					_CLIEnd:
.8cc5	4c 1b 80	jmp $801b			jmp 	WarmStart
.8cc8					ListCurrent:
.8cc8	a9 02		lda #$02			lda 	#COL_GREEN
.8cca	20 ff 85	jsr $85ff			jsr 	ExternColour
.8ccd	a0 01		ldy #$01			ldy 	#1							; print line#
.8ccf	b1 00		lda ($00),y			lda 	(codePtr),y
.8cd1	aa		tax				tax
.8cd2	c8		iny				iny
.8cd3	b1 00		lda ($00),y			lda 	(codePtr),y
.8cd5	a8		tay				tay
.8cd6	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.8cd9	a8		tay				tay
.8cda					_LCPadOut:
.8cda	a9 20		lda #$20			lda 	#' '
.8cdc	20 f5 85	jsr $85f5			jsr 	ExternPrint
.8cdf	c8		iny				iny
.8ce0	c0 06		cpy #$06			cpy 	#6
.8ce2	d0 f6		bne $8cda			bne 	_LCPadOut
.8ce4	a0 03		ldy #$03			ldy 	#3 							; start here
.8ce6	64 17		stz $17				stz 	PrefixCharacter				; no prefix
.8ce8					_LCLoop:
.8ce8	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.8cea	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.8cec	f0 0b		beq $8cf9			beq 	_LCNoPrefix
.8cee	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.8cf0	f0 07		beq $8cf9			beq 	_LCNoPrefix
.8cf2	a5 17		lda $17				lda 	PrefixCharacter 			; output prefix, reset to space
.8cf4	f0 03		beq $8cf9			beq		_LCNoPrefix
.8cf6	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8cf9					_LCNoPrefix:
.8cf9	a9 20		lda #$20			lda 	#32
.8cfb	85 17		sta $17				sta 	PrefixCharacter
.8cfd	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.8cff	f0 13		beq $8d14			beq 	_LCExit
.8d01	10 4d		bpl $8d50			bpl 	_LCIsToken 					; +ve goto token.
.8d03	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.8d05	b0 13		bcs $8d1a			bcs 	_LCIsIdentifier
.8d07	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.8d09	aa		tax				tax
.8d0a	c8		iny				iny
.8d0b	5a		phy				phy 								; push pos
.8d0c	a0 00		ldy #$00			ldy 	#0
.8d0e	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.8d11	7a		ply				ply
.8d12	80 d4		bra $8ce8			bra 	_LCLoop
.8d14					_LCExit:
.8d14	a9 0d		lda #$0d			lda 	#13
.8d16	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8d19	60		rts				rts
.8d1a					_LCIsIdentifier:
.8d1a					_LCIdentLoop:
.8d1a	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.8d1c	20 2d 8e	jsr $8e2d			jsr 	ListPrintIDChar
.8d1f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.8d21	c8		iny				iny
.8d22	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.8d24	b0 c2		bcs $8ce8			bcs 	_LCLoop 					; if so, do next
.8d26	80 f2		bra $8d1a			bra 	_LCIdentLoop				; if not loop round
.8d28					_LCConstant:
.8d28	c8		iny				iny
.8d29	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.8d2b	aa		tax				tax
.8d2c	c8		iny				iny 								; get MSB into Y
.8d2d	b1 00		lda ($00),y			lda 	(codePtr),y
.8d2f	c8		iny				iny
.8d30	5a		phy				phy
.8d31	a8		tay				tay
.8d32	5a		phy				phy 								; save sign
.8d33	10 0c		bpl $8d41			bpl 	_LCNotNegative
.8d35	98		tya				tya 								; YX = |YX|
.8d36	49 ff		eor #$ff			eor 	#$FF
.8d38	a8		tay				tay
.8d39	8a		txa				txa
.8d3a	49 ff		eor #$ff			eor 	#$FF
.8d3c	aa		tax				tax
.8d3d	e8		inx				inx
.8d3e	d0 01		bne $8d41			bne 	_LCNotNegative
.8d40	c8		iny				iny
.8d41					_LCNotNegative:
.8d41					_LCPrintYX:
.8d41	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.8d44	68		pla				pla 								; restore sign
.8d45	10 05		bpl $8d4c			bpl 	_LCNoTrail
.8d47	a9 2d		lda #$2d			lda 	#"-"
.8d49	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8d4c					_LCNoTrail:
.8d4c	7a		ply				ply 								; restore Y
.8d4d	4c e8 8c	jmp $8ce8			jmp 	_LCLoop
.8d50					_LCIsToken:
.8d50	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.8d52	f0 d4		beq $8d28			beq 	_LCConstant
.8d54	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.8d56	90 3e		bcc $8d96			bcc 	_LCControl
.8d58					_LCIsKeywordToken:
.8d58	85 02		sta $02				sta 	zTemp0 						; save token #
.8d5a	a9 91		lda #$91			lda 	#(KeywordText) & $FF
.8d5c	85 04		sta $04				sta 	zTemp1
.8d5e	a9 80		lda #$80			lda 	#(KeywordText) >> 8
.8d60	85 05		sta $05				sta 	zTemp1+1
.8d62	5a		phy				phy 								; save code offset
.8d63					_LCForward:
.8d63	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.8d65	f0 0f		beq $8d76			beq 	_LCFoundToken
.8d67	c6 02		dec $02				dec 	zTemp0						; dec count.
.8d69	38		sec				sec 								; go to next keyword.
.8d6a	b2 04		lda ($04)			lda 	(zTemp1)
.8d6c	65 04		adc $04				adc 	zTemp1
.8d6e	85 04		sta $04				sta 	zTemp1
.8d70	90 f1		bcc $8d63			bcc 	_LCForward
.8d72	e6 05		inc $05				inc 	zTemp1+1
.8d74	80 ed		bra $8d63			bra 	_LCForward
.8d76					_LCFoundToken:
.8d76	a0 01		ldy #$01			ldy 	#1 							; output the token.
.8d78					_LCOutToken:
.8d78	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.8d7a	29 7f		and #$7f			and 	#$7F
.8d7c	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8d7f	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.8d81	c8		iny				iny
.8d82	0a		asl a				asl 	a
.8d83	90 f3		bcc $8d78			bcc 	_LCOutToken
.8d85	7a		ply				ply 								; restore code offset
.8d86	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.8d88	c8		iny				iny
.8d89	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.8d8b	f0 04		beq $8d91			beq 	_LCCancelPrefix
.8d8d	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.8d8f	d0 02		bne $8d93			bne 	_LCGoLoop
.8d91					_LCCancelPrefix:
.8d91	64 17		stz $17				stz 	PrefixCharacter
.8d93					_LCGoLoop:
.8d93	4c e8 8c	jmp $8ce8			jmp 	_LCLoop
.8d96					_LCControl:
.8d96	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.8d98	f0 3b		beq $8dd5			beq 	_LCDecodeCall
.8d9a	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8d9c	f0 22		beq $8dc0			beq 	_LCDecodeDefine
.8d9e	5a		phy				phy 								; save Y
.8d9f	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.8da1	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.8da3	f0 07		beq $8dac			beq 	_LCDecodeString
.8da5	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.8da7	a9 07		lda #$07			lda 	#COL_WHITE 					; highlight comment.
.8da9	20 ff 85	jsr $85ff			jsr 	ExternColour
.8dac					_LCDecodeString
.8dac	98		tya				tya
.8dad	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8db0	7a		ply				ply 								; restore Y pos
.8db1	48		pha				pha 								; save end character on stack.
.8db2	20 0d 8e	jsr $8e0d			jsr 	ListPrintCodeIdentifier
.8db5	68		pla				pla 								; last character
.8db6	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.8db8	f0 03		beq $8dbd			beq 	_LCEDNoQuote
.8dba	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8dbd					_LCEDNoQuote:
.8dbd	4c e8 8c	jmp $8ce8			jmp 	_LCLoop
.8dc0					_LCDecodeDefine:
.8dc0	a9 03		lda #$03			lda 	#COL_YELLOW 				; highlight definition.
.8dc2	20 ff 85	jsr $85ff			jsr 	ExternColour
.8dc5	a9 3a		lda #$3a			lda 	#":"
.8dc7	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8dca	20 0d 8e	jsr $8e0d			jsr 	ListPrintCodeIdentifier
.8dcd	a9 02		lda #$02			lda 	#COL_GREEN
.8dcf	20 ff 85	jsr $85ff			jsr 	ExternColour
.8dd2	4c e8 8c	jmp $8ce8			jmp 	_LCLoop
.8dd5					_LCDecodeCall:
.8dd5	a9 06		lda #$06			lda 	#COL_CYAN
.8dd7	20 ff 85	jsr $85ff			jsr 	ExternColour
.8dda	c8		iny				iny 								; get line number into XA
.8ddb	b1 00		lda ($00),y			lda 	(codePtr),y
.8ddd	48		pha				pha
.8dde	c8		iny				iny
.8ddf	b1 00		lda ($00),y			lda 	(codePtr),y
.8de1	c8		iny				iny
.8de2	aa		tax				tax
.8de3	68		pla				pla
.8de4	20 3f 8e	jsr $8e3f			jsr 	ListFindLine 				; find that line.
.8de7	90 19		bcc $8e02			bcc 	_LCNoDefinition
.8de9	5a		phy				phy
.8dea	a0 03		ldy #$03			ldy 	#3 							; look at first character
.8dec	b1 02		lda ($02),y			lda 	(zTemp0),y
.8dee	7a		ply				ply
.8def	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8df1	d0 0f		bne $8e02			bne 	_LCNoDefinition 			; not define
.8df3	5a		phy				phy
.8df4	a0 03		ldy #$03			ldy 	#3
.8df6	20 17 8e	jsr $8e17			jsr 	ListPrintIdentifier
.8df9	7a		ply				ply
.8dfa	a9 02		lda #$02			lda 	#COL_GREEN
.8dfc	20 ff 85	jsr $85ff			jsr 	ExternColour
.8dff	4c e8 8c	jmp $8ce8			jmp 	_LCLoop
.8e02					_LCNoDefinition:
.8e02	a9 25		lda #$25			lda 	#"%"						; print a %
.8e04	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8e07	88		dey				dey 								; unpick Y changes
.8e08	88		dey				dey
.8e09	88		dey				dey
.8e0a	4c 28 8d	jmp $8d28			jmp 	_LCConstant 				; output # as constant
.8e0d					ListPrintCodeIdentifier:
.8e0d	48		pha				pha 								; copy codePtr -> zTemp0
.8e0e	a5 00		lda $00				lda 	codePtr
.8e10	85 02		sta $02				sta 	zTemp0
.8e12	a5 01		lda $01				lda 	codePtr+1
.8e14	85 03		sta $03				sta 	zTemp0+1
.8e16	68		pla				pla
.8e17					ListPrintIdentifier:
.8e17	48		pha				pha
.8e18	da		phx				phx
.8e19	c8		iny				iny 								; skip over the type
.8e1a	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.8e1c	aa		tax				tax
.8e1d					_LPILoop:
.8e1d	c8		iny				iny
.8e1e	e0 00		cpx #$00			cpx 	#0
.8e20	f0 08		beq $8e2a			beq 	_LPIExit
.8e22	b1 02		lda ($02),y			lda 	(zTemp0),y
.8e24	20 2d 8e	jsr $8e2d			jsr 	ListPrintIDChar
.8e27	ca		dex				dex
.8e28	80 f3		bra $8e1d			bra 	_LPILoop
.8e2a					_LPIExit:
.8e2a	fa		plx				plx
.8e2b	68		pla				pla
.8e2c	60		rts				rts
.8e2d					ListPrintIDChar:
.8e2d	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.8e2f	10 0a		bpl $8e3b			bpl	 	_LCNotDot
.8e31	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.8e33	09 40		ora #$40			ora 	#$40 						; ASCII except .
.8e35	c9 5b		cmp #$5b			cmp 	#$40+27
.8e37	d0 02		bne $8e3b			bne 	_LCNotDot
.8e39	a9 2e		lda #$2e			lda 	#"."
.8e3b					_LCNotDot:
.8e3b	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.8e3e	60		rts				rts
.8e3f					ListFindLine:
.8e3f	5a		phy				phy
.8e40	86 05		stx $05				stx 	zTemp1+1
.8e42	85 04		sta $04				sta 	zTemp1
.8e44	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8e46	85 02		sta $02				sta 	zTemp0
.8e48	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.8e4a	85 03		sta $03				sta 	zTemp0+1
.8e4c					_LFLSearch:
.8e4c	18		clc				clc									; reached the end.
.8e4d	b2 02		lda ($02)			lda 	(zTemp0)
.8e4f	f0 1d		beq $8e6e			beq 	_LFLExit 					; exit with CC
.8e51	a0 01		ldy #$01			ldy 	#1
.8e53	a5 04		lda $04				lda 	zTemp1
.8e55	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8e57	d0 07		bne $8e60			bne 	_LFLNext
.8e59	c8		iny				iny
.8e5a	a5 05		lda $05				lda 	zTemp1+1
.8e5c	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8e5e	f0 0d		beq $8e6d			beq 	_LFLFound
.8e60					_LFLNext:
.8e60	18		clc				clc
.8e61	b2 02		lda ($02)			lda 	(zTemp0)
.8e63	65 02		adc $02				adc 	zTemp0
.8e65	85 02		sta $02				sta 	zTemp0
.8e67	90 e3		bcc $8e4c			bcc 	_LFLSearch
.8e69	e6 03		inc $03				inc 	zTemp0+1
.8e6b	80 df		bra $8e4c			bra 	_LFLSearch
.8e6d					_LFLFound:
.8e6d	38		sec				sec
.8e6e					_LFLExit:
.8e6e	7a		ply				ply
.8e6f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.8e70					Mem_Peek:
.8e70	fa		plx				plx
.8e71	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8e74	85 02		sta $02				sta 	zTemp0
.8e76	bd 00 07	lda $0700,x			lda 	highStack,x
.8e79	85 03		sta $03				sta 	zTemp0+1
.8e7b	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.8e7d	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.8e80	9e 00 07	stz $0700,x			stz 	highStack,x
.8e83	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8e86					Mem_WPeek:
.8e86	fa		plx				plx
.8e87	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8e8a	85 02		sta $02				sta 	zTemp0
.8e8c	bd 00 07	lda $0700,x			lda 	highStack,x
.8e8f	85 03		sta $03				sta 	zTemp0+1
.8e91	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.8e93	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.8e96	5a		phy				phy 								; read msb
.8e97	a0 01		ldy #$01			ldy 	#1
.8e99	b1 02		lda ($02),y			lda 	(zTemp0),y
.8e9b	7a		ply				ply
.8e9c	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.8e9f	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8ea2					Mem_Poke:
.8ea2	fa		plx				plx
.8ea3	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8ea6	85 02		sta $02				sta 	zTemp0
.8ea8	bd 00 07	lda $0700,x			lda 	highStack,x
.8eab	85 03		sta $03				sta 	zTemp0+1
.8ead	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8eb0	92 02		sta ($02)			sta 	(zTemp0)
.8eb2	ca		dex				dex
.8eb3	ca		dex				dex
.8eb4	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8eb7					Mem_WPoke:
.8eb7	fa		plx				plx
.8eb8	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8ebb	85 02		sta $02				sta 	zTemp0
.8ebd	bd 00 07	lda $0700,x			lda 	highStack,x
.8ec0	85 03		sta $03				sta 	zTemp0+1
.8ec2	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8ec5	92 02		sta ($02)			sta 	(zTemp0)
.8ec7	5a		phy				phy
.8ec8	a0 01		ldy #$01			ldy 	#1
.8eca	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.8ecd	91 02		sta ($02),y			sta 	(zTemp0),y
.8ecf	7a		ply				ply
.8ed0	ca		dex				dex
.8ed1	ca		dex				dex
.8ed2	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8ed5					Mem_DWPoke:
.8ed5	fa		plx				plx
.8ed6	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8ed9	85 02		sta $02				sta 	zTemp0
.8edb	bd 00 07	lda $0700,x			lda 	highStack,x
.8ede	85 03		sta $03				sta 	zTemp0+1
.8ee0	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8ee3	92 02		sta ($02)			sta 	(zTemp0)
.8ee5	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.8ee8	92 02		sta ($02)			sta 	(zTemp0)
.8eea	ca		dex				dex
.8eeb	ca		dex				dex
.8eec	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8eef					Mem_Alloc:
.8eef	fa		plx				plx
.8ef0	38		sec				sec 								; subtract count from alloc ptr
.8ef1	a5 11		lda $11				lda 	allocPtr
.8ef3	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.8ef6	85 11		sta $11				sta 	allocPtr
.8ef8	48		pha				pha 								; save low.
.8ef9	a5 12		lda $12				lda 	allocPtr+1
.8efb	fd 00 07	sbc $0700,x			sbc 	highStack,x
.8efe	85 12		sta $12				sta 	allocPtr+1
.8f00	90 10		bcc $8f12			bcc 	_MAError 					; borrow ?
.8f02	c5 14		cmp $14				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.8f04	90 0c		bcc $8f12			bcc 	_MAError
.8f06	f0 0a		beq $8f12			beq 	_MAError
.8f08	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.8f0b	68		pla				pla
.8f0c	9d 00 06	sta $0600,x			sta 	lowStack,x
.8f0f	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8f12					_MAError:
.8f12	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8f15	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/saveload.asm

.8f1d					System_Save:
.8f1d	fa		plx				plx
.8f1e	da		phx				phx
.8f1f	20 14 88	jsr $8814			jsr 	ResetVarMemory 				; make sure start/end are right
.8f22	20 49 8f	jsr $8f49			jsr 	SLGetFileName 				; get filename -> zTemp0
.8f25	a5 13		lda $13				lda 	memVarPtr 					; end address
.8f27	85 04		sta $04				sta 	zTemp1
.8f29	a5 14		lda $14				lda 	memVarPtr+1
.8f2b	85 05		sta $05				sta 	zTemp1+1
.8f2d	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.8f2f	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.8f31	20 4c 86	jsr $864c			jsr 	ExternSave
.8f34	7a		ply				ply
.8f35	4c 1b 80	jmp $801b			jmp 	WarmStart
.8f38					System_Load:
.8f38	fa		plx				plx
.8f39	20 49 8f	jsr $8f49			jsr 	SLGetFileName 				; get filename -> zTemp0
.8f3c	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.8f3e	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.8f40	20 82 86	jsr $8682			jsr 	ExternLoad
.8f43	20 f6 87	jsr $87f6			jsr 	ResetMemory 				; reset everything.
.8f46	4c 1b 80	jmp $801b			jmp 	WarmStart
.8f49					SLGetFileName:
.8f49	e0 ff		cpx #$ff			cpx 	#255 						; gotta be something on the stack
.8f4b	f0 4a		beq $8f97			beq 	_SLFNFail
.8f4d	bd 00 07	lda $0700,x			lda 	highStack,x 				; should be something in token buffer
.8f50	c9 0a		cmp #$0a			cmp 	#TokenBuffer >> 8
.8f52	d0 43		bne $8f97			bne 	_SLFNFail
.8f54	85 05		sta $05				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.8f56	bd 00 06	lda $0600,x			lda 	lowStack,x
.8f59	85 04		sta $04				sta 	zTemp1
.8f5b	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.8f5d	85 02		sta $02				sta 	zTemp0
.8f5f	a9 08		lda #$08			lda 	#InputBuffer >> 8
.8f61	85 03		sta $03				sta 	zTemp0+1
.8f63	b2 04		lda ($04)			lda 	(zTemp1) 					; copy string to input buffer
.8f65	1a		inc a				inc 	a
.8f66	aa		tax				tax
.8f67	a0 00		ldy #$00			ldy 	#0
.8f69	b1 04		lda ($04),y	_SLCopy:lda 	(zTemp1),y
.8f6b	91 02		sta ($02),y			sta 	(zTemp0),y
.8f6d	c8		iny				iny
.8f6e	ca		dex				dex
.8f6f	d0 f8		bne $8f69			bne 	_SLCopy
.8f71	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.8f73					_SLCheckEnd:
.8f73	88		dey				dey
.8f74	bd a7 8f	lda $8fa7,x			lda 	_SLFNExtension,x
.8f77	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8f79	d0 05		bne $8f80			bne 	_SLNoExtension
.8f7b	ca		dex				dex
.8f7c	10 f5		bpl $8f73			bpl 	_SLCheckEnd
.8f7e	80 16		bra $8f96			bra 	_SLExit
.8f80					_SLNoExtension:
.8f80	a0 00		ldy #$00			ldy 	#0							; add the extension.
.8f82					_SLExtend:
.8f82	ee 00 08	inc $0800			inc 	InputBuffer
.8f85	ae 00 08	ldx $0800			ldx 	InputBuffer
.8f88	b9 a7 8f	lda $8fa7,y			lda 	_SLFNExtension,y
.8f8b	c8		iny				iny
.8f8c	9d 00 08	sta $0800,x			sta 	InputBuffer,x
.8f8f	c9 00		cmp #$00			cmp		#0
.8f91	d0 ef		bne $8f82			bne 	_SLExtend
.8f93	ce 00 08	dec $0800			dec 	InputBuffer 				; because wrote the $00
.8f96					_SLExit:
.8f96	60		rts				rts
.8f97					_SLFNFail:
.8f97	20 9a 84	jsr $849a			jsr 	ErrorHandler
>8f9a	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>8fa2	4e 41 4d 45 00
.8fa7					_SLFNExtension:
>8fa7	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.8fac					Stack_Empty:
.8fac	fa		plx				plx
.8fad	a2 00		ldx #$00			ldx 	#0
.8faf	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8fb2					Stack_Drop:
.8fb2	fa		plx				plx
.8fb3	ca		dex				dex
.8fb4	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8fb7					Stack_Dup:
.8fb7	fa		plx				plx
.8fb8	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.8fbb	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.8fbe	bd 00 07	lda $0700,x			lda 	highStack,x
.8fc1	9d 01 07	sta $0701,x			sta 	highStack+1,x
.8fc4	e8		inx				inx 								; bump stack pointer
.8fc5	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8fc8					Stack_Nip:
.8fc8	fa		plx				plx
.8fc9	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.8fcc	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.8fcf	bd 00 07	lda $0700,x			lda 	highStack,x
.8fd2	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.8fd5	ca		dex				dex 								; drop tos
.8fd6	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8fd9					Stack_Over:
.8fd9	fa		plx				plx
.8fda	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.8fdd	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.8fe0	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.8fe3	9d 01 07	sta $0701,x			sta 	highStack+1,x
.8fe6	e8		inx				inx 							; bump stack pointer
.8fe7	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.8fea					Stack_Swap:
.8fea	fa		plx				plx
.8feb	5a		phy				phy
.8fec	bd 00 06	lda $0600,x			lda 	lowStack,x
.8fef	a8		tay				tay
.8ff0	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.8ff3	9d 00 06	sta $0600,x			sta 	lowStack,x
.8ff6	98		tya				tya
.8ff7	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.8ffa	bd 00 07	lda $0700,x			lda 	highStack,x
.8ffd	a8		tay				tay
.8ffe	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.9001	9d 00 07	sta $0700,x			sta 	highStack,x
.9004	98		tya				tya
.9005	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.9008	7a		ply				ply
.9009	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.900c					Command_Store:
.900c	fa		plx				plx
.900d	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.900f	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.9011	90 1f		bcc $9032			bcc 	_CSLongVariable
.9013	c8		iny				iny 								; get the next
.9014	b1 00		lda ($00),y			lda 	(codePtr),y
.9016	88		dey				dey
.9017	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.9019	f0 17		beq $9032			beq 	_CSLongVariable
.901b	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.901d	c8		iny				iny 								; skip over it and push on stack
.901e	5a		phy				phy
.901f	0a		asl a				asl 	a 							; double it, now C0-FE
.9020	a8		tay				tay 								; put in Y
.9021	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.9024	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.9027	bd 00 07	lda $0700,x			lda 	highStack,x
.902a	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.902d	ca		dex				dex 								; pop off stack
.902e	7a		ply				ply 								; restore position and do next
.902f	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9032					_CSLongVariable:
.9032	38		sec				sec 								; create variable if not found.
.9033	20 4a 89	jsr $894a			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.9036	20 bd 86	jsr $86bd			jsr 	IndexCheck 					; check indexing.
.9039	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.903c	92 02		sta ($02)			sta 	(zTemp0)
.903e	5a		phy				phy
.903f	a0 01		ldy #$01			ldy 	#1
.9041	bd 00 07	lda $0700,x			lda 	highStack,x
.9044	91 02		sta ($02),y			sta 	(zTemp0),y
.9046	7a		ply				ply
.9047	ca		dex				dex 								; pop off stack
.9048	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.904b					Command_New:
.904b	fa		plx				plx
.904c	9c 00 10	stz $1000			stz 	ProgramStart
.904f	4c 1b 80	jmp $801b			jmp 	WarmStart
.9052					Command_Old:
.9052	fa		plx				plx
.9053	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.9055	85 00		sta $00				sta 	codePtr
.9057	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.9059	85 01		sta $01				sta 	codePtr+1
.905b	a0 03		ldy #$03			ldy 	#3
.905d					_COAdvance:
.905d	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.905f	b0 0e		bcs $906f			bcs		_COFail
.9061	20 83 94	jsr $9483			jsr 	AdvanceInCode
.9064	b1 00		lda ($00),y			lda 	(codePtr),y
.9066	d0 f5		bne $905d			bne 	_COAdvance
.9068	c8		iny				iny 								; byte after end of line
.9069	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.906c					_CONotDeleted:
.906c	4c 1b 80	jmp $801b			jmp 	WarmStart
.906f					_COFail:
.906f	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9072	43 41 4e 54 3f 00				.text 	"CANT?",0
.9078					Command_End:
.9078	fa		plx				plx
.9079	4c 1b 80	jmp $801b			jmp 	WarmStart
.907c					Command_Stop:
>907c	ff						.byte 	$FF
.907d	fa		plx				plx
.907e	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9081	53 54 4f 50 00					.text 	"STOP",0
.9086					Command_Assert:
.9086	fa		plx				plx
.9087	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.908a	1d 00 07	ora $0700,x			ora 	highStack,x
.908d	f0 04		beq $9093			beq 	_CAFail
.908f	ca		dex				dex 								; throw if not.
.9090	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9093					_CAFail:
.9093	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9096	41 53 53 45 52 54 00				.text 	"ASSERT",0
.909d					Command_Sys:
.909d	fa		plx				plx
.909e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.90a1	85 02		sta $02				sta 	zTemp0
.90a3	bd 00 07	lda $0700,x			lda 	highStack,x
.90a6	85 03		sta $03				sta 	zTemp0+1
.90a8	ca		dex				dex 								; pop tos
.90a9	da		phx				phx 								; save XY
.90aa	5a		phy				phy
.90ab	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.90ae	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.90b1	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.90b4	20 bc 90	jsr $90bc			jsr 	_CSCallInd
.90b7	7a		ply				ply 								; restore XY
.90b8	fa		plx				plx
.90b9	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.90bc					_CSCallInd:
.90bc	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.90bf					Command_DumpStack:
.90bf	fa		plx				plx
.90c0	da		phx				phx 								; save pos and sp
.90c1	5a		phy				phy
.90c2	86 10		stx $10				stx 	SignCount
.90c4	a2 ff		ldx #$ff			ldx 	#$FF
.90c6					_CDSLoop:
.90c6	e4 10		cpx $10				cpx 	SignCount 					; done all ?
.90c8	f0 2a		beq $90f4			beq 	_CDSExit
.90ca	e8		inx				inx
.90cb	da		phx				phx 								; save SP
.90cc	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.90cf	a8		tay				tay
.90d0	bd 00 06	lda $0600,x			lda 	lowStack,x
.90d3	aa		tax				tax
.90d4	c0 00		cpy #$00			cpy 	#0
.90d6	10 11		bpl $90e9			bpl 	_CDSPositive
.90d8	a9 2d		lda #$2d			lda 	#"-" 						; minus
.90da	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.90dd	98		tya				tya 								; negate YX
.90de	49 ff		eor #$ff			eor 	#$FF
.90e0	a8		tay				tay
.90e1	8a		txa				txa
.90e2	49 ff		eor #$ff			eor 	#$FF
.90e4	aa		tax				tax
.90e5	e8		inx				inx
.90e6	d0 01		bne $90e9			bne 	_CDSPositive
.90e8	c8		iny				iny
.90e9					_CDSPositive:
.90e9	20 c7 84	jsr $84c7			jsr 	PrintIntegerUnsigned
.90ec	a9 20		lda #$20			lda 	#" " 						; space
.90ee	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.90f1	fa		plx				plx
.90f2	80 d2		bra $90c6			bra 	_CDSLoop
.90f4					_CDSExit:
.90f4	a9 3c		lda #$3c			lda 	#"<"
.90f6	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.90f9	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.90fc	a9 0d		lda #$0d			lda 	#13 						; CR
.90fe	20 e4 84	jsr $84e4			jsr 	PrintCharacter
.9101	7a		ply				ply
.9102	fa		plx				plx
.9103	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.9106					Stack_Add:
.9106	fa		plx				plx
.9107	ca		dex				dex
.9108	18		clc				clc
.9109	bd 00 06	lda $0600,x			lda		lowStack,x
.910c	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.910f	9d 00 06	sta $0600,x			sta 	lowStack,x
.9112	bd 00 07	lda $0700,x			lda		highStack,x
.9115	7d 01 07	adc $0701,x			adc 	highStack+1,x
.9118	9d 00 07	sta $0700,x			sta 	highStack,x
.911b	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.911e					Stack_Sub:
.911e	fa		plx				plx
.911f	ca		dex				dex
.9120	38		sec				sec
.9121	bd 00 06	lda $0600,x			lda		lowStack,x
.9124	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.9127	9d 00 06	sta $0600,x			sta 	lowStack,x
.912a	bd 00 07	lda $0700,x			lda		highStack,x
.912d	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.9130	9d 00 07	sta $0700,x			sta 	highStack,x
.9133	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9136					Stack_And:
.9136	fa		plx				plx
.9137	ca		dex				dex
.9138	bd 00 06	lda $0600,x			lda		lowStack,x
.913b	3d 01 06	and $0601,x			and		lowStack+1,x
.913e	9d 00 06	sta $0600,x			sta 	lowStack,x
.9141	bd 00 07	lda $0700,x			lda		highStack,x
.9144	3d 01 07	and $0701,x			and 	highStack+1,x
.9147	9d 00 07	sta $0700,x			sta 	highStack,x
.914a	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.914d					Stack_Xor:
.914d	fa		plx				plx
.914e	ca		dex				dex
.914f	bd 00 06	lda $0600,x			lda		lowStack,x
.9152	5d 01 06	eor $0601,x			eor		lowStack+1,x
.9155	9d 00 06	sta $0600,x			sta 	lowStack,x
.9158	bd 00 07	lda $0700,x			lda		highStack,x
.915b	5d 01 07	eor $0701,x			eor 	highStack+1,x
.915e	9d 00 07	sta $0700,x			sta 	highStack,x
.9161	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9164					Stack_Or:
.9164	fa		plx				plx
.9165	ca		dex				dex
.9166	bd 00 06	lda $0600,x			lda		lowStack,x
.9169	1d 01 06	ora $0601,x			ora		lowStack+1,x
.916c	9d 00 06	sta $0600,x			sta 	lowStack,x
.916f	bd 00 07	lda $0700,x			lda		highStack,x
.9172	1d 01 07	ora $0701,x			ora 	highStack+1,x
.9175	9d 00 07	sta $0700,x			sta 	highStack,x
.9178	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.917b					Stack_Shl:
.917b	fa		plx				plx
.917c	38		sec				sec
.917d	80 02		bra $9181			bra 	StackShift
.917f					Stack_Shr:
.917f	fa		plx				plx
.9180	18		clc				clc
.9181					StackShift:
.9181	08		php				php
.9182	ca		dex				dex
.9183	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.9186	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.9188	1d 01 07	ora $0701,x			ora 	highStack+1,x
.918b	d0 19		bne $91a6			bne 	_SSZero
.918d					_SSLoop:
.918d	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.9190	30 1a		bmi $91ac			bmi 	_SSDone 					; completed ?
.9192	28		plp				plp 								; restore flag
.9193	08		php				php
.9194	b0 08		bcs $919e			bcs 	_SSLeft 					; do either shift.
.9196	5e 00 07	lsr $0700,x			lsr 	highStack,x
.9199	7e 00 06	ror $0600,x			ror 	lowStack,x
.919c	80 ef		bra $918d			bra 	_SSLoop
.919e					_SSLeft:
.919e	1e 00 06	asl $0600,x			asl 	lowStack,x
.91a1	3e 00 07	rol $0700,x			rol 	highStack,x
.91a4	80 e7		bra $918d			bra 	_SSLoop
.91a6					_SSZero:
.91a6	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.91a9	9e 00 07	stz $0700,x			stz 	highStack,x
.91ac					_SSDone:
.91ac	28		plp				plp 								; throw flag.
.91ad	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.91b0					Comp_Equal:
.91b0	fa		plx				plx
.91b1	38		sec				sec
.91b2	80 02		bra $91b6			bra 	Comp_CheckEqual
.91b4					Comp_NotEqual:
.91b4	fa		plx				plx
.91b5	18		clc				clc
.91b6					Comp_CheckEqual:
.91b6	08		php				php
.91b7	ca		dex				dex
.91b8	bd 00 06	lda $0600,x			lda		lowStack,x
.91bb	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.91be	d0 06		bne $91c6			bne 	_CCENonZero
.91c0	bd 00 07	lda $0700,x			lda		highStack,x
.91c3	5d 01 07	eor $0701,x			eor 	highStack+1,x
.91c6					_CCENonZero:
.91c6	f0 02		beq $91ca			beq 	_CCENotSet
.91c8	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.91ca					_CCENotSet:
.91ca					CompCheckFlip:
.91ca	28		plp				plp 								; if carry set, we want $FF if equal
.91cb	90 02		bcc $91cf			bcc 	CompReturn
.91cd	49 ff		eor #$ff			eor 	#$FF
.91cf					CompReturn:
.91cf	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.91d2	9d 00 07	sta $0700,x			sta 	highStack,x
.91d5	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.91d8					Comp_Less:
.91d8	fa		plx				plx
.91d9	18		clc				clc
.91da	80 02		bra $91de			bra 	Comp_LessCont
.91dc					Comp_GreaterEqual:
.91dc	fa		plx				plx
.91dd	38		sec				sec
.91de					Comp_LessCont:
.91de	08		php				php
.91df	ca		dex				dex
.91e0	38		sec				sec
.91e1	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.91e4	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.91e7	bd 00 07	lda $0700,x			lda 	highStack,x
.91ea	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.91ed	50 02		bvc $91f1			bvc 	_CLNoFlip 					; unsigned -> signed
.91ef	49 80		eor #$80			eor 	#$80
.91f1					_CLNoFlip:
.91f1	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.91f3	f0 d5		beq $91ca			beq 	CompCheckFlip
.91f5	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.91f7	80 d1		bra $91ca			bra 	CompCheckFlip
.91f9					Comp_LessEqual:
.91f9	fa		plx				plx
.91fa	38		sec				sec
.91fb	80 02		bra $91ff			bra 	Comp_LessEqualCont
.91fd					Comp_Greater:
.91fd	fa		plx				plx
.91fe	18		clc				clc
.91ff					Comp_LessEqualCont:
.91ff	08		php				php
.9200	ca		dex				dex
.9201	38		sec				sec
.9202	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.9205	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.9208	bd 01 07	lda $0701,x			lda 	highStack+1,x
.920b	fd 00 07	sbc $0700,x			sbc 	highStack,x
.920e	50 02		bvc $9212			bvc 	_CLENoFlip 					; unsigned -> signed
.9210	49 80		eor #$80			eor 	#$80
.9212					_CLENoFlip:
.9212	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.9214	f0 b4		beq $91ca			beq 	CompCheckFlip
.9216	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.9218	80 b0		bra $91ca			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.921a					DivInteger16:
.921a	fa		plx				plx
.921b	20 21 92	jsr $9221			jsr 	IntegerDivide
.921e	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9221					IntegerDivide:
.9221	ca		dex				dex
.9222	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.9225	1d 01 07	ora $0701,x			ora 	highStack+1,x
.9228	d0 14		bne $923e			bne 	_BFDOkay
.922a	20 9a 84	jsr $849a			jsr 	ErrorHandler
>922d	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>9235	20 42 59 20 5a 45 52 4f 00
.923e					_BFDOkay:
.923e	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.9240	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.9242	64 10		stz $10				stz 	SignCount 					; Count of signs.
.9244	20 80 92	jsr $9280			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.9247	e8		inx				inx
.9248	20 80 92	jsr $9280			jsr 	CheckIntegerNegate
.924b	ca		dex				dex
.924c	5a		phy				phy 								; Y is the counter
.924d	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.924f					_BFDLoop:
.924f	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.9252	3e 00 07	rol $0700,x			rol 	highStack,x
.9255	26 04		rol $04				rol 	zTemp1
.9257	26 05		rol $05				rol 	zTemp1+1
.9259	38		sec				sec
.925a	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.925c	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.925f	48		pha				pha
.9260	a5 05		lda $05				lda 	zTemp1+1
.9262	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.9265	90 0f		bcc $9276			bcc 	_BFDNoAdd
.9267	85 05		sta $05				sta 	zTemp1+1
.9269	68		pla				pla
.926a	85 04		sta $04				sta 	zTemp1+0
.926c	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.926f	09 01		ora #$01			ora 	#1
.9271	9d 00 06	sta $0600,x			sta 	lowStack,x
.9274	80 01		bra $9277			bra 	_BFDNext
.9276					_BFDNoAdd:
.9276	68		pla				pla 								; Throw away the intermediate calculations
.9277					_BFDNext:
.9277	88		dey				dey
.9278	d0 d5		bne $924f			bne 	_BFDLoop
.927a	7a		ply				ply 								; restore Y
.927b	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.927d	b0 07		bcs $9286			bcs		IntegerNegateAlways 		; negate the result
.927f	60		rts				rts
.9280					CheckIntegerNegate:
.9280	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.9283	30 01		bmi $9286			bmi 	IntegerNegateAlways 		; if so negate it
.9285	60		rts				rts
.9286					IntegerNegateAlways:
.9286	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.9288	4c e3 92	jmp $92e3			jmp 	Unary_Negate
.928b					ModInteger16:
.928b	fa		plx				plx
.928c	20 21 92	jsr $9221			jsr 	IntegerDivide
.928f	a5 04		lda $04				lda 	zTemp1
.9291	9d 00 06	sta $0600,x			sta 	lowStack,x
.9294	a5 05		lda $05				lda 	zTemp1+1
.9296	9d 00 07	sta $0700,x			sta 	highStack,x
.9299	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.929c					MulInteger16:
.929c	fa		plx				plx
.929d	ca		dex				dex
.929e	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.92a1	85 04		sta $04				sta 	zTemp1
.92a3	bd 00 07	lda $0700,x			lda 	highStack,x
.92a6	85 05		sta $05				sta 	zTemp1+1
.92a8	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.92ab	9e 00 07	stz $0700,x			stz 	highStack,x
.92ae					_BFMMultiply:
.92ae	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.92b0	29 01		and #$01			and 	#1
.92b2	f0 13		beq $92c7			beq 	_BFMNoAdd
.92b4	18		clc				clc 								; add old tos to current tos.
.92b5	bd 00 06	lda $0600,x			lda		lowStack,x
.92b8	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.92bb	9d 00 06	sta $0600,x			sta 	lowStack,x
.92be	bd 00 07	lda $0700,x			lda		highStack,x
.92c1	7d 01 07	adc $0701,x			adc 	highStack+1,x
.92c4	9d 00 07	sta $0700,x			sta 	highStack,x
.92c7					_BFMNoAdd:
.92c7	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.92ca	3e 01 07	rol $0701,x			rol 	highStack+1,x
.92cd	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.92cf	66 04		ror $04				ror 	zTemp1+0
.92d1	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.92d3	05 05		ora $05				ora 	zTemp1+1
.92d5	d0 d7		bne $92ae			bne 	_BFMMultiply
.92d7	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.92da					Unary_Absolute:
.92da	fa		plx				plx
.92db	bd 00 07	lda $0700,x			lda 	highStack,x
.92de	30 04		bmi $92e4			bmi 	Unary_Negate_Code
.92e0	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.92e3					Unary_Negate:
.92e3	fa		plx				plx
.92e4					Unary_Negate_Code:
.92e4	38		sec				sec
.92e5	a9 00		lda #$00			lda		#0
.92e7	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.92ea	9d 00 06	sta $0600,x			sta 	lowStack,x
.92ed	a9 00		lda #$00			lda		#0
.92ef	fd 00 07	sbc $0700,x			sbc 	highStack,x
.92f2	9d 00 07	sta $0700,x			sta 	highStack,x
.92f5	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.92f8					Unary_Not:
.92f8	fa		plx				plx
.92f9	bd 00 06	lda $0600,x			lda 	lowStack,x
.92fc	49 ff		eor #$ff			eor 	#$FF
.92fe	9d 00 06	sta $0600,x			sta 	lowStack,x
.9301	bd 00 07	lda $0700,x			lda 	highStack,x
.9304	49 ff		eor #$ff			eor 	#$FF
.9306	9d 00 07	sta $0700,x			sta 	highStack,x
.9309	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.930c					Unary_Increment:
.930c	fa		plx				plx
.930d	fe 00 06	inc $0600,x			inc 	lowStack,x
.9310	d0 03		bne $9315			bne 	_UIExit
.9312	fe 00 07	inc $0700,x			inc 	highStack,x
.9315					_UIExit:
.9315	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9318					Unary_Decrement:
.9318	fa		plx				plx
.9319	bd 00 06	lda $0600,x			lda 	lowStack,x
.931c	d0 03		bne $9321			bne 	_UDNoBorrow
.931e	de 00 07	dec $0700,x			dec 	highStack,x
.9321					_UDNoBorrow:
.9321	de 00 06	dec $0600,x			dec 	lowStack,x
.9324	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9327					Unary_BSwap:
.9327	fa		plx				plx
.9328	bd 00 06	lda $0600,x			lda 	lowStack,x
.932b	48		pha				pha
.932c	bd 00 07	lda $0700,x			lda 	highStack,x
.932f	9d 00 06	sta $0600,x			sta 	lowStack,x
.9332	68		pla				pla
.9333	9d 00 07	sta $0700,x			sta 	highStack,x
.9336	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9339					Unary_Shl:
.9339	fa		plx				plx
.933a	1e 00 06	asl $0600,x			asl 	lowStack,x
.933d	3e 00 07	rol $0700,x			rol 	highStack,x
.9340	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9343					Unary_Shr:
.9343	fa		plx				plx
.9344	5e 00 07	lsr $0700,x			lsr 	highStack,x
.9347	7e 00 06	ror $0600,x			ror 	lowStack,x
.934a	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.934d					Unary_Sgn:
.934d	fa		plx				plx
.934e	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.9351	10 0a		bpl $935d			bpl 	_USNotNeg
.9353	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.9355	9d 00 06	sta $0600,x			sta 	lowStack,x
.9358	9d 00 07	sta $0700,x			sta 	highStack,x
.935b	80 10		bra $936d			bra 	_USExit
.935d					_USNotNeg:
.935d	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.9360	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.9363	9e 00 07	stz $0700,x			stz 	highStack,x
.9366	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.9368	f0 03		beq $936d			beq 	_USExit
.936a	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.936d					_USExit:
.936d	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9370					Random_Handler:
.9370	fa		plx				plx
.9371	a5 15		lda $15				lda 	randomSeed
.9373	05 16		ora $16				ora 	randomSeed+1
.9375	d0 08		bne $937f			bne 	_RH_NoInit
.9377	a9 7c		lda #$7c			lda 	#$7C
.9379	85 15		sta $15				sta 	randomSeed
.937b	a9 a1		lda #$a1			lda 	#$A1
.937d	85 16		sta $16				sta 	randomSeed+1
.937f					_RH_NoInit:
.937f	a5 15		lda $15				lda 	randomSeed
.9381	4a		lsr a		        lsr		a
.9382	26 16		rol $16		        rol 	randomSeed+1
.9384	90 02		bcc $9388	        bcc 	_RH_NoEor
.9386	49 b4		eor #$b4	        eor 	#$B4
.9388					_RH_NoEor:
.9388	85 15		sta $15		        sta 	randomSeed
.938a	45 16		eor $16		        eor 	randomSeed+1
.938c	e8		inx		        inx
.938d	9d 00 07	sta $0700,x	        sta 	highStack,x
.9390	a5 15		lda $15		        lda 	randomSeed
.9392	9d 00 06	sta $0600,x	        sta 	lowStack,x
.9395	4c 08 85	jmp $8508			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.9398					Command_Call:
.9398	fa		plx				plx
.9399	20 4f 88	jsr $884f			jsr 	StackPushPosition 				; save stack position
.939c	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.939e	20 3f 88	jsr $883f			jsr 	StackPushByte
.93a1	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.93a3	85 02		sta $02				sta 	zTemp0
.93a5	c8		iny				iny
.93a6	b1 00		lda ($00),y			lda 	(codePtr),y
.93a8	85 03		sta $03				sta 	zTemp0+1
.93aa	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.93ac	85 00		sta $00				sta 	codePtr
.93ae	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.93b0	85 01		sta $01				sta 	codePtr+1
.93b2	a0 01		ldy #$01			ldy 	#1
.93b4					_CCSearch:
.93b4	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.93b6	f0 2d		beq $93e5			beq		_CCFail
.93b8	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.93ba	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.93bc	f0 0d		beq $93cb			beq 	_CCCheckMSB
.93be	18		clc				clc 									; forward to next line.
.93bf	b2 00		lda ($00)			lda 	(codePtr)
.93c1	65 00		adc $00				adc 	codePtr
.93c3	85 00		sta $00				sta 	codePtr
.93c5	90 ed		bcc $93b4			bcc 	_CCSearch
.93c7	e6 01		inc $01				inc 	codePtr+1
.93c9	80 e9		bra $93b4			bra 	_CCSearch
.93cb					_CCCheckMSB:
.93cb	c8		iny				iny 									; get MSB, keeping Y as 1
.93cc	b1 00		lda ($00),y			lda 	(codePtr),y
.93ce	88		dey				dey
.93cf	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.93d1	d0 e1		bne $93b4			bne 	_CCSearch
.93d3	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.93d5	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.93d7	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.93d9	d0 0a		bne $93e5			bne 	_CCFail
.93db	c8		iny				iny 									; get the length of this.
.93dc	b1 00		lda ($00),y			lda 	(codePtr),y
.93de	18		clc				clc
.93df	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.93e1	a8		tay				tay
.93e2	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.93e5					_CCFail:
.93e5	20 9a 84	jsr $849a			jsr 	ErrorHandler
>93e8	43 41 4c 4c 3f 00				.text 	"CALL?",0
.93ee					Command_Return:
.93ee	fa		plx				plx
.93ef	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.93f1	20 5e 88	jsr $885e			jsr 	StackCheckTop
.93f4	90 0f		bcc $9405			bcc 	_CRFail
.93f6	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.93f8	20 6c 88	jsr $886c			jsr 	StackRestorePosition
.93fb	c8		iny				iny
.93fc	c8		iny				iny
.93fd	a9 04		lda #$04			lda 	#4 								; pop off stack
.93ff	20 66 88	jsr $8866			jsr 	StackPop
.9402	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9405					_CRFail:
.9405	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9408	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.940e					Structure_If:
.940e	fa		plx				plx
.940f	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.9411	20 3f 88	jsr $883f			jsr 	StackPushByte
.9414	18		clc				clc
.9415	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.9418	1d 00 07	ora $0700,x			ora 	highStack,x
.941b	ca		dex				dex 									; drop TOS
.941c	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.941e	d0 0e		bne $942e			bne 	_SIFNoSkip 						; at this level.
.9420	da		phx				phx
.9421	a9 38		lda #$38			lda 	#KWD_ELSE
.9423	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.9425	20 5b 94	jsr $945b			jsr 	StructSkipForward
.9428	fa		plx				plx 									; restore X
.9429	c9 38		cmp #$38			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.942b	d0 01		bne $942e			bne 	_SIFNoSkip 						; clause.
.942d	c8		iny				iny
.942e					_SIFNoSkip:
.942e	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9431					Structure_Else:
.9431	fa		plx				plx
.9432	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.9434	20 5e 88	jsr $885e			jsr 	StackCheckTop
.9437	90 0b		bcc $9444			bcc 	SIFail
.9439	da		phx				phx 									; got here by executing IF clause so skip
.943a	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.943c	aa		tax				tax
.943d	20 5b 94	jsr $945b			jsr 	StructSkipForward
.9440	fa		plx				plx
.9441	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9444					SIFail:
.9444	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9447	49 46 3f 00					.text 	"IF?",0
.944b					Structure_Endif:
.944b	fa		plx				plx
.944c	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.944e	20 5e 88	jsr $885e			jsr 	StackCheckTop
.9451	90 f1		bcc $9444			bcc 	SIFail
.9453	a9 01		lda #$01			lda 	#1 								; throw it.
.9455	20 66 88	jsr $8866			jsr 	StackPop
.9458	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.945b					StructSkipForward:
.945b	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.945d	86 03		stx $03				stx 	zTemp0+1
.945f	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.9461					_SSFLoop:
.9461	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.9463	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.9465	d0 08		bne $946f			bne		_SSFFail
.9467	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.9469	f0 17		beq $9482			beq 	_SSFEnd
.946b	c5 03		cmp $03				cmp 	zTemp0+1
.946d	f0 13		beq $9482			beq 	_SSFEnd
.946f					_SSFFail:
.946f	20 83 94	jsr $9483			jsr 	AdvanceInCode 					; skip over in code.
.9472	b0 ed		bcs $9461			bcs 	_SSFLoop 						; if not end of program, keep going.
.9474	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9477	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>947f	45 3f 00
.9482					_SSFEnd:
.9482	60		rts				rts
.9483					AdvanceInCode:
.9483	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.9485	f0 28		beq $94af			beq 	_AICEndOfLine 					; end of line.
.9487	c8		iny				iny 									; advance one.
.9488	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.948a	90 10		bcc $949c			bcc 	_AICControl
.948c	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.948e	b0 0a		bcs $949a			bcs 	_AICExit
.9490	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.9492	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.9494	90 04		bcc $949a			bcc 	_AICExit
.9496	c6 04		dec $04				dec 	zTemp1
.9498	c6 04		dec $04				dec 	zTemp1
.949a					_AICExit:
.949a	38		sec				sec
.949b	60		rts				rts
.949c					_AICControl:
.949c	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.949e	f0 0b		beq $94ab			beq 	_AICThree
.94a0	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.94a2	f0 07		beq $94ab			beq 	_AICThree
.94a4	98		tya				tya										; skip over a string/comment/define.
.94a5	38		sec				sec
.94a6	71 00		adc ($00),y			adc 	(codePtr),y
.94a8	a8		tay				tay
.94a9	38		sec				sec
.94aa	60		rts				rts
.94ab					_AICThree:
.94ab	c8		iny				iny
.94ac	c8		iny				iny
.94ad	38		sec				sec
.94ae	60		rts				rts
.94af					_AICEndOfLine:
.94af	18		clc				clc 									; forward to next line.
.94b0	b2 00		lda ($00)			lda 	(codePtr)
.94b2	65 00		adc $00				adc 	codePtr
.94b4	85 00		sta $00				sta 	codePtr
.94b6	90 02		bcc $94ba			bcc 	_AICNoCarry
.94b8	e6 01		inc $01				inc 	codePtr+1
.94ba					_AICNoCarry:
.94ba	a0 03		ldy #$03			ldy 	#3 								; start of new line
.94bc	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.94be	d0 da		bne $949a			bne 	_AICExit
.94c0	18		clc				clc 									; program end.
.94c1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.94c2					Struct_Repeat:
.94c2	fa		plx				plx
.94c3	20 4f 88	jsr $884f			jsr 	StackPushPosition 				; save stack position
.94c6	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.94c8	20 3f 88	jsr $883f			jsr 	StackPushByte
.94cb	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.94ce					Struct_Until:
.94ce	fa		plx				plx
.94cf	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.94d1	20 5e 88	jsr $885e			jsr 	StackCheckTop
.94d4	90 1b		bcc $94f1			bcc 	_SUFail
.94d6	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.94d9	1d 00 07	ora $0700,x			ora 	highStack,x
.94dc	ca		dex				dex
.94dd	09 00		ora #$00			ora 	#0
.94df	f0 08		beq $94e9			beq 	_SULoopBack 					; if so keep going.
.94e1	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.94e3	20 66 88	jsr $8866			jsr 	StackPop
.94e6	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.94e9					_SULoopBack:
.94e9	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.94eb	20 6c 88	jsr $886c			jsr 	StackRestorePosition
.94ee	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.94f1					_SUFail:
.94f1	20 9a 84	jsr $849a			jsr 	ErrorHandler
>94f4	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>94fc	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.94fe					Struct_For:
.94fe	fa		plx				plx
.94ff	18		clc				clc
.9500	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.9503	49 ff		eor #$ff			eor 	#$FF
.9505	69 01		adc #$01			adc 	#1
.9507	08		php				php
.9508	20 3f 88	jsr $883f			jsr 	StackPushByte
.950b	bd 00 07	lda $0700,x			lda 	highStack,x
.950e	49 ff		eor #$ff			eor 	#$FF
.9510	28		plp				plp
.9511	69 00		adc #$00			adc 	#0
.9513	20 3f 88	jsr $883f			jsr 	StackPushByte
.9516	ca		dex				dex 									; throw TOS
.9517	20 4f 88	jsr $884f			jsr 	StackPushPosition 				; save stack position
.951a	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.951c	20 3f 88	jsr $883f			jsr 	StackPushByte
.951f	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9522					Struct_Index:
.9522	fa		plx				plx
.9523	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.9525	20 5e 88	jsr $885e			jsr 	StackCheckTop
.9528	90 43		bcc $956d			bcc 	SNFail
.952a	e8		inx				inx 									; new stack entry
.952b	5a		phy				phy
.952c	a0 04		ldy #$04			ldy 	#4 								; access index value
.952e	b1 0e		lda ($0e),y			lda 	(iStack),y
.9530	49 ff		eor #$ff			eor 	#$FF
.9532	9d 00 07	sta $0700,x			sta 	highStack,x
.9535	c8		iny				iny
.9536	b1 0e		lda ($0e),y			lda 	(iStack),y
.9538	49 ff		eor #$ff			eor 	#$FF
.953a	9d 00 06	sta $0600,x			sta 	lowStack,x
.953d	7a		ply				ply 									; restore code pointer
.953e	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9541					Struct_Next:
.9541	fa		plx				plx
.9542	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.9544	20 5e 88	jsr $885e			jsr 	StackCheckTop
.9547	90 24		bcc $956d			bcc 	SNFail
.9549	5a		phy				phy 									; save code position
.954a	a0 05		ldy #$05			ldy 	#5 								; bump the count
.954c	b1 0e		lda ($0e),y			lda 	(iStack),y
.954e	1a		inc a				inc 	a
.954f	91 0e		sta ($0e),y			sta 	(iStack),y
.9551	d0 11		bne $9564			bne 	_SNLoopBack
.9553	88		dey				dey
.9554	b1 0e		lda ($0e),y			lda 	(iStack),y
.9556	1a		inc a				inc 	a
.9557	91 0e		sta ($0e),y			sta 	(iStack),y
.9559	d0 09		bne $9564			bne 	_SNLoopBack  					; non-zero loop back.
.955b	7a		ply				ply 									; restore code position.
.955c	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.955e	20 66 88	jsr $8866			jsr 	StackPop
.9561	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.9564					_SNLoopBack:
.9564	7a		ply				ply 									; restore code position, being junked anyway.
.9565	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.9567	20 6c 88	jsr $886c			jsr 	StackRestorePosition
.956a	4c 08 85	jmp $8508			jmp 	ExecuteLoop
.956d					SNFail:
.956d	20 9a 84	jsr $849a			jsr 	ErrorHandler
>9570	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
