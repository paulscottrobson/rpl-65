
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Mon Nov 18 18:59:06 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer (must be on a page boundary)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					zTemp4:			.word ?
>000c					zTemp5:			.word ?
>000e					iStack:			.word ?						; stack pointer
>0010					signCount:		.byte ? 					; divide sign count.
>0011					allocPtr:		.word ? 					; memory allocation pointer (down)
>0013					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0015					randomSeed:		.word ? 					; random number seed
>0017					prefixCharacter:.byte ?						; char to print before listed element.
>0018					breakCount:		.byte ? 					; counter avoids repeated break checks
>0019					tokenOffset:	.byte ? 					; position in output token buffer.
>001a					assemblerMode:	.byte ? 					; in assembler mode ?
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	13 e8 03 03 0d 54 48 45			.byte	$13,$e8,$03,$03,$0d,$54,$48,$45,$20,$42,$41,$4c,$4c,$20,$44,$45,$4d,$4f,$00,$0c,$f2,$03,$23,$c3,$cc,$e3,$24,$02,$ec,$04,$00,$10,$fc,$03,$01,$00,$04,$21,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$56,$04,$0b,$00,$05,$24,$04,$07,$00,$12,$2e,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$9c,$04,$0b,$00,$06,$38,$04,$80,$0a,$00,$05,$42,$04,$41,$00,$23,$4c,$04,$05,$0b,$c2,$c1,$cc,$cc,$db,$d3,$c5,$cc,$c5,$c3,$f4,$2e,$2e,$2e,$2e,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$3a,$00,$29,$56,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$31,$28,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$31,$28,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$60,$04,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$31,$87,$11,$2b,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$74,$04,$3a,$00,$1c,$6a,$04,$05,$0b,$d2,$c1,$ce,$c4,$cf,$cd,$db,$d3,$c9,$c7,$ee,$31,$81,$11,$06,$81,$38,$01,$ff,$ff,$09,$3a,$00,$0f,$74,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$7e,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2e,$01,$20,$9f,$1d,$00,$0f,$88,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$92,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$3a,$00,$0f,$9c,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$a6,$04,$a0,$02,$74,$04,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ba,$04,$34,$01,$50,$00,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ce,$04,$34,$bc,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$d8,$04,$01,$51,$00,$02,$74,$04,$00,$05,$e2,$04,$3a,$00,$15,$ec,$04,$05,$05,$c3,$cc,$c5,$c1,$f2,$80,$01,$20,$9f,$1f,$90,$01,$22,$9f,$1d,$00,$0a,$f6,$04,$01,$80,$00,$bc,$0c,$08,$00,$0e,$00,$05,$a0,$01,$23,$9f,$1d,$81,$01,$23,$9f,$1d,$00,$06,$0a,$05,$0b,$3a,$00
>1008	20 42 41 4c 4c 20 44 45 4d 4f 00 0c f2 03 23 c3
>1018	cc e3 24 02 ec 04 00 10 fc 03 01 00 04 21 22 c2
>1028	c1 cc cc cd c5 ed 00 0b 06 04 a0 22 c3 cf d5 ce
>1038	f4 00 0d 10 04 01 8e 00 22 e1 01 d2 ff 25 00 12
>1048	1a 04 c3 cf d5 ce f4 08 39 02 4c 04 02 56 04 0b
>1058	00 05 24 04 07 00 12 2e 04 c3 cf d5 ce f4 08 39
>1068	02 4c 04 02 9c 04 0b 00 06 38 04 80 0a 00 05 42
>1078	04 41 00 23 4c 04 05 0b c2 c1 cc cc db d3 c5 cc
>1088	c5 c3 f4 2e 2e 2e 2e c2 c1 cc cc cd c5 ed 0f 22
>1098	c2 c1 cc ec 3a 00 29 56 04 05 09 c2 c1 cc cc db
>10a8	c9 ce c9 f4 31 28 01 50 00 0e 22 c2 c1 cc ec 23
>10b8	80 24 31 28 bc 0e 22 c2 c1 cc ec 23 81 24 00 2d
>10c8	60 04 02 6a 04 22 c2 c1 cc ec 23 82 24 02 6a 04
>10d8	22 c2 c1 cc ec 23 83 24 31 87 11 2b 22 c2 c1 cc
>10e8	ec 23 84 24 01 51 00 02 74 04 3a 00 1c 6a 04 05
>10f8	0b d2 c1 ce c4 cf cd db d3 c9 c7 ee 31 81 11 06
>1108	81 38 01 ff ff 09 3a 00 0f 74 04 05 09 c2 c1 cc
>1118	cc db c4 d2 c1 f7 00 10 7e 04 c2 c1 cc ec 23 80
>1128	24 2e 01 20 9f 1d 00 0f 88 04 c2 c1 cc ec 23 81
>1138	24 01 21 9f 1d 00 19 92 04 90 01 22 9f 1d 01 23
>1148	9f 1d c2 c1 cc ec 23 84 24 01 23 9f 1d 3a 00 0f
>1158	9c 04 05 09 c2 c1 cc cc db cd cf d6 e5 00 08 a6
>1168	04 a0 02 74 04 00 1c b0 04 c2 c1 cc ec 23 80 24
>1178	c2 c1 cc ec 23 82 24 0f 34 22 c2 c1 cc ec 23 80
>1188	24 00 1f ba 04 34 01 50 00 1a 37 80 19 12 06 c2
>1198	c1 cc ec 23 82 24 29 22 c2 c1 cc ec 23 82 24 09
>11a8	00 1c c4 04 c2 c1 cc ec 23 81 24 c2 c1 cc ec 23
>11b8	83 24 0f 34 22 c2 c1 cc ec 23 81 24 00 1d ce 04
>11c8	34 bc 1a 37 80 19 12 06 c2 c1 cc ec 23 83 24 29
>11d8	22 c2 c1 cc ec 23 83 24 09 00 0a d8 04 01 51 00
>11e8	02 74 04 00 05 e2 04 3a 00 15 ec 04 05 05 c3 cc
>11f8	c5 c1 f2 80 01 20 9f 1f 90 01 22 9f 1d 00 0a f6
>1208	04 01 80 00 bc 0c 08 00 0e 00 05 a0 01 23 9f 1d
>1218	81 01 23 9f 1d 00 06 0a 05 0b 3a 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 cc a5	jsr $a5cc			jsr 	ExternInitialise			; set up external stuff.
.a006	a2 63		ldx #$63			ldx 	#BootPrompt & $FF 			; print start up.
.a008	a0 a0		ldy #$a0			ldy 	#BootPrompt >> 8
.a00a	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a00d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.a00f	a0 8f		ldy #$8f			ldy 	#(HighMemory-ProgramStart) >> 8
.a011	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.a014	a2 80		ldx #$80			ldx 	#BootPrompt2 & $FF
.a016	a0 a0		ldy #$a0			ldy 	#BootPrompt2 >> 8
.a018	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a01b					WarmStart:
.a01b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a01d	9a		txs				txs
.a01e	20 21 a6	jsr $a621			jsr 	ExternInput					; input a line.
.a021	ad 00 08	lda $0800			lda 	InputBuffer 				; get the first character.
.a024	48		pha				pha
.a025	20 43 aa	jsr $aa43			jsr 	TokeniseInputBuffer 		; tokenise it
.a028	68		pla				pla
.a029	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.a02b	f0 0d		beq $a03a			beq 	ExecuteLine
.a02d	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.a030	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.a032	f0 0d		beq $a041			beq 	LineNumber
.a034	29 c0		and #$c0			and 	#$C0
.a036	c9 80		cmp #$80			cmp 	#$80
.a038	f0 07		beq $a041			beq 	LineNumber
.a03a					ExecuteLine:
.a03a	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.a03c	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.a03e	4c f6 a4	jmp $a4f6			jmp 	ExecuteFromXY
.a041					LineNumber:
.a041	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.a044	a2 00		ldx #$00			ldx 	#0
.a046	a0 04		ldy #$04			ldy 	#4
.a048	38		sec				sec
.a049	e9 80		sbc #$80			sbc 	#$80
.a04b	c9 40		cmp #$40			cmp 	#$40
.a04d	90 08		bcc $a057			bcc 	_HaveLineNumber
.a04f	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.a052	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.a055	a0 06		ldy #$06			ldy 	#6
.a057					_HaveLineNumber:
.a057	48		pha				pha 								; a fudge. Because you use
.a058	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.a05b	c9 3c		cmp #$3c			cmp 	#KWD_LIST 					; this to be executed and not
.a05d	f0 db		beq $a03a			beq 	ExecuteLine 				; to be code.
.a05f	68		pla				pla
.a060	4c 16 a7	jmp $a716			jmp 	EditProgram
.a063					BootPrompt:
>a063	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (19-NOV-19) ***",13,13
>a06b	36 35 20 28 31 39 2d 4e 4f 56 2d 31 39 29 20 2a
>a07b	2a 2a 0d 0d
>a07f	00						.byte 	0
.a080					BootPrompt2:
>a080	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>a088	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_HASH                       = $0027 ; #
=$0028					KWD_ABS                        = $0028 ; abs
=$0029					KWD_NEGATE                     = $0029 ; negate
=$002a					KWD_NOT                        = $002a ; not
=$002b					KWD_PLUSPLUS                   = $002b ; ++
=$002c					KWD_MINUSMINUS                 = $002c ; --
=$002d					KWD_BSWAP                      = $002d ; bswap
=$002e					KWD_LESSLESS                   = $002e ; <<
=$002f					KWD_GREATERGREATER             = $002f ; >>
=$0030					KWD_SGN                        = $0030 ; sgn
=$0031					KWD_RND                        = $0031 ; rnd
=$0032					KWD_CLR                        = $0032 ; clr
=$0033					KWD_DROP                       = $0033 ; drop
=$0034					KWD_DUP                        = $0034 ; dup
=$0035					KWD_NIP                        = $0035 ; nip
=$0036					KWD_OVER                       = $0036 ; over
=$0037					KWD_SWAP                       = $0037 ; swap
=$0038					KWD_ELSE                       = $0038 ; else
=$0039					KWD_INDEX                      = $0039 ; index
=$003a					KWD_SEMICOLON                  = $003a ; ;
=$003b					KWD_ASSERT                     = $003b ; assert
=$003c					KWD_LIST                       = $003c ; list
=$003d					KWD_NEW                        = $003d ; new
=$003e					KWD_OLD                        = $003e ; old
=$003f					KWD_STOP                       = $003f ; stop
=$0040					KWD_RUN                        = $0040 ; run
=$0041					KWD_END                        = $0041 ; end
=$0042					KWD_SAVE                       = $0042 ; save
=$0043					KWD_LOAD                       = $0043 ; load
.a094					KeywordText:
>a094	01 ff					.text $01,$ff                          ; $0000 %eol
>a096	01 ff					.text $01,$ff                          ; $0001 %const
>a098	01 ff					.text $01,$ff                          ; $0002 %call
>a09a	01 ff					.text $01,$ff                          ; $0003 %comment
>a09c	01 ff					.text $01,$ff                          ; $0004 %qstring
>a09e	01 ff					.text $01,$ff                          ; $0005 %define
>a0a0	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a0a3	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a0aa	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a0ae	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a0b4	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a0ba	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a0bf	01 aa					.text $01,$aa                          ; $000c *
>a0c1	01 af					.text $01,$af                          ; $000d /
>a0c3	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a0c7	01 ab					.text $01,$ab                          ; $000f +
>a0c9	01 ad					.text $01,$ad                          ; $0010 -
>a0cb	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a0cf	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a0d2	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a0d6	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a0da	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a0de	01 bd					.text $01,$bd                          ; $0016 =
>a0e0	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a0e3	01 be					.text $01,$be                          ; $0018 >
>a0e5	01 bc					.text $01,$bc                          ; $0019 <
>a0e7	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a0ea	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a0ed	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a0f0	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a0f3	01 c0					.text $01,$c0                          ; $001e @
>a0f5	01 a1					.text $01,$a1                          ; $001f !
>a0f7	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a0fa	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a100	01 de					.text $01,$de                          ; $0022 ^
>a102	01 db					.text $01,$db                          ; $0023 [
>a104	01 dd					.text $01,$dd                          ; $0024 ]
>a106	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a10a	01 bf					.text $01,$bf                          ; $0026 ?
>a10c	01 a3					.text $01,$a3                          ; $0027 #
>a10e	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0028 abs
>a112	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0029 negate
>a119	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $002a not
>a11d	02 2b ab				.text $02,$2b,$ab                      ; $002b ++
>a120	02 2d ad				.text $02,$2d,$ad                      ; $002c --
>a123	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002d bswap
>a129	02 3c bc				.text $02,$3c,$bc                      ; $002e <<
>a12c	02 3e be				.text $02,$3e,$be                      ; $002f >>
>a12f	03 53 47 ce				.text $03,$53,$47,$ce                  ; $0030 sgn
>a133	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0031 rnd
>a137	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0032 clr
>a13b	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0033 drop
>a140	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0034 dup
>a144	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0035 nip
>a148	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0036 over
>a14d	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0037 swap
>a152	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0038 else
>a157	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0039 index
>a15d	01 bb					.text $01,$bb                          ; $003a ;
>a15f	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003b assert
>a166	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003c list
>a16b	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003d new
>a16f	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003e old
>a173	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003f stop
>a178	03 52 55 ce				.text $03,$52,$55,$ce                  ; $0040 run
>a17c	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0041 end
>a180	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0042 save
>a185	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0043 load
>a18a	00					.byte 0
>a18b						.align 2
.a18c					DispatchHandler:
>a18c	6c a5					.word ExecuteNextLine          ; $0000 %eol
>a18e	a3 a5					.word LongConstant             ; $0001 %const
>a190	97 b3					.word Command_Call             ; $0002 %call
>a192	6c a5					.word ExecuteComment           ; $0003 %comment
>a194	b4 a5					.word StringConstant           ; $0004 %qstring
>a196	94 a4					.word SyntaxError              ; $0005 %define
>a198	0d b4					.word Structure_If             ; $0006 if
>a19a	c1 b4					.word Struct_Repeat            ; $0007 repeat
>a19c	fd b4					.word Struct_For               ; $0008 for
>a19e	4a b4					.word Structure_Endif          ; $0009 endif
>a1a0	cd b4					.word Struct_Until             ; $000a until
>a1a2	40 b5					.word Struct_Next              ; $000b next
>a1a4	9b b2					.word MulInteger16             ; $000c *
>a1a6	19 b2					.word DivInteger16             ; $000d /
>a1a8	8a b2					.word ModInteger16             ; $000e mod
>a1aa	05 b1					.word Stack_Add                ; $000f +
>a1ac	1d b1					.word Stack_Sub                ; $0010 -
>a1ae	35 b1					.word Stack_And                ; $0011 and
>a1b0	63 b1					.word Stack_Or                 ; $0012 or
>a1b2	4c b1					.word Stack_Xor                ; $0013 xor
>a1b4	7a b1					.word Stack_Shl                ; $0014 shl
>a1b6	7e b1					.word Stack_Shr                ; $0015 shr
>a1b8	af b1					.word Comp_Equal               ; $0016 =
>a1ba	b3 b1					.word Comp_NotEqual            ; $0017 <>
>a1bc	fc b1					.word Comp_Greater             ; $0018 >
>a1be	d7 b1					.word Comp_Less                ; $0019 <
>a1c0	db b1					.word Comp_GreaterEqual        ; $001a >=
>a1c2	f8 b1					.word Comp_LessEqual           ; $001b <=
>a1c4	6f ae					.word Mem_Peek                 ; $001c c@
>a1c6	a1 ae					.word Mem_Poke                 ; $001d c!
>a1c8	85 ae					.word Mem_WPeek                ; $001e @
>a1ca	b6 ae					.word Mem_WPoke                ; $001f !
>a1cc	d4 ae					.word Mem_DWPoke               ; $0020 d!
>a1ce	ee ae					.word Mem_Alloc                ; $0021 alloc
>a1d0	0b b0					.word Command_Store            ; $0022 ^
>a1d2	95 a5					.word CommandAssemblerOn       ; $0023 [
>a1d4	9d a5					.word CommandAssemblerOff      ; $0024 ]
>a1d6	9c b0					.word Command_Sys              ; $0025 sys
>a1d8	be b0					.word Command_DumpStack        ; $0026 ?
>a1da	94 a4					.word SyntaxError              ; $0027 #
>a1dc	d9 b2					.word Unary_Absolute           ; $0028 abs
>a1de	e2 b2					.word Unary_Negate             ; $0029 negate
>a1e0	f7 b2					.word Unary_Not                ; $002a not
>a1e2	0b b3					.word Unary_Increment          ; $002b ++
>a1e4	17 b3					.word Unary_Decrement          ; $002c --
>a1e6	26 b3					.word Unary_BSwap              ; $002d bswap
>a1e8	38 b3					.word Unary_Shl                ; $002e <<
>a1ea	42 b3					.word Unary_Shr                ; $002f >>
>a1ec	4c b3					.word Unary_Sgn                ; $0030 sgn
>a1ee	6f b3					.word Random_Handler           ; $0031 rnd
>a1f0	ab af					.word Stack_Empty              ; $0032 clr
>a1f2	b1 af					.word Stack_Drop               ; $0033 drop
>a1f4	b6 af					.word Stack_Dup                ; $0034 dup
>a1f6	c7 af					.word Stack_Nip                ; $0035 nip
>a1f8	d8 af					.word Stack_Over               ; $0036 over
>a1fa	e9 af					.word Stack_Swap               ; $0037 swap
>a1fc	30 b4					.word Structure_Else           ; $0038 else
>a1fe	21 b5					.word Struct_Index             ; $0039 index
>a200	ed b3					.word Command_Return           ; $003a ;
>a202	85 b0					.word Command_Assert           ; $003b assert
>a204	80 ac					.word Cmd_List                 ; $003c list
>a206	4a b0					.word Command_New              ; $003d new
>a208	51 b0					.word Command_Old              ; $003e old
>a20a	7b b0					.word Command_Stop             ; $003f stop
>a20c	f2 a4					.word ExecuteProgram           ; $0040 run
>a20e	77 b0					.word Command_End              ; $0041 end
>a210	1c af					.word System_Save              ; $0042 save
>a212	37 af					.word System_Load              ; $0043 load

;******  Return to file: main.asm


;******  Processing file: generated/assembler.inc

=2					ASM_FIRST_2BYTE = 2
=10					ASM_FIRST_3BYTE = 10
=0					ASM_MODE_IMP = 0
=1					ASM_MODE_A = 1
=2					ASM_MODE_IMM = 2
=3					ASM_MODE_RL = 3
=4					ASM_MODE_ZP = 4
=5					ASM_MODE_ZX = 5
=6					ASM_MODE_ZY = 6
=7					ASM_MODE_IX = 7
=8					ASM_MODE_IY = 8
=9					ASM_MODE_IN = 9
=10					ASM_MODE_AB = 10
=11					ASM_MODE_AX = 11
=12					ASM_MODE_AY = 12
=13					ASM_MODE_IA = 13
=14					ASM_MODE_IAX = 14
.a214					LowBytes:
>a214	2b 21 00 00 42 21 4c 00			.byte $2b,$21,$00,$00,$42,$21,$4c,$00,$f0,$21,$4c,$00,$42,$21,$4c,$00,$ec,$21,$21,$00,$22,$21,$4c,$00,$63,$21,$a3,$00,$22,$21,$4c,$00,$52,$a4,$00,$00,$14,$a4,$cc,$00,$70,$a4,$cc,$00,$14,$a4,$cc,$00,$89,$a4,$a4,$00,$14,$a4,$cc,$00,$83,$a4,$83,$00,$14,$a4,$cc,$00,$69,$d2,$00,$00,$00,$d2,$52,$00,$e1,$d2,$52,$00,$90,$d2,$52,$00,$a3,$d2,$d2,$00,$00,$d2,$52,$00,$69,$d2,$f9,$00,$00,$d2,$52,$00,$73,$63,$00,$00,$7a,$63,$d2,$00,$61,$63,$d2,$00,$90,$63,$d2,$00,$b3,$63,$63,$00,$7a,$63,$d2,$00,$89,$63,$79,$00,$90,$63,$d2,$00,$21,$61,$00,$00,$79,$61,$78,$00,$99,$14,$e1,$00,$79,$61,$78,$00,$43,$61,$61,$00,$79,$61,$78,$00,$01,$61,$f3,$00,$7a,$61,$7a,$00,$79,$61,$78,$00,$79,$61,$78,$00,$19,$61,$18,$00,$79,$61,$78,$00,$53,$61,$61,$00,$79,$61,$78,$00,$76,$61,$58,$00,$79,$61,$78,$00,$f9,$90,$00,$00,$f9,$90,$83,$00,$b9,$90,$98,$00,$f9,$90,$83,$00,$a5,$90,$90,$00,$00,$90,$83,$00,$64,$90,$f8,$00,$00,$90,$83,$00,$f8,$23,$00,$00,$f8,$23,$a3,$00,$b8,$23,$d0,$00,$f8,$23,$a3,$00,$91,$23,$23,$00,$00,$23,$a3,$00,$84,$23,$78,$00,$00,$23,$a3,$00
>a21c	f0 21 4c 00 42 21 4c 00 ec 21 21 00 22 21 4c 00
>a22c	63 21 a3 00 22 21 4c 00 52 a4 00 00 14 a4 cc 00
>a23c	70 a4 cc 00 14 a4 cc 00 89 a4 a4 00 14 a4 cc 00
>a24c	83 a4 83 00 14 a4 cc 00 69 d2 00 00 00 d2 52 00
>a25c	e1 d2 52 00 90 d2 52 00 a3 d2 d2 00 00 d2 52 00
>a26c	69 d2 f9 00 00 d2 52 00 73 63 00 00 7a 63 d2 00
>a27c	61 63 d2 00 90 63 d2 00 b3 63 63 00 7a 63 d2 00
>a28c	89 63 79 00 90 63 d2 00 21 61 00 00 79 61 78 00
>a29c	99 14 e1 00 79 61 78 00 43 61 61 00 79 61 78 00
>a2ac	01 61 f3 00 7a 61 7a 00 79 61 78 00 79 61 78 00
>a2bc	19 61 18 00 79 61 78 00 53 61 61 00 79 61 78 00
>a2cc	76 61 58 00 79 61 78 00 f9 90 00 00 f9 90 83 00
>a2dc	b9 90 98 00 f9 90 83 00 a5 90 90 00 00 90 83 00
>a2ec	64 90 f8 00 00 90 83 00 f8 23 00 00 f8 23 a3 00
>a2fc	b8 23 d0 00 f8 23 a3 00 91 23 23 00 00 23 a3 00
>a30c	84 23 78 00 00 23 a3 00
.a314					HighBytes:
>a314	0b 3f 00 00 53 3f 07 00			.byte $0b,$3f,$00,$00,$53,$3f,$07,$00,$41,$3f,$07,$00,$53,$3f,$07,$00,$0a,$3f,$3f,$00,$53,$3f,$07,$00,$0e,$3f,$26,$00,$53,$3f,$07,$00,$2b,$06,$00,$00,$0a,$06,$4a,$00,$42,$06,$4a,$00,$0a,$06,$4a,$00,$0a,$06,$06,$00,$0a,$06,$4a,$00,$4d,$06,$11,$00,$0a,$06,$4a,$00,$4b,$16,$00,$00,$00,$16,$33,$00,$41,$16,$33,$00,$2a,$16,$33,$00,$0b,$16,$16,$00,$00,$16,$33,$00,$0e,$16,$41,$00,$00,$16,$33,$00,$4b,$05,$00,$00,$4f,$05,$4a,$00,$42,$05,$4a,$00,$2a,$05,$4a,$00,$0b,$05,$05,$00,$4f,$05,$4a,$00,$4d,$05,$42,$00,$2a,$05,$4a,$00,$0b,$4f,$00,$00,$4f,$4f,$4f,$00,$11,$0a,$53,$00,$4f,$4f,$4f,$00,$09,$4f,$4f,$00,$4f,$4f,$4f,$00,$54,$4f,$53,$00,$4f,$4f,$4f,$00,$31,$31,$31,$00,$31,$31,$31,$00,$51,$31,$51,$00,$31,$31,$31,$00,$09,$31,$31,$00,$31,$31,$31,$00,$0e,$31,$53,$00,$31,$31,$31,$00,$0e,$0e,$00,$00,$0e,$0e,$11,$00,$26,$0e,$11,$00,$0e,$0e,$11,$00,$0a,$0e,$0e,$00,$00,$0e,$11,$00,$0e,$0e,$41,$00,$00,$0e,$11,$00,$0e,$4d,$00,$00,$0e,$4d,$26,$00,$26,$4d,$3a,$00,$0e,$4d,$26,$00,$09,$4d,$4d,$00,$00,$4d,$26,$00,$4d,$4d,$42,$00,$00,$4d,$26,$00
>a31c	41 3f 07 00 53 3f 07 00 0a 3f 3f 00 53 3f 07 00
>a32c	0e 3f 26 00 53 3f 07 00 2b 06 00 00 0a 06 4a 00
>a33c	42 06 4a 00 0a 06 4a 00 0a 06 06 00 0a 06 4a 00
>a34c	4d 06 11 00 0a 06 4a 00 4b 16 00 00 00 16 33 00
>a35c	41 16 33 00 2a 16 33 00 0b 16 16 00 00 16 33 00
>a36c	0e 16 41 00 00 16 33 00 4b 05 00 00 4f 05 4a 00
>a37c	42 05 4a 00 2a 05 4a 00 0b 05 05 00 4f 05 4a 00
>a38c	4d 05 42 00 2a 05 4a 00 0b 4f 00 00 4f 4f 4f 00
>a39c	11 0a 53 00 4f 4f 4f 00 09 4f 4f 00 4f 4f 4f 00
>a3ac	54 4f 53 00 4f 4f 4f 00 31 31 31 00 31 31 31 00
>a3bc	51 31 51 00 31 31 31 00 09 31 31 00 31 31 31 00
>a3cc	0e 31 53 00 31 31 31 00 0e 0e 00 00 0e 0e 11 00
>a3dc	26 0e 11 00 0e 0e 11 00 0a 0e 0e 00 00 0e 11 00
>a3ec	0e 0e 41 00 00 0e 11 00 0e 4d 00 00 0e 4d 26 00
>a3fc	26 4d 3a 00 0e 4d 26 00 09 4d 4d 00 00 4d 26 00
>a40c	4d 4d 42 00 00 4d 26 00
.a414					ModeNibbles:
>a414	07 ff 44 4f 02 1f aa af			.byte $07,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$45,$5f,$0c,$1f,$ab,$bf,$17,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$55,$5f,$0c,$1f,$bb,$bf,$07,$ff,$f4,$4f,$02,$1f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$07,$ff,$44,$4f,$02,$1f,$da,$af,$38,$9f,$55,$5f,$0c,$0f,$eb,$bf,$37,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$ab,$bf,$27,$2f,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$bb,$cf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf
>a41c	38 9f 45 5f 0c 1f ab bf 17 ff 44 4f 02 1f aa af
>a42c	38 9f 55 5f 0c 1f bb bf 07 ff f4 4f 02 1f aa af
>a43c	38 9f f5 5f 0c 0f fb bf 07 ff 44 4f 02 1f da af
>a44c	38 9f 55 5f 0c 0f eb bf 37 ff 44 4f 02 0f aa af
>a45c	38 9f 55 6f 0c 0f ab bf 27 2f 44 4f 02 0f aa af
>a46c	38 9f 55 6f 0c 0f bb cf 27 ff 44 4f 02 0f aa af
>a47c	38 9f f5 5f 0c 0f fb bf 27 ff 44 4f 02 0f aa af
>a48c	38 9f f5 5f 0c 0f fb bf

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a494					SyntaxError:
.a494	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a497	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a49e					ErrorHandler:
.a49e	fa		plx				plx 								; pull address off.
.a49f	7a		ply				ply
.a4a0	e8		inx				inx 								; point to message
.a4a1	d0 01		bne $a4a4			bne 	_EHNoCarry
.a4a3	c8		iny				iny
.a4a4					_EHNoCarry:
.a4a4	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY 				; print string at XY
.a4a7	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a4a9	f0 13		beq $a4be			beq 	_EHNoLine
.a4ab	a2 c6		ldx #$c6			ldx 	#_EHMessage & $FF 			; print " AT "
.a4ad	a0 a4		ldy #$a4			ldy 	#_EHMessage >> 8
.a4af	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a4b2	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a4b4	b1 00		lda ($00),y			lda 	(codePtr),y
.a4b6	aa		tax				tax
.a4b7	c8		iny				iny
.a4b8	b1 00		lda ($00),y			lda 	(codePtr),y
.a4ba	a8		tay				tay
.a4bb	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.a4be					_EHNoLine:
.a4be	a9 0d		lda #$0d			lda 	#13
.a4c0	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.a4c3	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a4c6					_EHMessage:
>a4c6	20 41 54 20 00					.text	" AT ",0
.a4cb					PrintIntegerUnsigned:
.a4cb	20 fe a8	jsr $a8fe			jsr 	IntToString
.a4ce	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a4d0	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a4d2	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a4d5	98		tya				tya
.a4d6	60		rts				rts
.a4d7					PrintStringXY:
.a4d7	86 02		stx $02				stx 	zTemp0
.a4d9	84 03		sty $03				sty 	zTemp0+1
.a4db	a0 00		ldy #$00			ldy 	#0
.a4dd	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a4df	f0 06		beq $a4e7			beq 	_PSExit
.a4e1	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.a4e4	c8		iny				iny
.a4e5	80 f6		bra $a4dd			bra 	_PSLoop
.a4e7	60		rts		_PSExit:rts
.a4e8					PrintCharacter:
.a4e8	48		pha				pha
.a4e9	da		phx				phx
.a4ea	5a		phy				phy
.a4eb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a4ee	7a		ply				ply
.a4ef	fa		plx				plx
.a4f0	68		pla				pla
.a4f1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a4f2					ExecuteProgram:
.a4f2	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.a4f4	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.a4f6					ExecuteFromXY:
.a4f6	20 f5 a7	jsr $a7f5			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a4f9	20 31 a8	jsr $a831			jsr 	StackReset 					; reset the CPU stack.
.a4fc	64 1a		stz $1a				stz 	assemblerMode 				; not in assembler mode.
.a4fe	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a500	80 0a		bra $a50c			bra 	ExecuteLoop
.a502					ShortConstant:
.a502	c8		iny				iny 								; skip short const
.a503	e8		inx				inx 								; space on stack
.a504	29 3f		and #$3f			and 	#$3F 						; the value
.a506	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a509	9e 00 07	stz $0700,x			stz 	highStack,x
.a50c					ExecuteLoop:
.a50c	e6 18		inc $18				inc 	breakCount 					; check break sometimes.
.a50e	d0 03		bne $a513			bne 	_EXNoBreak
.a510	20 e0 a5	jsr $a5e0			jsr 	ExternCheckBreak
.a513					_EXNoBreak:
.a513	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a515	f0 4b		beq $a562			beq 	_ELUnderflow
.a517	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a519	30 07		bmi $a522			bmi 	_ELNotToken
.a51b	c8		iny				iny 								; skip the token
.a51c	da		phx				phx 								; save X on the stack
.a51d	0a		asl a				asl 	a 							; double the token, put into X
.a51e	aa		tax				tax
.a51f	7c 8c a1	jmp ($a18c,x)			jmp 	(DispatchHandler,x)
.a522					_ELNotToken:
.a522	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a524	90 dc		bcc $a502			bcc 	ShortConstant 				; yes, it's a short constant
.a526	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a528	90 1e		bcc $a548			bcc 	_ELNotFastVariable
.a52a	c8		iny				iny 								; get the next token.
.a52b	b1 00		lda ($00),y			lda 	(codePtr),y
.a52d	88		dey				dey
.a52e	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a530	f0 16		beq $a548			beq 	_ELNotFastVariable 			; which we can optimise.
.a532	5a		phy				phy 								; save Y
.a533	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a535	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a536	a8		tay				tay 								; access via Y
.a537	e8		inx				inx 								; make space on the stack.
.a538	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a53b	9d 00 06	sta $0600,x			sta 	lowStack,x
.a53e	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a541	9d 00 07	sta $0700,x			sta 	highStack,x
.a544	7a		ply				ply 								; restore code pointer
.a545	c8		iny				iny 								; skip variable.
.a546	80 c4		bra $a50c			bra 	ExecuteLoop
.a548					_ELNotFastVariable:
.a548	18		clc				clc									; do not autocreate if not found.
.a549	20 49 a9	jsr $a949			jsr 	VariableFind				; find the variable.
.a54c	90 34		bcc $a582			bcc 	ELUnknown
.a54e	20 bc a6	jsr $a6bc			jsr 	IndexCheck
.a551	5a		phy				phy 								; copy to stack
.a552	e8		inx				inx
.a553	b2 02		lda ($02)			lda 	(zTemp0)
.a555	9d 00 06	sta $0600,x			sta 	lowStack,x
.a558	a0 01		ldy #$01			ldy 	#1
.a55a	b1 02		lda ($02),y			lda 	(zTemp0),y
.a55c	9d 00 07	sta $0700,x			sta 	highStack,x
.a55f	7a		ply				ply
.a560	80 aa		bra $a50c			bra 	ExecuteLoop
.a562					_ELUnderflow:
.a562	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a565	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a56c					ExecuteNextLine:
.a56c					ExecuteComment:
.a56c	fa		plx				plx
.a56d	18		clc				clc 								; skip forward
.a56e	b2 00		lda ($00)			lda 	(codePtr)
.a570	18		clc				clc
.a571	65 00		adc $00				adc 	codePtr
.a573	85 00		sta $00				sta 	codePtr
.a575	90 02		bcc $a579			bcc 	_ENLNoCarry
.a577	e6 01		inc $01				inc 	codePtr+1
.a579					_ENLNoCarry:
.a579	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a57b	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a57d	d0 8d		bne $a50c			bne 	ExecuteLoop
.a57f	4c 77 b0	jmp $b077			jmp	 	Command_End 				; if zero end program.
.a582					ELUnknown:
.a582	a5 1a		lda $1a				lda 	assemblerMode 				; error if not in assembler mode.
.a584	d0 0c		bne $a592			bne 	_ELCheckAssembler
.a586					_ELUnknown:
.a586	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a589	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a591	00
.a592					_ELCheckAssembler:
>a592	ff						.byte 	$FF
.a593	80 f1		bra $a586			bra 	_ELUnknown
.a595					CommandAssemblerOn:
.a595	fa		plx				plx
.a596	a9 01		lda #$01			lda 	#1
.a598	85 1a		sta $1a				sta 	assemblerMode
.a59a	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.a59d					CommandAssemblerOff:
.a59d	fa		plx				plx
.a59e	64 1a		stz $1a				stz 	assemblerMode
.a5a0	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.a5a3					LongConstant:
.a5a3	fa		plx				plx
.a5a4	e8		inx				inx 								; space for constant
.a5a5	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a5a7	9d 00 06	sta $0600,x			sta 	lowStack,x
.a5aa	c8		iny				iny
.a5ab	b1 00		lda ($00),y			lda 	(codePtr),y
.a5ad	9d 00 07	sta $0700,x			sta 	highStack,x
.a5b0	c8		iny				iny
.a5b1	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.a5b4					StringConstant:
.a5b4	fa		plx				plx
.a5b5	e8		inx				inx
.a5b6	18		clc				clc 								; copy Y + codePtr in.
.a5b7	98		tya				tya
.a5b8	65 00		adc $00				adc 	codePtr
.a5ba	9d 00 06	sta $0600,x			sta 	lowStack,x
.a5bd	a5 01		lda $01				lda 	codePtr+1
.a5bf	69 00		adc #$00			adc 	#0
.a5c1	9d 00 07	sta $0700,x			sta 	highStack,x
.a5c4	98		tya				tya 								; add 1 + length to Y
.a5c5	38		sec				sec
.a5c6	71 00		adc ($00),y			adc 	(codePtr),y
.a5c8	a8		tay				tay
.a5c9	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a5cc					ExternInitialise:
.a5cc	a9 02		lda #$02			lda 	#$02 						; set colour
.a5ce	8d c9 02	sta $02c9			sta 	713
.a5d1	a9 0e		lda #$0e			lda 	#14							; lower case
.a5d3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5d6	a9 93		lda #$93			lda 	#147 						; clear screen
.a5d8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5db	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a5dd	4c fe a5	jmp $a5fe			jmp 	ExternColour
.a5e0					ExternCheckBreak:
.a5e0	da		phx				phx 								; make sure we keep XY
.a5e1	5a		phy				phy
.a5e2	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a5e5	f0 03		beq $a5ea			beq		_ECBExit 					; stopped
.a5e7	7a		ply				ply 								; restore and exit.
.a5e8	fa		plx				plx
.a5e9	60		rts				rts
.a5ea					_ECBExit:
.a5ea	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a5ed	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a5f4					ExternPrint:
.a5f4	48		pha				pha
.a5f5	da		phx				phx
.a5f6	5a		phy				phy
.a5f7	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5fa	7a		ply				ply
.a5fb	fa		plx				plx
.a5fc	68		pla				pla
.a5fd	60		rts				rts
.a5fe					ExternColour:
.a5fe	48		pha				pha
.a5ff	da		phx				phx
.a600	48		pha				pha
.a601	29 08		and #$08			and 	#8
.a603	0a		asl a				asl 	a
.a604	0a		asl a				asl 	a
.a605	0a		asl a				asl 	a
.a606	0a		asl a				asl 	a
.a607	49 92		eor #$92			eor 	#$92
.a609	20 f4 a5	jsr $a5f4			jsr 	ExternPrint
.a60c	68		pla				pla
.a60d	29 07		and #$07			and 	#7
.a60f	aa		tax				tax
.a610	bd 19 a6	lda $a619,x			lda 	_ECTable,x
.a613	20 f4 a5	jsr $a5f4			jsr 	ExternPrint
.a616	fa		plx				plx
.a617	68		pla				pla
.a618	60		rts				rts
.a619					_ECTable:
>a619	90						.byte 	144
>a61a	1c						.byte 	28
>a61b	1e						.byte 	30
>a61c	9e						.byte 	158
>a61d	1f						.byte 	31
>a61e	9c						.byte 	156
>a61f	9f						.byte 	159
>a620	05						.byte 	5
.a621					ExternInput:
.a621	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a623	85 02		sta $02				sta 	zTemp0
.a625	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a627	85 03		sta $03				sta 	zTemp0+1
.a629	a9 07		lda #$07			lda 	#COL_WHITE
.a62b	20 fe a5	jsr $a5fe			jsr 	ExternColour
.a62e	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a631	29 7f		and #$7f			and 	#$7F
.a633	c9 0d		cmp #$0d			cmp 	#13
.a635	f0 0a		beq $a641			beq 	_EIExit
.a637	92 02		sta ($02)			sta 	(zTemp0)
.a639	e6 02		inc $02				inc 	zTemp0
.a63b	d0 f1		bne $a62e			bne 	_EIRead
.a63d	e6 03		inc $03				inc 	zTemp0+1
.a63f	80 ed		bra $a62e			bra 	_EIRead
.a641	a9 00		lda #$00	_EIExit:lda 	#0
.a643	92 02		sta ($02)			sta 	(zTemp0)
.a645	a9 0d		lda #$0d			lda 	#13
.a647	20 f4 a5	jsr $a5f4			jsr 	ExternPrint
.a64a	60		rts				rts
.a64b					ExternSave:
.a64b	da		phx				phx
.a64c	5a		phy				phy
.a64d	85 06		sta $06				sta 	zTemp2 						; save start
.a64f	84 07		sty $07				sty 	zTemp2+1
.a651	20 b3 a6	jsr $a6b3			jsr 	EXGetLength 				; get length of file into A
.a654	a6 02		ldx $02				ldx 	zTemp0
.a656	a4 03		ldy $03				ldy 	zTemp0+1
.a658	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a65b	a9 01		lda #$01			lda 	#1
.a65d	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a65f	a0 00		ldy #$00			ldy 	#0
.a661	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a664	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a666	a4 05		ldy $05				ldy 	zTemp1+1
.a668	a9 06		lda #$06			lda 	#zTemp2
.a66a	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a66d	b0 03		bcs $a672			bcs 	_ESSave
.a66f	7a		ply				ply
.a670	fa		plx				plx
.a671	60		rts				rts
.a672					_ESSave:
.a672	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a675	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a67d	4c 45 44 00
.a681					ExternLoad:
.a681	da		phx				phx 								; save XY
.a682	5a		phy				phy
.a683	48		pha				pha 								; save target
.a684	5a		phy				phy
.a685	20 b3 a6	jsr $a6b3			jsr 	EXGetLength 				; get length of file into A
.a688	a6 02		ldx $02				ldx 	zTemp0
.a68a	a4 03		ldy $03				ldy 	zTemp0+1
.a68c	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a68f	a9 01		lda #$01			lda 	#1
.a691	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a693	a0 00		ldy #$00			ldy 	#0
.a695	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a698	7a		ply				ply 								; restore target to YX and call load
.a699	fa		plx				plx
.a69a	a9 00		lda #$00			lda 	#0 							; load command
.a69c	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a69f	b0 03		bcs $a6a4			bcs 	_ESLoad
.a6a1	7a		ply				ply
.a6a2	fa		plx				plx
.a6a3	60		rts				rts
.a6a4					_ESLoad:
.a6a4	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a6a7	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a6af	4c 45 44 00
.a6b3					EXGetLength:
.a6b3	b2 02		lda ($02)			lda 	(zTemp0) 					; get name length
.a6b5	e6 02		inc $02				inc 	zTemp0 						; bump ptr past it
.a6b7	d0 02		bne $a6bb			bne 	_EXGLExit
.a6b9	e6 03		inc $03				inc 	zTemp0+1
.a6bb					_EXGLExit:
.a6bb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a6bc					IndexCheck:
.a6bc	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a6be	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a6c0	f0 01		beq $a6c3			beq 	_ICFound
.a6c2	60		rts				rts
.a6c3					_ICFound:
.a6c3	c8		iny				iny 							; get next
.a6c4	b1 00		lda ($00),y			lda 	(codePtr),y
.a6c6	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a6c8	f0 2b		beq $a6f5			beq 	_ICStackIndex
.a6ca	38		sec				sec
.a6cb	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a6cd	c9 40		cmp #$40			cmp 	#$40
.a6cf	b0 1a		bcs $a6eb			bcs 	_ICError
.a6d1	0a		asl a				asl 	a 						; double index clear carry
.a6d2	5a		phy				phy 							; put into Y
.a6d3	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a6d5	48		pha				pha
.a6d6	a0 01		ldy #$01			ldy 	#1
.a6d8	b1 02		lda ($02),y			lda 	(zTemp0),y
.a6da	69 00		adc #$00			adc 	#0
.a6dc	85 03		sta $03				sta 	zTemp0+1
.a6de	68		pla				pla
.a6df	85 02		sta $02				sta 	zTemp0
.a6e1	7a		ply				ply 							; restore position.
.a6e2	c8		iny				iny								; skip index
.a6e3	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a6e5	c8		iny				iny
.a6e6	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a6e8	d0 01		bne $a6eb			bne 	_ICError
.a6ea	60		rts				rts
.a6eb					_ICError:
.a6eb	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a6ee	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a6f5					_ICStackIndex:
.a6f5	c8		iny				iny 							; skip the ]
.a6f6	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a6f9	0a		asl a				asl 	a
.a6fa	85 04		sta $04				sta 	zTemp1
.a6fc	bd 00 07	lda $0700,x			lda 	highStack,x
.a6ff	2a		rol a				rol 	a
.a700	85 05		sta $05				sta 	zTemp1+1
.a702	ca		dex				dex 							; throw TOS.
.a703	5a		phy				phy
.a704	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a706	b2 02		lda ($02)			lda 	(zTemp0)
.a708	65 04		adc $04				adc 	zTemp1
.a70a	48		pha				pha
.a70b	b1 02		lda ($02),y			lda 	(zTemp0),y
.a70d	65 05		adc $05				adc 	zTemp1+1
.a70f	85 03		sta $03				sta 	zTemp0+1
.a711	68		pla				pla
.a712	85 02		sta $02				sta 	zTemp0
.a714	7a		ply				ply 							; restore pos and exit.
.a715	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/program.asm

.a716					EditProgram:
.a716	86 0d		stx $0d				stx 	zTemp5+1 					; save line number.
.a718	85 0c		sta $0c				sta 	zTemp5
.a71a	5a		phy				phy 								; save token buffer offset
.a71b	20 3e a7	jsr $a73e			jsr 	EDFindLine					; find line address -> zTemp1
.a71e	90 0f		bcc $a72f			bcc 	_EPNotFound 				; if missing don't delete it.
.a720	a5 04		lda $04				lda 	zTemp1 						; save line address
.a722	48		pha				pha
.a723	a5 05		lda $05				lda 	zTemp1+1
.a725	48		pha				pha
.a726	20 73 a7	jsr $a773			jsr 	EDDeleteLine 				; delete the line
.a729	68		pla				pla 								; restore line address
.a72a	85 05		sta $05				sta 	zTemp1+1
.a72c	68		pla				pla
.a72d	85 04		sta $04				sta 	zTemp1
.a72f					_EPNotFound:
.a72f	7a		ply				ply 								; get offset
.a730	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; if something after line#
.a733	f0 03		beq $a738			beq 	_EPNoInsert
.a735	20 96 a7	jsr $a796			jsr 	EDInsertLine 				; insert line back in.
.a738					_EPNoInsert:
.a738	20 f5 a7	jsr $a7f5			jsr 	ResetMemory
.a73b	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a73e					EDFindLine:
.a73e	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a740	85 04		sta $04				sta 	zTemp1
.a742	a9 10		lda #$10			lda 	#ProgramStart >> 8
.a744	85 05		sta $05				sta 	zTemp1+1
.a746					_EDFLLoop:
.a746	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a748	b1 04		lda ($04),y			lda 	(zTemp1),y
.a74a	f0 23		beq $a76f			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a74c	c8		iny				iny
.a74d	38		sec				sec
.a74e	a5 0c		lda $0c				lda 	zTemp5						; subtract the current from the target
.a750	f1 04		sbc ($04),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a752	aa		tax				tax	 								; this will return 10.
.a753	a5 0d		lda $0d				lda 	zTemp5+1
.a755	c8		iny				iny
.a756	f1 04		sbc ($04),y			sbc 	(zTemp1),y
.a758	90 15		bcc $a76f			bcc 	_EDFLFail					; if target < current then failed.
.a75a	d0 04		bne $a760			bne 	_EDFLNext 					; if non-zero then goto next
.a75c	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a75e	f0 11		beq $a771			beq 	_EDFLFound
.a760					_EDFLNext:
.a760	a0 00		ldy #$00			ldy 	#0 							; get offset
.a762	18		clc				clc
.a763	b1 04		lda ($04),y			lda 	(zTemp1),y
.a765	65 04		adc $04				adc 	zTemp1 						; add to pointer
.a767	85 04		sta $04				sta 	zTemp1
.a769	90 db		bcc $a746			bcc 	_EDFLLoop
.a76b	e6 05		inc $05				inc 	zTemp1+1 					; carry out.
.a76d	80 d7		bra $a746			bra 	_EDFLLoop
.a76f					_EDFLFail:
.a76f	18		clc				clc
.a770	60		rts				rts
.a771					_EDFLFound:
.a771	38		sec				sec
.a772	60		rts				rts
.a773					EDDeleteLine:
.a773	20 13 a8	jsr $a813			jsr 	ResetVarMemory
.a776	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a778	a2 00		ldx #$00			ldx 	#0
.a77a	b1 04		lda ($04),y			lda 	(zTemp1),y
.a77c	a8		tay				tay 								; put in Y
.a77d					_EDDelLoop:
.a77d	b1 04		lda ($04),y			lda 	(zTemp1),y 					; get it
.a77f	81 04		sta ($04,x)			sta 	(zTemp1,x) 					; write it.
.a781	a5 04		lda $04				lda 	zTemp1 						; check if pointer has reached the end of
.a783	c5 13		cmp $13				cmp		memVarPtr 					; low memory. We will have copied down an
.a785	d0 06		bne $a78d			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a787	a5 05		lda $05				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a789	c5 14		cmp $14				cmp 	memVarPtr+1					; doesn't really matter.
.a78b	f0 08		beq $a795			beq		_EDDelExit
.a78d					_EDDelNext:
.a78d	e6 04		inc $04				inc 	zTemp1 						; go to next byte.
.a78f	d0 ec		bne $a77d			bne 	_EDDelLoop
.a791	e6 05		inc $05				inc 	zTemp1+1
.a793	80 e8		bra $a77d			bra 	_EDDelLoop
.a795					_EDDelExit:
.a795	60		rts				rts
.a796					EDInsertLine:
.a796	84 02		sty $02				sty 	zTemp0						; zTemp0 = address of code.
.a798	a9 0a		lda #$0a			lda 	#TokenBuffer >> 8
.a79a	85 03		sta $03				sta 	zTemp0+1
.a79c	20 13 a8	jsr $a813			jsr 	ResetVarMemory
.a79f	a5 13		lda $13				lda 	memVarPtr 					; copy high memory to zTemp3
.a7a1	85 08		sta $08				sta 	zTemp3
.a7a3	a5 14		lda $14				lda 	memVarPtr+1
.a7a5	85 09		sta $09				sta 	zTemp3+1
.a7a7	a5 19		lda $19				lda 	TokenOffset 				; work out the space needed.
.a7a9	38		sec				sec
.a7aa	e5 02		sbc $02				sbc 	zTemp0
.a7ac	18		clc				clc
.a7ad	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a7af	48		pha				pha 								; save total size (e.g. offset)
.a7b0	85 0a		sta $0a				sta 	zTemp4 						; save for copying
.a7b2	a8		tay				tay 								; in Y
.a7b3	a2 00		ldx #$00			ldx 	#0
.a7b5					_EDInsLoop:
.a7b5	a1 08		lda ($08,x)			lda 	(zTemp3,x)					; copy it up
.a7b7	91 08		sta ($08),y			sta 	(zTemp3),y
.a7b9	a5 08		lda $08				lda 	zTemp3 						; reached the insert point (zTemp1)
.a7bb	c5 04		cmp $04				cmp 	zTemp1
.a7bd	d0 06		bne $a7c5			bne 	_EDINextShift
.a7bf	a5 09		lda $09				lda 	zTemp3+1
.a7c1	c5 05		cmp $05				cmp 	zTemp1+1
.a7c3	f0 0a		beq $a7cf			beq 	_EDIShiftOver
.a7c5					_EDINextShift:
.a7c5	a5 08		lda $08				lda 	zTemp3 					; decrement the copy pointer.
.a7c7	d0 02		bne $a7cb			bne 	_EDINoBorrow
.a7c9	c6 09		dec $09				dec 	zTemp3+1
.a7cb					_EDINoBorrow:
.a7cb	c6 08		dec $08				dec 	zTemp3
.a7cd	80 e6		bra $a7b5			bra 	_EDInsLoop
.a7cf					_EDIShiftOver:
.a7cf	68		pla				pla 								; this is the size + others, e.g. offset
.a7d0	a0 00		ldy #$00			ldy 	#0
.a7d2	91 08		sta ($08),y			sta 	(zTemp3),y 					; write that out.
.a7d4	a5 0c		lda $0c				lda 	zTemp5 						; write Line# out
.a7d6	c8		iny				iny
.a7d7	91 08		sta ($08),y			sta 	(zTemp3),y
.a7d9	a5 0d		lda $0d				lda 	zTemp5+1
.a7db	c8		iny				iny
.a7dc	91 08		sta ($08),y			sta 	(zTemp3),y
.a7de	c8		iny				iny 								; where the code goes.
.a7df	a2 00		ldx #$00			ldx 	#0 							; comes from
.a7e1					_EDICopyCode:
.a7e1	a1 02		lda ($02,x)			lda 	(zTemp0,x)					; read from the current line
.a7e3	91 08		sta ($08),y			sta 	(zTemp3),y 					; write out
.a7e5	c8		iny				iny 								; bump pointers
.a7e6	e6 02		inc $02				inc 	zTemp0
.a7e8	d0 02		bne $a7ec			bne 	_EDINoCarry
.a7ea	e6 03		inc $03				inc 	zTemp0+1
.a7ec					_EDINoCarry:
.a7ec	c6 0a		dec $0a				dec 	zTemp4 						; copy data in
.a7ee	a5 0a		lda $0a				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.a7f0	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.a7f2	d0 ed		bne $a7e1			bne 	_EDICopyCode
.a7f4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a7f5					ResetMemory:
.a7f5	da		phx				phx									; save run address
.a7f6	5a		phy				phy
.a7f7	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a7f9	85 11		sta $11				sta 	allocPtr
.a7fb	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a7fd	85 12		sta $12				sta 	allocPtr+1
.a7ff	20 13 a8	jsr $a813			jsr 	ResetVarMemory
.a802	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a804					_RMEraseHash:
.a804	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a807	ca		dex				dex
.a808	10 fa		bpl $a804			bpl 	_RMEraseHash
.a80a	7a		ply				ply 								; restore and set run address
.a80b	fa		plx				plx
.a80c	84 01		sty $01				sty 	codePtr+1
.a80e	86 00		stx $00				stx 	codePtr
.a810	a0 03		ldy #$03			ldy 	#3
.a812	60		rts				rts
.a813					ResetVarMemory:
.a813	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a815	85 13		sta $13				sta 	memVarPtr
.a817	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a819	85 14		sta $14				sta 	memVarPtr+1
.a81b					_RMFindEnd:
.a81b	b2 13		lda ($13)			lda 	(memVarPtr)					; offset 0, found end.
.a81d	f0 0b		beq $a82a			beq 	_RMFoundEnd 				; advance to next.
.a81f	18		clc				clc
.a820	65 13		adc $13				adc 	memVarPtr
.a822	85 13		sta $13				sta 	memVarPtr
.a824	90 f5		bcc $a81b			bcc 	_RMFindEnd
.a826	e6 14		inc $14				inc 	memVarPtr+1
.a828	80 f1		bra $a81b			bra 	_RMFindEnd
.a82a					_RMFoundEnd:
.a82a	e6 13		inc $13				inc 	memVarPtr 					; advance past last offset $00
.a82c	d0 02		bne $a830			bne 	_RMNoCarry
.a82e	e6 14		inc $14				inc 	memVarPtr+1
.a830					_RMNoCarry:
.a830	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a831					StackReset:
.a831	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a833	85 0e		sta $0e				sta 	iStack
.a835	a9 09		lda #$09			lda 	#IntStack >> 8
.a837	85 0f		sta $0f				sta 	iStack+1
.a839	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a83b	92 0e		sta ($0e)			sta 	(iStack)
.a83d	60		rts				rts
.a83e					StackPushByte:
.a83e	c6 0e		dec $0e				dec 	iStack
.a840	92 0e		sta ($0e)			sta 	(iStack)
.a842	f0 01		beq $a845			beq 	_SPBUnderflow
.a844	60		rts				rts
.a845					_SPBUnderflow:
.a845	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a848	53 54 41 43 4b 00				.text 	"STACK",0
.a84e					StackPushPosition:
.a84e	98		tya				tya
.a84f	20 3e a8	jsr $a83e			jsr 	StackPushByte
.a852	a5 01		lda $01				lda 	codePtr+1
.a854	20 3e a8	jsr $a83e			jsr 	StackPushByte
.a857	a5 00		lda $00				lda 	codePtr
.a859	20 3e a8	jsr $a83e			jsr 	StackPushByte
.a85c	60		rts				rts
.a85d					StackCheckTop:
.a85d	d2 0e		cmp ($0e)			cmp 	(iStack)
.a85f	f0 02		beq $a863			beq 	_SCTOk
.a861	18		clc				clc
.a862	60		rts				rts
.a863	38		sec		_SCTOk:	sec
.a864	60		rts				rts
.a865					StackPop:
.a865	18		clc				clc
.a866	65 0e		adc $0e				adc 	iStack
.a868	85 0e		sta $0e				sta 	iStack
.a86a	60		rts				rts
.a86b					StackRestorePosition:
.a86b	b1 0e		lda ($0e),y			lda 	(iStack),y
.a86d	85 00		sta $00				sta 	codePtr
.a86f	c8		iny				iny
.a870	b1 0e		lda ($0e),y			lda 	(iStack),y
.a872	85 01		sta $01				sta 	codePtr+1
.a874	c8		iny				iny
.a875	b1 0e		lda ($0e),y			lda 	(iStack),y
.a877	a8		tay				tay
.a878	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a879					StringToInt:
.a879	86 08		stx $08				stx 	zTemp3 						; save string
.a87b	84 09		sty $09				sty 	zTemp3+1
.a87d	64 10		stz $10				stz 	signCount 					; signcount is the number of chars copied.
.a87f	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a881	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a883	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a885	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a887	f0 03		beq $a88c			beq 	_STIConvert 				; convert from character 1, base 16.
.a889	88		dey				dey 								; from character 0
.a88a	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a88c					_STIConvert:
.a88c	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a88e	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a890	f0 5f		beq $a8f1			beq 	_STIFail 					; if zero, then it has failed anyway.
.a892	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a894	64 03		stz $03				stz 	zTemp0+1
.a896					_STILoop:
.a896	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a898	c9 30		cmp #$30			cmp 	#"0"
.a89a	90 55		bcc $a8f1			bcc 	_STIFail
.a89c	c9 3a		cmp #$3a			cmp 	#"9"+1
.a89e	90 08		bcc $a8a8			bcc 	_STIOkay
.a8a0	c9 41		cmp #$41			cmp 	#"A"
.a8a2	90 4d		bcc $a8f1			bcc 	_STIFail
.a8a4	c9 47		cmp #$47			cmp 	#"F"+1
.a8a6	b0 49		bcs $a8f1			bcs 	_STIFail
.a8a8					_STIOkay:
.a8a8	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a8aa	85 06		sta $06				sta 	zTemp2
.a8ac	a5 03		lda $03				lda 	zTemp0+1
.a8ae	85 07		sta $07				sta 	zTemp2+1
.a8b0	64 02		stz $02				stz 	zTemp0 						; clear result
.a8b2	64 03		stz $03				stz 	zTemp0+1
.a8b4	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a8b6					_STIMultiply:
.a8b6	8a		txa				txa 								; shift Y right into carry.
.a8b7	4a		lsr a				lsr 	a
.a8b8	aa		tax				tax
.a8b9	90 0d		bcc $a8c8			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a8bb	18		clc				clc
.a8bc	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a8be	65 02		adc $02				adc 	zTemp0
.a8c0	85 02		sta $02				sta 	zTemp0
.a8c2	a5 07		lda $07				lda 	zTemp2+1
.a8c4	65 03		adc $03				adc 	zTemp0+1
.a8c6	85 03		sta $03				sta 	zTemp0+1
.a8c8					_STINoAdd:
.a8c8	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a8ca	26 07		rol $07				rol 	zTemp2+1
.a8cc	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a8ce	d0 e6		bne $a8b6			bne 	_STIMultiply
.a8d0	38		sec				sec 								; hex adjust
.a8d1	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a8d3	c9 3a		cmp #$3a			cmp 	#58
.a8d5	90 03		bcc $a8da			bcc 	_STIDecimal
.a8d7	38		sec				sec
.a8d8	e9 07		sbc #$07			sbc 	#7
.a8da					_STIDecimal:
.a8da	38		sec				sec
.a8db	e9 30		sbc #$30			sbc 	#48
.a8dd	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a8df	b0 10		bcs $a8f1			bcs 	_STIFail
.a8e1	d8		cld				cld
.a8e2	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a8e4	85 02		sta $02				sta 	zTemp0
.a8e6	90 02		bcc $a8ea			bcc 	_STINoCarry
.a8e8	e6 03		inc $03				inc 	zTemp0+1
.a8ea					_STINoCarry:
.a8ea	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a8ec	c8		iny				iny 								; point to next
.a8ed	e6 10		inc $10				inc 	SignCount
.a8ef	80 a5		bra $a896			bra 	_STILoop 					; and go round again.
.a8f1					_STIFail:
.a8f1	a5 10		lda $10				lda 	SignCount 					; if converted 0 charactes, fail.
.a8f3	f0 07		beq $a8fc			beq 	_STINoConvert
.a8f5	98		tya				tya 								; convert count in A.
.a8f6	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a8f8	a4 03		ldy $03				ldy 	zTemp0+1
.a8fa	38		sec				sec
.a8fb	60		rts				rts
.a8fc					_STINoConvert:
.a8fc	18		clc				clc
.a8fd	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a8fe					IntToString:
.a8fe	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a900	84 03		sty $03				sty 	zTemp0+1
.a902	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a904	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a906					_ITSLoop:
.a906	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a908					_ITSSubtractLoop:
.a908	38		sec				sec
.a909	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a90b	fd 41 a9	sbc $a941,x			sbc 	_ITSWords,x
.a90e	48		pha				pha
.a90f	a5 03		lda $03				lda 	zTemp0+1
.a911	fd 42 a9	sbc $a942,x			sbc 	_ITSWords+1,x
.a914	90 09		bcc $a91f			bcc 	_ITSEndSub 					; can't subtract any more.
.a916	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a918	68		pla				pla
.a919	85 02		sta $02				sta 	zTemp0
.a91b	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a91d	80 e9		bra $a908			bra 	_ITSSubtractLoop
.a91f					_ITSEndSub:
.a91f	68		pla				pla 								; throw away the interim result
.a920	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a922	d0 04		bne $a928			bne 	_ITSWriteOut 				; always write it out
.a924	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a926	f0 06		beq $a92e			beq 	_ITSNext 					; suppressing leading zeros.
.a928					_ITSWriteOut:
.a928	09 30		ora #$30			ora 	#48 						; output digit.
.a92a	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a92d	c8		iny				iny
.a92e					_ITSNext:
.a92e	e8		inx				inx
.a92f	e8		inx				inx
.a930	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a932	d0 d2		bne $a906			bne 	_ITSLoop 					; do the new digits
.a934	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a936	09 30		ora #$30			ora 	#48
.a938	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a93b	a9 00		lda #$00			lda 	#0
.a93d	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a940	60		rts				rts
.a941					_ITSWords:
>a941	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a949					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a949					VariableFind:
.a949	da		phx				phx 								; save the stack position
.a94a	08		php				php 								; save the create flag
.a94b	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a94d	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a94f	90 10		bcc $a961			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a951	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a953	0a		asl a				asl 	a 							; double clear carry
.a954	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a956	85 02		sta $02				sta 	zTemp0
.a958	a9 0f		lda #$0f			lda		#FastVariables >>8
.a95a	85 03		sta $03				sta 	zTemp0+1
.a95c	28		plp				plp 								; create flag is irrelevant.
.a95d	fa		plx				plx									; restore the old stack position
.a95e	c8		iny				iny 								; skip over the single identifier character
.a95f	38		sec				sec 								; return with CS
.a960	60		rts				rts
.a961					_VFIsNotFastVariable:
.a961	20 33 aa	jsr $aa33			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a964	20 8e a9	jsr $a98e			jsr 	VFSearch 					; try to find the variable.
.a967	b0 0d		bcs $a976			bcs 	_VFEndSearch 				; found it, so exit
.a969	28		plp				plp 								; do we want autocreate
.a96a	b0 03		bcs $a96f			bcs 	_VFCreate
.a96c	fa		plx				plx 								; restore stack position and return CC
.a96d	18		clc				clc
.a96e	60		rts				rts
.a96f					_VFCreate:
.a96f	20 33 aa	jsr $aa33			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a972	20 ca a9	jsr $a9ca			jsr 	VFCreate 					; create a new record and link it in.
.a975	08		php				php 								; save a dummy P to be popped.
.a976					_VFEndSearch:
.a976	18		clc				clc 								; the data is at offset + 4
.a977	a5 04		lda $04				lda 	zTemp1
.a979	69 04		adc #$04			adc 	#4
.a97b	85 02		sta $02				sta 	zTemp0
.a97d	a5 05		lda $05				lda 	zTemp1+1
.a97f	69 00		adc #$00			adc 	#0
.a981	85 03		sta $03				sta 	zTemp0+1
.a983	28		plp				plp 								; dump the create flag
.a984					_VFSkipExit:
.a984	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a986	c8		iny				iny
.a987	c9 e0		cmp #$e0			cmp 	#$E0
.a989	90 f9		bcc $a984			bcc 	_VFSkipExit
.a98b	fa		plx				plx 								; restore X
.a98c	38		sec				sec
.a98d	60		rts				rts
.a98e					VFSearch:
.a98e	48		pha				pha 								; save AXY.
.a98f	da		phx				phx
.a990	5a		phy				phy
.a991	98		tya				tya									; add Y to codePtr, put in zTemp2
.a992	18		clc				clc 								; so it points to the identifier.
.a993	65 00		adc $00				adc 	codePtr
.a995	85 06		sta $06				sta 	zTemp2
.a997	a5 01		lda $01				lda 	codePtr+1
.a999	69 00		adc #$00			adc 	#0
.a99b	85 07		sta $07				sta 	zTemp2+1
.a99d					_VFSLoop:
.a99d	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a99f	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a9a1	f0 22		beq $a9c5			beq 	_VFSFailed 					; failed.
.a9a3	aa		tax				tax 								; MSB in X
.a9a4	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a9a6	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a9a8	86 05		stx $05				stx 	zTemp1+1
.a9aa	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a9ac	b1 04		lda ($04),y			lda 	(zTemp1),y
.a9ae	85 08		sta $08				sta 	zTemp3
.a9b0	c8		iny				iny
.a9b1	b1 04		lda ($04),y			lda 	(zTemp1),y
.a9b3	85 09		sta $09				sta 	zTemp3+1
.a9b5	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a9b7					_VFSCheckName:
.a9b7	c8		iny				iny
.a9b8	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a9ba	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a9bc	d0 df		bne $a99d			bne 	_VFSLoop
.a9be	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a9c0	90 f5		bcc $a9b7			bcc 	_VFSCheckName
.a9c2	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a9c3	80 01		bra $a9c6			bra		_VFSExit
.a9c5					_VFSFailed:
.a9c5	18		clc				clc
.a9c6					_VFSExit:
.a9c6	7a		ply				ply 								; restore registers and exit.
.a9c7	fa		plx				plx
.a9c8	68		pla				pla
.a9c9	60		rts				rts
.a9ca					VFCreate:
.a9ca	48		pha				pha 								; save registers
.a9cb	da		phx				phx
.a9cc	5a		phy				phy
.a9cd	18		clc				clc 								; add 6 to memVarPtr, saving its
.a9ce	a5 13		lda $13				lda 	memVarPtr 					; address in zTemp0 as we go.
.a9d0	85 02		sta $02				sta 	zTemp0
.a9d2	69 06		adc #$06			adc 	#6
.a9d4	85 13		sta $13				sta 	memVarPtr
.a9d6	a5 14		lda $14				lda 	memVarPtr+1
.a9d8	85 03		sta $03				sta 	zTemp0+1
.a9da	69 00		adc #$00			adc 	#0
.a9dc	85 14		sta $14				sta 	memVarPtr+1
.a9de	c5 12		cmp $12				cmp 	allocPtr+1 					; out of memory ?
.a9e0	f0 46		beq $aa28			beq 	_VFCMemory
.a9e2	98		tya				tya 								; work out identifier address
.a9e3	18		clc				clc
.a9e4	65 00		adc $00				adc 	codePtr
.a9e6	48		pha				pha
.a9e7	c8		iny				iny
.a9e8	a5 01		lda $01				lda 	codePtr+1
.a9ea	69 00		adc #$00			adc 	#0
.a9ec	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.a9ee	b0 0b		bcs $a9fb			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.a9f0	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a9f3	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.a9fb					_VFCInProgram:
.a9fb	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a9fd	91 02		sta ($02),y			sta 	(zTemp0),y
.a9ff	88		dey				dey
.aa00	68		pla				pla
.aa01	91 02		sta ($02),y			sta 	(zTemp0),y
.aa03	a0 04		ldy #$04			ldy 	#4 							; clear new data
.aa05	a9 00		lda #$00			lda 	#0
.aa07	91 02		sta ($02),y			sta 	(zTemp0),y
.aa09	c8		iny				iny
.aa0a	91 02		sta ($02),y			sta 	(zTemp0),y
.aa0c	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.aa0e	b2 04		lda ($04)			lda 	(zTemp1)
.aa10	92 02		sta ($02)			sta 	(zTemp0)
.aa12	b1 04		lda ($04),y			lda 	(zTemp1),y
.aa14	91 02		sta ($02),y			sta 	(zTemp0),y
.aa16	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.aa18	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.aa1a	a5 03		lda $03				lda 	zTemp0+1
.aa1c	91 04		sta ($04),y			sta 	(zTemp1),y
.aa1e	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.aa20	a5 02		lda $02				lda 	zTemp0
.aa22	85 04		sta $04				sta 	zTemp1
.aa24	7a		ply				ply
.aa25	fa		plx				plx
.aa26	68		pla				pla
.aa27	60		rts				rts
.aa28					_VFCMemory:
.aa28	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>aa2b	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.aa33					VFSetupHashPointer:
.aa33	48		pha				pha
.aa34	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.aa36	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.aa38	0a		asl a				asl 	a 							; double it, also clears carry
.aa39	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.aa3b	85 04		sta $04				sta 	zTemp1
.aa3d	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.aa3f	85 05		sta $05				sta 	zTemp1+1
.aa41	68		pla				pla
.aa42	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.aa43					TokeniseInputBuffer:
.aa43	48		pha				pha
.aa44	da		phx				phx
.aa45	5a		phy				phy
.aa46	64 19		stz $19				stz 	TokenOffset					; reset index into TokenBuffer
.aa48	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.aa4b	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.aa4d	20 b6 aa	jsr $aab6			jsr 	TokWriteToken
.aa50	20 b6 aa	jsr $aab6			jsr 	TokWriteToken
.aa53	20 b6 aa	jsr $aab6			jsr 	TokWriteToken
.aa56	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.aa58					_TIBForward:
.aa58	e8		inx				inx
.aa59	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.aa5c	d0 fa		bne $aa58			bne 	_TIBForward
.aa5e					_TIBBackward:
.aa5e	ca		dex				dex 								; back one.
.aa5f	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.aa61	f0 4f		beq $aab2			beq 	_TIBExit					; return empty buffer
.aa63	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.aa66	c9 20		cmp #$20			cmp 	#" "
.aa68	f0 f4		beq $aa5e			beq 	_TIBBackward
.aa6a	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.aa6d	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.aa6f					_TIBMainLoop:
.aa6f	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.aa72	f0 3e		beq $aab2			beq 	_TIBExit 					; done the buffer if zero.
.aa74	e8		inx				inx
.aa75	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.aa77	f0 f6		beq $aa6f			beq 	_TIBMainLoop
.aa79	ca		dex				dex 								; undo the last inx.
.aa7a	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.aa7c	f0 08		beq $aa86			beq 	_TIBConstant
.aa7e	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.aa80	90 09		bcc $aa8b			bcc 	_TIBNotConstant
.aa82	c9 3a		cmp #$3a			cmp 	#"9"+1
.aa84	b0 05		bcs $aa8b			bcs 	_TIBNotConstant
.aa86					_TIBConstant:
.aa86	20 39 ab	jsr $ab39			jsr 	TOKConvertConstant
.aa89	80 e4		bra $aa6f			bra 	_TIBMainLoop
.aa8b					_TIBNotConstant:
.aa8b	c9 3a		cmp #$3a			cmp 	#":"						; definition
.aa8d	d0 05		bne $aa94			bne 	_TIBNotDefinition
.aa8f	20 8b ab	jsr $ab8b			jsr 	TOKConvertDefinition
.aa92	80 db		bra $aa6f			bra 	_TIBMainLoop
.aa94					_TIBNotDefinition:
.aa94	c9 27		cmp #$27			cmp 	#"'"
.aa96	f0 04		beq $aa9c			beq 	_TIBIsCommentString
.aa98	c9 22		cmp #$22			cmp 	#'"'
.aa9a	d0 05		bne $aaa1			bne 	_TIBNotCommentString
.aa9c					_TIBIsCommentString:
.aa9c	20 ef ab	jsr $abef			jsr 	TOKConvertCommentString
.aa9f	80 ce		bra $aa6f			bra 	_TIBMainLoop
.aaa1					_TIBNotCommentString:
.aaa1	20 36 ac	jsr $ac36			jsr 	TOKCheckIsToken 			; check if a token.
.aaa4	b0 c9		bcs $aa6f			bcs 	_TIBMainLoop
.aaa6	a5 19		lda $19				lda 	TokenOffset 				; save token offset.
.aaa8	48		pha				pha
.aaa9	20 ca ab	jsr $abca			jsr 	TOKCopyIdentifier 			; copy identifier.
.aaac	68		pla				pla
.aaad	20 e7 aa	jsr $aae7			jsr 	TOKCheckIdentifierIsCall 	; convert if call.
.aab0	80 bd		bra $aa6f			bra 	_TIBMainLoop
.aab2					_TIBExit:
.aab2	7a		ply				ply
.aab3	fa		plx				plx
.aab4	68		pla				pla
.aab5	60		rts				rts
.aab6					TOKWriteToken:
.aab6	da		phx				phx
.aab7	a6 19		ldx $19				ldx 	TokenOffset
.aab9	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.aabc	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.aabf	e6 19		inc $19				inc 	TokenOffset
.aac1	fa		plx				plx
.aac2	60		rts				rts
.aac3					TOKFixUpLast:
.aac3	da		phx				phx
.aac4	a6 19		ldx $19				ldx 	TokenOffset
.aac6	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.aac9	09 e0		ora #$e0			ora 	#$E0
.aacb	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.aace	fa		plx				plx
.aacf	60		rts				rts
.aad0					TOKConvertIdentifier:
.aad0	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.aad2	f0 0f		beq $aae3			beq 	_TKCIDot
.aad4	38		sec				sec 								; A-Z -> 1-27
.aad5	e9 40		sbc #$40			sbc 	#64
.aad7	f0 08		beq $aae1			beq 	_TKCIFail
.aad9	c9 1b		cmp #$1b			cmp 	#27
.aadb	b0 04		bcs $aae1			bcs 	_TKCIFail
.aadd	09 c0		ora #$c0			ora 	#$C0 						; fix up
.aadf	38		sec				sec
.aae0	60		rts				rts
.aae1					_TKCIFail:
.aae1	18		clc				clc
.aae2	60		rts				rts
.aae3					_TKCIDot:
.aae3	a9 db		lda #$db			lda 	#$C0+27
.aae5	38		sec				sec
.aae6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_check_call.asm

.aae7					TOKCheckIdentifierIsCall:
.aae7	48		pha				pha
.aae8	da		phx				phx
.aae9	5a		phy				phy
.aaea	85 04		sta $04				sta 	zTemp1
.aaec	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.aaee	85 02		sta $02				sta 	zTemp0
.aaf0	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aaf2	85 03		sta $03				sta 	zTemp0+1
.aaf4					_TKCIILoop:
.aaf4	b2 02		lda ($02)			lda 	(zTemp0) 					; reached the end
.aaf6	f0 3d		beq $ab35			beq 	_TKCIIExit
.aaf8	a0 03		ldy #$03			ldy 	#3							; check if definition
.aafa	b1 02		lda ($02),y			lda 	(zTemp0),y
.aafc	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.aafe	d0 28		bne $ab28			bne 	_TKCIINext 					; if not skip.
.ab00	a6 04		ldx $04				ldx 	zTemp1 						; position of identifier.
.ab02	c8		iny				iny 								; skip count
.ab03					_TKCIICheck:
.ab03	c8		iny				iny
.ab04	bd 00 0a	lda $0a00,x			lda 	TokenBuffer,x 				; compare identifiers
.ab07	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.ab09	d0 1d		bne $ab28			bne 	_TKCIINext
.ab0b	e8		inx				inx
.ab0c	c9 e0		cmp #$e0			cmp 	#$E0						; go back if not end identifier.
.ab0e	90 f3		bcc $ab03			bcc 	_TKCIICheck
.ab10	a5 04		lda $04				lda 	zTemp1 						; get identifier position
.ab12	85 19		sta $19				sta 	TokenOffset 				; reset it.
.ab14	a9 02		lda #$02			lda 	#KWD_SYS_CALL 				; write call
.ab16	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab19	a0 01		ldy #$01			ldy 	#1
.ab1b	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab1d	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab20	c8		iny				iny
.ab21	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab23	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab26	80 0d		bra $ab35			bra 	_TKCIIExit 					; and exit.
.ab28					_TKCIINext:
.ab28	18		clc				clc
.ab29	b2 02		lda ($02)			lda 	(zTemp0)
.ab2b	65 02		adc $02				adc 	zTemp0
.ab2d	85 02		sta $02				sta 	zTemp0
.ab2f	90 c3		bcc $aaf4			bcc 	_TKCIILoop
.ab31	e6 03		inc $03				inc 	zTemp0+1
.ab33	80 bf		bra $aaf4			bra 	_TKCIILoop
.ab35					_TKCIIExit:
.ab35	7a		ply				ply
.ab36	fa		plx				plx
.ab37	68		pla				pla
.ab38	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.ab39					TOKConvertConstant:
.ab39	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.ab3b	da		phx				phx 								; save X position
.ab3c	20 79 a8	jsr $a879			jsr 	StringToInt 				; try to convert
.ab3f	90 40		bcc $ab81			bcc 	_TKCCError
.ab41	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.ab43	86 02		stx $02				stx 	zTemp0
.ab45	85 04		sta $04				sta 	zTemp1 						; save count
.ab47	68		pla				pla 								; restore X position, add the count
.ab48	18		clc				clc
.ab49	65 04		adc $04				adc 	zTemp1
.ab4b	aa		tax				tax
.ab4c	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.ab4f	c9 2d		cmp #$2d			cmp 	#"-"
.ab51	d0 0e		bne $ab61			bne 	_TKCCNotNegative
.ab53	e8		inx				inx 								; consume the -
.ab54	38		sec				sec
.ab55	a9 00		lda #$00			lda 	#0 							; negate the constant.
.ab57	e5 02		sbc $02				sbc 	zTemp0
.ab59	85 02		sta $02				sta 	zTemp0
.ab5b	a9 00		lda #$00			lda 	#0
.ab5d	e5 03		sbc $03				sbc 	zTemp0+1
.ab5f	85 03		sta $03				sta 	zTemp0+1
.ab61					_TKCCNotNegative:
.ab61	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.ab63	d0 0c		bne $ab71			bne 	_TKCCLongConstant
.ab65	a5 02		lda $02				lda 	zTemp0
.ab67	c9 40		cmp #$40			cmp 	#$40
.ab69	b0 06		bcs $ab71			bcs 	_TKCCLongConstant
.ab6b	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.ab6d	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab70	60		rts				rts
.ab71					_TKCCLongConstant:
.ab71	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.ab73	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab76	a5 02		lda $02				lda 	zTemp0
.ab78	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab7b	a5 03		lda $03				lda 	zTemp0+1
.ab7d	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab80	60		rts				rts
.ab81					_TKCCError:
.ab81	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>ab84	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.ab8b					TOKConvertDefinition:
.ab8b	e8		inx				inx 								; skip over :
.ab8c	a9 05		lda #$05			lda 	#KWD_SYS_DEFINE 			; output define token
.ab8e	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ab91					TOKConvertIdentifierOnly:
.ab91	64 02		stz $02				stz 	zTemp0 						; count how many identifiers.
.ab93	da		phx				phx
.ab94					_TKCDCount:
.ab94	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.ab97	20 d0 aa	jsr $aad0			jsr 	TOKConvertIdentifier
.ab9a	90 05		bcc $aba1			bcc 	_TKCDCounted
.ab9c	e8		inx				inx
.ab9d	e6 02		inc $02				inc 	zTemp0
.ab9f	80 f3		bra $ab94			bra 	_TKCDCount
.aba1					_TKCDCounted:
.aba1	a5 02		lda $02				lda 	zTemp0 						; get count
.aba3	f0 16		beq $abbb			beq 	_TKCDFail 					; can't be none
.aba5	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken 				; write count
.aba8	fa		plx				plx 								; restore X
.aba9					_TKCDLoop:
.aba9	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; output that many tokens.
.abac	e8		inx				inx
.abad	20 d0 aa	jsr $aad0			jsr 	TOKConvertIdentifier
.abb0	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.abb3	c6 02		dec $02				dec 	zTemp0
.abb5	d0 f2		bne $aba9			bne 	_TKCDLoop
.abb7	20 c3 aa	jsr $aac3			jsr 	TOKFixUpLast 				; set bit for last character.
.abba	60		rts				rts
.abbb					_TKCDFail:
.abbb	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>abbe	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>abc6	45 52 3f 00
.abca					TOKCopyIdentifier:
.abca	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.abcd	20 d0 aa	jsr $aad0			jsr 	TOKConvertIdentifier
.abd0	90 13		bcc $abe5			bcc 	_TKCIError
.abd2					_TKCILoop:
.abd2	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get and output token till not found
.abd5	e8		inx				inx
.abd6	20 d0 aa	jsr $aad0			jsr 	TOKConvertIdentifier
.abd9	90 05		bcc $abe0			bcc 	_TKCIEnd
.abdb	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.abde	80 f2		bra $abd2			bra 	_TKCILoop
.abe0					_TKCIEnd:
.abe0	ca		dex				dex
.abe1	20 c3 aa	jsr $aac3			jsr 	TOKFixUpLast 				; set bit for last character.
.abe4	60		rts				rts
.abe5					_TKCIError:
.abe5	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>abe8	50 41 52 53 45 3f 00				.text 	"PARSE?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.abef					TOKConvertCommentString:
.abef	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.abf1	f0 06		beq $abf9			beq 	_TKCCSComment
.abf3	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.abf5	a0 22		ldy #$22			ldy 	#'"'						; match character
.abf7	80 04		bra $abfd			bra 	_TKCCSContinue
.abf9					_TKCCSComment:
.abf9	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.abfb	a0 00		ldy #$00			ldy 	#0 							; match character
.abfd					_TKCCSContinue:
.abfd	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken 				; write initial token
.ac00	e8		inx				inx 								; skip over ' or "
.ac01	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.ac03	a0 00		ldy #$00			ldy 	#0 							; count of characters
.ac05	da		phx				phx 								; save start position
.ac06					_TKCCSFindSize:
.ac06	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.ac09	c5 02		cmp $02				cmp 	zTemp0
.ac0b	f0 10		beq $ac1d			beq 	_TKCCSFoundEnd
.ac0d	e8		inx				inx 								; bump pos, count
.ac0e	c8		iny				iny
.ac0f	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.ac11	d0 f3		bne $ac06			bne 	_TKCCSFindSize
.ac13	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>ac16	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.ac1d					_TKCCSFoundEnd:
.ac1d	98		tya				tya 								; length of element in Y
.ac1e	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ac21	fa		plx				plx 								; restore start position and copy out
.ac22					_TKCCSCopyOut:
.ac22	c0 00		cpy #$00			cpy 	#0 							; complete ?
.ac24	f0 0a		beq $ac30			beq 	_TKCCSExit
.ac26	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.ac29	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken
.ac2c	e8		inx				inx
.ac2d	88		dey				dey
.ac2e	80 f2		bra $ac22			bra 	_TKCCSCopyOut
.ac30					_TKCCSExit:
.ac30	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.ac32	f0 01		beq $ac35			beq 	_TKCSSNotComment
.ac34	e8		inx				inx
.ac35					_TKCSSNotComment:
.ac35	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.ac36					TOKCheckIsToken:
.ac36	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.ac38	85 02		sta $02				sta 	zTemp0
.ac3a	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.ac3c	85 03		sta $03				sta 	zTemp0+1
.ac3e	64 04		stz $04				stz 	zTemp1 						; best match length
.ac40	64 06		stz $06				stz 	zTemp2 						; current token.
.ac42					_TCTLoop:
.ac42	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.ac44	da		phx				phx 								; save start
.ac45					_TCTCompare:
.ac45	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.ac47	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.ac4a	e8		inx				inx 								; bump both pointers.
.ac4b	c8		iny				iny
.ac4c	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.ac4d	d0 0e		bne $ac5d			bne 	_TCTNext 					; different, go to next.
.ac4f	90 f4		bcc $ac45			bcc 	_TCTCompare 				; still comparing.
.ac51	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.ac53	c5 04		cmp $04				cmp 	zTemp1						; best so far
.ac55	90 06		bcc $ac5d			bcc 	_TCTNext 					; if not, skip to next.
.ac57	85 04		sta $04				sta 	zTemp1 						; new best score
.ac59	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.ac5b	85 07		sta $07				sta 	zTemp2+1
.ac5d					_TCTNext:
.ac5d	fa		plx				plx 								; restore start position.
.ac5e	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.ac60	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.ac62	38		sec				sec
.ac63	65 02		adc $02				adc 	zTemp0
.ac65	85 02		sta $02				sta 	zTemp0
.ac67	90 02		bcc $ac6b			bcc		_TCTNoCarry
.ac69	e6 03		inc $03				inc 	zTemp0+1
.ac6b					_TCTNoCarry:
.ac6b	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.ac6d	d0 d3		bne $ac42			bne 	_TCTLoop 					; no, check the next keyword.
.ac6f	18		clc				clc
.ac70	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.ac72	f0 0b		beq $ac7f			beq 	_TCTExit
.ac74	8a		txa				txa 								; add that length to the input index.
.ac75	18		clc				clc
.ac76	65 04		adc $04				adc 	zTemp1
.ac78	aa		tax				tax
.ac79	a5 07		lda $07				lda 	zTemp2+1 					; token number
.ac7b	20 b6 aa	jsr $aab6			jsr 	TOKWriteToken 				; write it out.
.ac7e	38		sec				sec 								; set carry and exit
.ac7f					_TCTExit:
.ac7f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.ac80					Cmd_List:
.ac80	fa		plx				plx
.ac81	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.ac83	64 07		stz $07				stz 	zTemp2+1
.ac85	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.ac87	f0 0b		beq $ac94			beq 	_CLNoStart
.ac89	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.ac8c	85 06		sta $06				sta 	zTemp2
.ac8e	bd 00 07	lda $0700,x			lda 	highStack,x
.ac91	85 07		sta $07				sta 	zTemp2+1
.ac93	ca		dex				dex
.ac94					_CLNoStart:
.ac94					_CLNoStartLine:
.ac94	a9 00		lda #$00			lda 	#(programStart) & $FF
.ac96	85 00		sta $00				sta 	codePtr
.ac98	a9 10		lda #$10			lda 	#(programStart) >> 8
.ac9a	85 01		sta $01				sta 	codePtr+1
.ac9c					_CLILoop:
.ac9c	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.ac9e	f0 24		beq $acc4			beq 	_CLIEnd
.aca0	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.aca2	38		sec				sec
.aca3	b1 00		lda ($00),y			lda 	(codePtr),y
.aca5	e5 06		sbc $06				sbc 	zTemp2
.aca7	c8		iny				iny
.aca8	b1 00		lda ($00),y			lda 	(codePtr),y
.acaa	e5 07		sbc $07				sbc 	zTemp2+1
.acac	90 09		bcc $acb7			bcc 	_CLISkip
.acae	da		phx				phx
.acaf	20 c7 ac	jsr $acc7			jsr 	ListCurrent 				; list the line.
.acb2	fa		plx				plx
.acb3	c6 08		dec $08				dec 	zTemp3 						; done all lines
.acb5	f0 0d		beq $acc4			beq 	_CLIEnd
.acb7					_CLISkip:
.acb7	18		clc				clc
.acb8	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.acba	65 00		adc $00				adc 	codePtr
.acbc	85 00		sta $00				sta 	codePtr
.acbe	90 dc		bcc $ac9c			bcc 	_CLILoop
.acc0	e6 01		inc $01				inc 	codePtr+1
.acc2	80 d8		bra $ac9c			bra 	_CLILoop
.acc4					_CLIEnd:
.acc4	4c 1b a0	jmp $a01b			jmp 	WarmStart
.acc7					ListCurrent:
.acc7	a9 02		lda #$02			lda 	#COL_GREEN
.acc9	20 fe a5	jsr $a5fe			jsr 	ExternColour
.accc	a0 01		ldy #$01			ldy 	#1							; print line#
.acce	b1 00		lda ($00),y			lda 	(codePtr),y
.acd0	aa		tax				tax
.acd1	c8		iny				iny
.acd2	b1 00		lda ($00),y			lda 	(codePtr),y
.acd4	a8		tay				tay
.acd5	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.acd8	a8		tay				tay
.acd9					_LCPadOut:
.acd9	a9 20		lda #$20			lda 	#' '
.acdb	20 f4 a5	jsr $a5f4			jsr 	ExternPrint
.acde	c8		iny				iny
.acdf	c0 06		cpy #$06			cpy 	#6
.ace1	d0 f6		bne $acd9			bne 	_LCPadOut
.ace3	a0 03		ldy #$03			ldy 	#3 							; start here
.ace5	64 17		stz $17				stz 	PrefixCharacter				; no prefix
.ace7					_LCLoop:
.ace7	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.ace9	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.aceb	f0 0b		beq $acf8			beq 	_LCNoPrefix
.aced	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.acef	f0 07		beq $acf8			beq 	_LCNoPrefix
.acf1	a5 17		lda $17				lda 	PrefixCharacter 			; output prefix, reset to space
.acf3	f0 03		beq $acf8			beq		_LCNoPrefix
.acf5	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.acf8					_LCNoPrefix:
.acf8	a9 20		lda #$20			lda 	#32
.acfa	85 17		sta $17				sta 	PrefixCharacter
.acfc	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.acfe	f0 13		beq $ad13			beq 	_LCExit
.ad00	10 4d		bpl $ad4f			bpl 	_LCIsToken 					; +ve goto token.
.ad02	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.ad04	b0 13		bcs $ad19			bcs 	_LCIsIdentifier
.ad06	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.ad08	aa		tax				tax
.ad09	c8		iny				iny
.ad0a	5a		phy				phy 								; push pos
.ad0b	a0 00		ldy #$00			ldy 	#0
.ad0d	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.ad10	7a		ply				ply
.ad11	80 d4		bra $ace7			bra 	_LCLoop
.ad13					_LCExit:
.ad13	a9 0d		lda #$0d			lda 	#13
.ad15	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad18	60		rts				rts
.ad19					_LCIsIdentifier:
.ad19					_LCIdentLoop:
.ad19	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.ad1b	20 2c ae	jsr $ae2c			jsr 	ListPrintIDChar
.ad1e	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.ad20	c8		iny				iny
.ad21	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.ad23	b0 c2		bcs $ace7			bcs 	_LCLoop 					; if so, do next
.ad25	80 f2		bra $ad19			bra 	_LCIdentLoop				; if not loop round
.ad27					_LCConstant:
.ad27	c8		iny				iny
.ad28	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.ad2a	aa		tax				tax
.ad2b	c8		iny				iny 								; get MSB into Y
.ad2c	b1 00		lda ($00),y			lda 	(codePtr),y
.ad2e	c8		iny				iny
.ad2f	5a		phy				phy
.ad30	a8		tay				tay
.ad31	5a		phy				phy 								; save sign
.ad32	10 0c		bpl $ad40			bpl 	_LCNotNegative
.ad34	98		tya				tya 								; YX = |YX|
.ad35	49 ff		eor #$ff			eor 	#$FF
.ad37	a8		tay				tay
.ad38	8a		txa				txa
.ad39	49 ff		eor #$ff			eor 	#$FF
.ad3b	aa		tax				tax
.ad3c	e8		inx				inx
.ad3d	d0 01		bne $ad40			bne 	_LCNotNegative
.ad3f	c8		iny				iny
.ad40					_LCNotNegative:
.ad40					_LCPrintYX:
.ad40	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.ad43	68		pla				pla 								; restore sign
.ad44	10 05		bpl $ad4b			bpl 	_LCNoTrail
.ad46	a9 2d		lda #$2d			lda 	#"-"
.ad48	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad4b					_LCNoTrail:
.ad4b	7a		ply				ply 								; restore Y
.ad4c	4c e7 ac	jmp $ace7			jmp 	_LCLoop
.ad4f					_LCIsToken:
.ad4f	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.ad51	f0 d4		beq $ad27			beq 	_LCConstant
.ad53	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.ad55	90 3e		bcc $ad95			bcc 	_LCControl
.ad57					_LCIsKeywordToken:
.ad57	85 02		sta $02				sta 	zTemp0 						; save token #
.ad59	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.ad5b	85 04		sta $04				sta 	zTemp1
.ad5d	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.ad5f	85 05		sta $05				sta 	zTemp1+1
.ad61	5a		phy				phy 								; save code offset
.ad62					_LCForward:
.ad62	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.ad64	f0 0f		beq $ad75			beq 	_LCFoundToken
.ad66	c6 02		dec $02				dec 	zTemp0						; dec count.
.ad68	38		sec				sec 								; go to next keyword.
.ad69	b2 04		lda ($04)			lda 	(zTemp1)
.ad6b	65 04		adc $04				adc 	zTemp1
.ad6d	85 04		sta $04				sta 	zTemp1
.ad6f	90 f1		bcc $ad62			bcc 	_LCForward
.ad71	e6 05		inc $05				inc 	zTemp1+1
.ad73	80 ed		bra $ad62			bra 	_LCForward
.ad75					_LCFoundToken:
.ad75	a0 01		ldy #$01			ldy 	#1 							; output the token.
.ad77					_LCOutToken:
.ad77	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.ad79	29 7f		and #$7f			and 	#$7F
.ad7b	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad7e	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.ad80	c8		iny				iny
.ad81	0a		asl a				asl 	a
.ad82	90 f3		bcc $ad77			bcc 	_LCOutToken
.ad84	7a		ply				ply 								; restore code offset
.ad85	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.ad87	c8		iny				iny
.ad88	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.ad8a	f0 04		beq $ad90			beq 	_LCCancelPrefix
.ad8c	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.ad8e	d0 02		bne $ad92			bne 	_LCGoLoop
.ad90					_LCCancelPrefix:
.ad90	64 17		stz $17				stz 	PrefixCharacter
.ad92					_LCGoLoop:
.ad92	4c e7 ac	jmp $ace7			jmp 	_LCLoop
.ad95					_LCControl:
.ad95	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.ad97	f0 3b		beq $add4			beq 	_LCDecodeCall
.ad99	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ad9b	f0 22		beq $adbf			beq 	_LCDecodeDefine
.ad9d	5a		phy				phy 								; save Y
.ad9e	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.ada0	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.ada2	f0 07		beq $adab			beq 	_LCDecodeString
.ada4	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.ada6	a9 07		lda #$07			lda 	#COL_WHITE 					; highlight comment.
.ada8	20 fe a5	jsr $a5fe			jsr 	ExternColour
.adab					_LCDecodeString
.adab	98		tya				tya
.adac	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.adaf	7a		ply				ply 								; restore Y pos
.adb0	48		pha				pha 								; save end character on stack.
.adb1	20 0c ae	jsr $ae0c			jsr 	ListPrintCodeIdentifier
.adb4	68		pla				pla 								; last character
.adb5	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.adb7	f0 03		beq $adbc			beq 	_LCEDNoQuote
.adb9	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.adbc					_LCEDNoQuote:
.adbc	4c e7 ac	jmp $ace7			jmp 	_LCLoop
.adbf					_LCDecodeDefine:
.adbf	a9 03		lda #$03			lda 	#COL_YELLOW 				; highlight definition.
.adc1	20 fe a5	jsr $a5fe			jsr 	ExternColour
.adc4	a9 3a		lda #$3a			lda 	#":"
.adc6	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.adc9	20 0c ae	jsr $ae0c			jsr 	ListPrintCodeIdentifier
.adcc	a9 02		lda #$02			lda 	#COL_GREEN
.adce	20 fe a5	jsr $a5fe			jsr 	ExternColour
.add1	4c e7 ac	jmp $ace7			jmp 	_LCLoop
.add4					_LCDecodeCall:
.add4	a9 06		lda #$06			lda 	#COL_CYAN
.add6	20 fe a5	jsr $a5fe			jsr 	ExternColour
.add9	c8		iny				iny 								; get line number into XA
.adda	b1 00		lda ($00),y			lda 	(codePtr),y
.addc	48		pha				pha
.addd	c8		iny				iny
.adde	b1 00		lda ($00),y			lda 	(codePtr),y
.ade0	c8		iny				iny
.ade1	aa		tax				tax
.ade2	68		pla				pla
.ade3	20 3e ae	jsr $ae3e			jsr 	ListFindLine 				; find that line.
.ade6	90 19		bcc $ae01			bcc 	_LCNoDefinition
.ade8	5a		phy				phy
.ade9	a0 03		ldy #$03			ldy 	#3 							; look at first character
.adeb	b1 02		lda ($02),y			lda 	(zTemp0),y
.aded	7a		ply				ply
.adee	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.adf0	d0 0f		bne $ae01			bne 	_LCNoDefinition 			; not define
.adf2	5a		phy				phy
.adf3	a0 03		ldy #$03			ldy 	#3
.adf5	20 16 ae	jsr $ae16			jsr 	ListPrintIdentifier
.adf8	7a		ply				ply
.adf9	a9 02		lda #$02			lda 	#COL_GREEN
.adfb	20 fe a5	jsr $a5fe			jsr 	ExternColour
.adfe	4c e7 ac	jmp $ace7			jmp 	_LCLoop
.ae01					_LCNoDefinition:
.ae01	a9 25		lda #$25			lda 	#"%"						; print a %
.ae03	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ae06	88		dey				dey 								; unpick Y changes
.ae07	88		dey				dey
.ae08	88		dey				dey
.ae09	4c 27 ad	jmp $ad27			jmp 	_LCConstant 				; output # as constant
.ae0c					ListPrintCodeIdentifier:
.ae0c	48		pha				pha 								; copy codePtr -> zTemp0
.ae0d	a5 00		lda $00				lda 	codePtr
.ae0f	85 02		sta $02				sta 	zTemp0
.ae11	a5 01		lda $01				lda 	codePtr+1
.ae13	85 03		sta $03				sta 	zTemp0+1
.ae15	68		pla				pla
.ae16					ListPrintIdentifier:
.ae16	48		pha				pha
.ae17	da		phx				phx
.ae18	c8		iny				iny 								; skip over the type
.ae19	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.ae1b	aa		tax				tax
.ae1c					_LPILoop:
.ae1c	c8		iny				iny
.ae1d	e0 00		cpx #$00			cpx 	#0
.ae1f	f0 08		beq $ae29			beq 	_LPIExit
.ae21	b1 02		lda ($02),y			lda 	(zTemp0),y
.ae23	20 2c ae	jsr $ae2c			jsr 	ListPrintIDChar
.ae26	ca		dex				dex
.ae27	80 f3		bra $ae1c			bra 	_LPILoop
.ae29					_LPIExit:
.ae29	fa		plx				plx
.ae2a	68		pla				pla
.ae2b	60		rts				rts
.ae2c					ListPrintIDChar:
.ae2c	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.ae2e	10 0a		bpl $ae3a			bpl	 	_LCNotDot
.ae30	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.ae32	09 40		ora #$40			ora 	#$40 						; ASCII except .
.ae34	c9 5b		cmp #$5b			cmp 	#$40+27
.ae36	d0 02		bne $ae3a			bne 	_LCNotDot
.ae38	a9 2e		lda #$2e			lda 	#"."
.ae3a					_LCNotDot:
.ae3a	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ae3d	60		rts				rts
.ae3e					ListFindLine:
.ae3e	5a		phy				phy
.ae3f	86 05		stx $05				stx 	zTemp1+1
.ae41	85 04		sta $04				sta 	zTemp1
.ae43	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ae45	85 02		sta $02				sta 	zTemp0
.ae47	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ae49	85 03		sta $03				sta 	zTemp0+1
.ae4b					_LFLSearch:
.ae4b	18		clc				clc									; reached the end.
.ae4c	b2 02		lda ($02)			lda 	(zTemp0)
.ae4e	f0 1d		beq $ae6d			beq 	_LFLExit 					; exit with CC
.ae50	a0 01		ldy #$01			ldy 	#1
.ae52	a5 04		lda $04				lda 	zTemp1
.ae54	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.ae56	d0 07		bne $ae5f			bne 	_LFLNext
.ae58	c8		iny				iny
.ae59	a5 05		lda $05				lda 	zTemp1+1
.ae5b	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.ae5d	f0 0d		beq $ae6c			beq 	_LFLFound
.ae5f					_LFLNext:
.ae5f	18		clc				clc
.ae60	b2 02		lda ($02)			lda 	(zTemp0)
.ae62	65 02		adc $02				adc 	zTemp0
.ae64	85 02		sta $02				sta 	zTemp0
.ae66	90 e3		bcc $ae4b			bcc 	_LFLSearch
.ae68	e6 03		inc $03				inc 	zTemp0+1
.ae6a	80 df		bra $ae4b			bra 	_LFLSearch
.ae6c					_LFLFound:
.ae6c	38		sec				sec
.ae6d					_LFLExit:
.ae6d	7a		ply				ply
.ae6e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.ae6f					Mem_Peek:
.ae6f	fa		plx				plx
.ae70	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ae73	85 02		sta $02				sta 	zTemp0
.ae75	bd 00 07	lda $0700,x			lda 	highStack,x
.ae78	85 03		sta $03				sta 	zTemp0+1
.ae7a	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.ae7c	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.ae7f	9e 00 07	stz $0700,x			stz 	highStack,x
.ae82	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.ae85					Mem_WPeek:
.ae85	fa		plx				plx
.ae86	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ae89	85 02		sta $02				sta 	zTemp0
.ae8b	bd 00 07	lda $0700,x			lda 	highStack,x
.ae8e	85 03		sta $03				sta 	zTemp0+1
.ae90	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.ae92	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.ae95	5a		phy				phy 								; read msb
.ae96	a0 01		ldy #$01			ldy 	#1
.ae98	b1 02		lda ($02),y			lda 	(zTemp0),y
.ae9a	7a		ply				ply
.ae9b	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.ae9e	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.aea1					Mem_Poke:
.aea1	fa		plx				plx
.aea2	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aea5	85 02		sta $02				sta 	zTemp0
.aea7	bd 00 07	lda $0700,x			lda 	highStack,x
.aeaa	85 03		sta $03				sta 	zTemp0+1
.aeac	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aeaf	92 02		sta ($02)			sta 	(zTemp0)
.aeb1	ca		dex				dex
.aeb2	ca		dex				dex
.aeb3	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.aeb6					Mem_WPoke:
.aeb6	fa		plx				plx
.aeb7	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aeba	85 02		sta $02				sta 	zTemp0
.aebc	bd 00 07	lda $0700,x			lda 	highStack,x
.aebf	85 03		sta $03				sta 	zTemp0+1
.aec1	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aec4	92 02		sta ($02)			sta 	(zTemp0)
.aec6	5a		phy				phy
.aec7	a0 01		ldy #$01			ldy 	#1
.aec9	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aecc	91 02		sta ($02),y			sta 	(zTemp0),y
.aece	7a		ply				ply
.aecf	ca		dex				dex
.aed0	ca		dex				dex
.aed1	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.aed4					Mem_DWPoke:
.aed4	fa		plx				plx
.aed5	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aed8	85 02		sta $02				sta 	zTemp0
.aeda	bd 00 07	lda $0700,x			lda 	highStack,x
.aedd	85 03		sta $03				sta 	zTemp0+1
.aedf	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aee2	92 02		sta ($02)			sta 	(zTemp0)
.aee4	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aee7	92 02		sta ($02)			sta 	(zTemp0)
.aee9	ca		dex				dex
.aeea	ca		dex				dex
.aeeb	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.aeee					Mem_Alloc:
.aeee	fa		plx				plx
.aeef	38		sec				sec 								; subtract count from alloc ptr
.aef0	a5 11		lda $11				lda 	allocPtr
.aef2	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.aef5	85 11		sta $11				sta 	allocPtr
.aef7	48		pha				pha 								; save low.
.aef8	a5 12		lda $12				lda 	allocPtr+1
.aefa	fd 00 07	sbc $0700,x			sbc 	highStack,x
.aefd	85 12		sta $12				sta 	allocPtr+1
.aeff	90 10		bcc $af11			bcc 	_MAError 					; borrow ?
.af01	c5 14		cmp $14				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.af03	90 0c		bcc $af11			bcc 	_MAError
.af05	f0 0a		beq $af11			beq 	_MAError
.af07	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.af0a	68		pla				pla
.af0b	9d 00 06	sta $0600,x			sta 	lowStack,x
.af0e	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.af11					_MAError:
.af11	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>af14	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/saveload.asm

.af1c					System_Save:
.af1c	fa		plx				plx
.af1d	da		phx				phx
.af1e	20 13 a8	jsr $a813			jsr 	ResetVarMemory 				; make sure start/end are right
.af21	20 48 af	jsr $af48			jsr 	SLGetFileName 				; get filename -> zTemp0
.af24	a5 13		lda $13				lda 	memVarPtr 					; end address
.af26	85 04		sta $04				sta 	zTemp1
.af28	a5 14		lda $14				lda 	memVarPtr+1
.af2a	85 05		sta $05				sta 	zTemp1+1
.af2c	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.af2e	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.af30	20 4b a6	jsr $a64b			jsr 	ExternSave
.af33	7a		ply				ply
.af34	4c 1b a0	jmp $a01b			jmp 	WarmStart
.af37					System_Load:
.af37	fa		plx				plx
.af38	20 48 af	jsr $af48			jsr 	SLGetFileName 				; get filename -> zTemp0
.af3b	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.af3d	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.af3f	20 81 a6	jsr $a681			jsr 	ExternLoad
.af42	20 f5 a7	jsr $a7f5			jsr 	ResetMemory 				; reset everything.
.af45	4c 1b a0	jmp $a01b			jmp 	WarmStart
.af48					SLGetFileName:
.af48	e0 ff		cpx #$ff			cpx 	#255 						; gotta be something on the stack
.af4a	f0 4a		beq $af96			beq 	_SLFNFail
.af4c	bd 00 07	lda $0700,x			lda 	highStack,x 				; should be something in token buffer
.af4f	c9 0a		cmp #$0a			cmp 	#TokenBuffer >> 8
.af51	d0 43		bne $af96			bne 	_SLFNFail
.af53	85 05		sta $05				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.af55	bd 00 06	lda $0600,x			lda 	lowStack,x
.af58	85 04		sta $04				sta 	zTemp1
.af5a	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.af5c	85 02		sta $02				sta 	zTemp0
.af5e	a9 08		lda #$08			lda 	#InputBuffer >> 8
.af60	85 03		sta $03				sta 	zTemp0+1
.af62	b2 04		lda ($04)			lda 	(zTemp1) 					; copy string to input buffer
.af64	1a		inc a				inc 	a
.af65	aa		tax				tax
.af66	a0 00		ldy #$00			ldy 	#0
.af68	b1 04		lda ($04),y	_SLCopy:lda 	(zTemp1),y
.af6a	91 02		sta ($02),y			sta 	(zTemp0),y
.af6c	c8		iny				iny
.af6d	ca		dex				dex
.af6e	d0 f8		bne $af68			bne 	_SLCopy
.af70	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.af72					_SLCheckEnd:
.af72	88		dey				dey
.af73	bd a6 af	lda $afa6,x			lda 	_SLFNExtension,x
.af76	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.af78	d0 05		bne $af7f			bne 	_SLNoExtension
.af7a	ca		dex				dex
.af7b	10 f5		bpl $af72			bpl 	_SLCheckEnd
.af7d	80 16		bra $af95			bra 	_SLExit
.af7f					_SLNoExtension:
.af7f	a0 00		ldy #$00			ldy 	#0							; add the extension.
.af81					_SLExtend:
.af81	ee 00 08	inc $0800			inc 	InputBuffer
.af84	ae 00 08	ldx $0800			ldx 	InputBuffer
.af87	b9 a6 af	lda $afa6,y			lda 	_SLFNExtension,y
.af8a	c8		iny				iny
.af8b	9d 00 08	sta $0800,x			sta 	InputBuffer,x
.af8e	c9 00		cmp #$00			cmp		#0
.af90	d0 ef		bne $af81			bne 	_SLExtend
.af92	ce 00 08	dec $0800			dec 	InputBuffer 				; because wrote the $00
.af95					_SLExit:
.af95	60		rts				rts
.af96					_SLFNFail:
.af96	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>af99	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>afa1	4e 41 4d 45 00
.afa6					_SLFNExtension:
>afa6	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.afab					Stack_Empty:
.afab	fa		plx				plx
.afac	a2 00		ldx #$00			ldx 	#0
.afae	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.afb1					Stack_Drop:
.afb1	fa		plx				plx
.afb2	ca		dex				dex
.afb3	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.afb6					Stack_Dup:
.afb6	fa		plx				plx
.afb7	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.afba	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.afbd	bd 00 07	lda $0700,x			lda 	highStack,x
.afc0	9d 01 07	sta $0701,x			sta 	highStack+1,x
.afc3	e8		inx				inx 								; bump stack pointer
.afc4	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.afc7					Stack_Nip:
.afc7	fa		plx				plx
.afc8	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.afcb	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.afce	bd 00 07	lda $0700,x			lda 	highStack,x
.afd1	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.afd4	ca		dex				dex 								; drop tos
.afd5	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.afd8					Stack_Over:
.afd8	fa		plx				plx
.afd9	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.afdc	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.afdf	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.afe2	9d 01 07	sta $0701,x			sta 	highStack+1,x
.afe5	e8		inx				inx 							; bump stack pointer
.afe6	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.afe9					Stack_Swap:
.afe9	fa		plx				plx
.afea	5a		phy				phy
.afeb	bd 00 06	lda $0600,x			lda 	lowStack,x
.afee	a8		tay				tay
.afef	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.aff2	9d 00 06	sta $0600,x			sta 	lowStack,x
.aff5	98		tya				tya
.aff6	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.aff9	bd 00 07	lda $0700,x			lda 	highStack,x
.affc	a8		tay				tay
.affd	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.b000	9d 00 07	sta $0700,x			sta 	highStack,x
.b003	98		tya				tya
.b004	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.b007	7a		ply				ply
.b008	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.b00b					Command_Store:
.b00b	fa		plx				plx
.b00c	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.b00e	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.b010	90 1f		bcc $b031			bcc 	_CSLongVariable
.b012	c8		iny				iny 								; get the next
.b013	b1 00		lda ($00),y			lda 	(codePtr),y
.b015	88		dey				dey
.b016	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.b018	f0 17		beq $b031			beq 	_CSLongVariable
.b01a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.b01c	c8		iny				iny 								; skip over it and push on stack
.b01d	5a		phy				phy
.b01e	0a		asl a				asl 	a 							; double it, now C0-FE
.b01f	a8		tay				tay 								; put in Y
.b020	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.b023	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.b026	bd 00 07	lda $0700,x			lda 	highStack,x
.b029	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.b02c	ca		dex				dex 								; pop off stack
.b02d	7a		ply				ply 								; restore position and do next
.b02e	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b031					_CSLongVariable:
.b031	38		sec				sec 								; create variable if not found.
.b032	20 49 a9	jsr $a949			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.b035	20 bc a6	jsr $a6bc			jsr 	IndexCheck 					; check indexing.
.b038	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.b03b	92 02		sta ($02)			sta 	(zTemp0)
.b03d	5a		phy				phy
.b03e	a0 01		ldy #$01			ldy 	#1
.b040	bd 00 07	lda $0700,x			lda 	highStack,x
.b043	91 02		sta ($02),y			sta 	(zTemp0),y
.b045	7a		ply				ply
.b046	ca		dex				dex 								; pop off stack
.b047	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.b04a					Command_New:
.b04a	fa		plx				plx
.b04b	9c 00 10	stz $1000			stz 	ProgramStart
.b04e	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b051					Command_Old:
.b051	fa		plx				plx
.b052	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.b054	85 00		sta $00				sta 	codePtr
.b056	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.b058	85 01		sta $01				sta 	codePtr+1
.b05a	a0 03		ldy #$03			ldy 	#3
.b05c					_COAdvance:
.b05c	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.b05e	b0 0e		bcs $b06e			bcs		_COFail
.b060	20 82 b4	jsr $b482			jsr 	AdvanceInCode
.b063	b1 00		lda ($00),y			lda 	(codePtr),y
.b065	d0 f5		bne $b05c			bne 	_COAdvance
.b067	c8		iny				iny 								; byte after end of line
.b068	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.b06b					_CONotDeleted:
.b06b	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b06e					_COFail:
.b06e	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b071	43 41 4e 54 3f 00				.text 	"CANT?",0
.b077					Command_End:
.b077	fa		plx				plx
.b078	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b07b					Command_Stop:
>b07b	ff						.byte 	$FF
.b07c	fa		plx				plx
.b07d	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b080	53 54 4f 50 00					.text 	"STOP",0
.b085					Command_Assert:
.b085	fa		plx				plx
.b086	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.b089	1d 00 07	ora $0700,x			ora 	highStack,x
.b08c	f0 04		beq $b092			beq 	_CAFail
.b08e	ca		dex				dex 								; throw if not.
.b08f	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b092					_CAFail:
.b092	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b095	41 53 53 45 52 54 00				.text 	"ASSERT",0
.b09c					Command_Sys:
.b09c	fa		plx				plx
.b09d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.b0a0	85 02		sta $02				sta 	zTemp0
.b0a2	bd 00 07	lda $0700,x			lda 	highStack,x
.b0a5	85 03		sta $03				sta 	zTemp0+1
.b0a7	ca		dex				dex 								; pop tos
.b0a8	da		phx				phx 								; save XY
.b0a9	5a		phy				phy
.b0aa	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.b0ad	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.b0b0	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.b0b3	20 bb b0	jsr $b0bb			jsr 	_CSCallInd
.b0b6	7a		ply				ply 								; restore XY
.b0b7	fa		plx				plx
.b0b8	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b0bb					_CSCallInd:
.b0bb	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.b0be					Command_DumpStack:
.b0be	fa		plx				plx
.b0bf	da		phx				phx 								; save pos and sp
.b0c0	5a		phy				phy
.b0c1	86 10		stx $10				stx 	SignCount
.b0c3	a2 ff		ldx #$ff			ldx 	#$FF
.b0c5					_CDSLoop:
.b0c5	e4 10		cpx $10				cpx 	SignCount 					; done all ?
.b0c7	f0 2a		beq $b0f3			beq 	_CDSExit
.b0c9	e8		inx				inx
.b0ca	da		phx				phx 								; save SP
.b0cb	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.b0ce	a8		tay				tay
.b0cf	bd 00 06	lda $0600,x			lda 	lowStack,x
.b0d2	aa		tax				tax
.b0d3	c0 00		cpy #$00			cpy 	#0
.b0d5	10 11		bpl $b0e8			bpl 	_CDSPositive
.b0d7	a9 2d		lda #$2d			lda 	#"-" 						; minus
.b0d9	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0dc	98		tya				tya 								; negate YX
.b0dd	49 ff		eor #$ff			eor 	#$FF
.b0df	a8		tay				tay
.b0e0	8a		txa				txa
.b0e1	49 ff		eor #$ff			eor 	#$FF
.b0e3	aa		tax				tax
.b0e4	e8		inx				inx
.b0e5	d0 01		bne $b0e8			bne 	_CDSPositive
.b0e7	c8		iny				iny
.b0e8					_CDSPositive:
.b0e8	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.b0eb	a9 20		lda #$20			lda 	#" " 						; space
.b0ed	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0f0	fa		plx				plx
.b0f1	80 d2		bra $b0c5			bra 	_CDSLoop
.b0f3					_CDSExit:
.b0f3	a9 3c		lda #$3c			lda 	#"<"
.b0f5	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0f8	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0fb	a9 0d		lda #$0d			lda 	#13 						; CR
.b0fd	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b100	7a		ply				ply
.b101	fa		plx				plx
.b102	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.b105					Stack_Add:
.b105	fa		plx				plx
.b106	ca		dex				dex
.b107	18		clc				clc
.b108	bd 00 06	lda $0600,x			lda		lowStack,x
.b10b	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.b10e	9d 00 06	sta $0600,x			sta 	lowStack,x
.b111	bd 00 07	lda $0700,x			lda		highStack,x
.b114	7d 01 07	adc $0701,x			adc 	highStack+1,x
.b117	9d 00 07	sta $0700,x			sta 	highStack,x
.b11a	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b11d					Stack_Sub:
.b11d	fa		plx				plx
.b11e	ca		dex				dex
.b11f	38		sec				sec
.b120	bd 00 06	lda $0600,x			lda		lowStack,x
.b123	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b126	9d 00 06	sta $0600,x			sta 	lowStack,x
.b129	bd 00 07	lda $0700,x			lda		highStack,x
.b12c	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b12f	9d 00 07	sta $0700,x			sta 	highStack,x
.b132	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b135					Stack_And:
.b135	fa		plx				plx
.b136	ca		dex				dex
.b137	bd 00 06	lda $0600,x			lda		lowStack,x
.b13a	3d 01 06	and $0601,x			and		lowStack+1,x
.b13d	9d 00 06	sta $0600,x			sta 	lowStack,x
.b140	bd 00 07	lda $0700,x			lda		highStack,x
.b143	3d 01 07	and $0701,x			and 	highStack+1,x
.b146	9d 00 07	sta $0700,x			sta 	highStack,x
.b149	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b14c					Stack_Xor:
.b14c	fa		plx				plx
.b14d	ca		dex				dex
.b14e	bd 00 06	lda $0600,x			lda		lowStack,x
.b151	5d 01 06	eor $0601,x			eor		lowStack+1,x
.b154	9d 00 06	sta $0600,x			sta 	lowStack,x
.b157	bd 00 07	lda $0700,x			lda		highStack,x
.b15a	5d 01 07	eor $0701,x			eor 	highStack+1,x
.b15d	9d 00 07	sta $0700,x			sta 	highStack,x
.b160	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b163					Stack_Or:
.b163	fa		plx				plx
.b164	ca		dex				dex
.b165	bd 00 06	lda $0600,x			lda		lowStack,x
.b168	1d 01 06	ora $0601,x			ora		lowStack+1,x
.b16b	9d 00 06	sta $0600,x			sta 	lowStack,x
.b16e	bd 00 07	lda $0700,x			lda		highStack,x
.b171	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b174	9d 00 07	sta $0700,x			sta 	highStack,x
.b177	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b17a					Stack_Shl:
.b17a	fa		plx				plx
.b17b	38		sec				sec
.b17c	80 02		bra $b180			bra 	StackShift
.b17e					Stack_Shr:
.b17e	fa		plx				plx
.b17f	18		clc				clc
.b180					StackShift:
.b180	08		php				php
.b181	ca		dex				dex
.b182	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.b185	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.b187	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b18a	d0 19		bne $b1a5			bne 	_SSZero
.b18c					_SSLoop:
.b18c	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.b18f	30 1a		bmi $b1ab			bmi 	_SSDone 					; completed ?
.b191	28		plp				plp 								; restore flag
.b192	08		php				php
.b193	b0 08		bcs $b19d			bcs 	_SSLeft 					; do either shift.
.b195	5e 00 07	lsr $0700,x			lsr 	highStack,x
.b198	7e 00 06	ror $0600,x			ror 	lowStack,x
.b19b	80 ef		bra $b18c			bra 	_SSLoop
.b19d					_SSLeft:
.b19d	1e 00 06	asl $0600,x			asl 	lowStack,x
.b1a0	3e 00 07	rol $0700,x			rol 	highStack,x
.b1a3	80 e7		bra $b18c			bra 	_SSLoop
.b1a5					_SSZero:
.b1a5	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.b1a8	9e 00 07	stz $0700,x			stz 	highStack,x
.b1ab					_SSDone:
.b1ab	28		plp				plp 								; throw flag.
.b1ac	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.b1af					Comp_Equal:
.b1af	fa		plx				plx
.b1b0	38		sec				sec
.b1b1	80 02		bra $b1b5			bra 	Comp_CheckEqual
.b1b3					Comp_NotEqual:
.b1b3	fa		plx				plx
.b1b4	18		clc				clc
.b1b5					Comp_CheckEqual:
.b1b5	08		php				php
.b1b6	ca		dex				dex
.b1b7	bd 00 06	lda $0600,x			lda		lowStack,x
.b1ba	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.b1bd	d0 06		bne $b1c5			bne 	_CCENonZero
.b1bf	bd 00 07	lda $0700,x			lda		highStack,x
.b1c2	5d 01 07	eor $0701,x			eor 	highStack+1,x
.b1c5					_CCENonZero:
.b1c5	f0 02		beq $b1c9			beq 	_CCENotSet
.b1c7	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.b1c9					_CCENotSet:
.b1c9					CompCheckFlip:
.b1c9	28		plp				plp 								; if carry set, we want $FF if equal
.b1ca	90 02		bcc $b1ce			bcc 	CompReturn
.b1cc	49 ff		eor #$ff			eor 	#$FF
.b1ce					CompReturn:
.b1ce	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.b1d1	9d 00 07	sta $0700,x			sta 	highStack,x
.b1d4	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b1d7					Comp_Less:
.b1d7	fa		plx				plx
.b1d8	18		clc				clc
.b1d9	80 02		bra $b1dd			bra 	Comp_LessCont
.b1db					Comp_GreaterEqual:
.b1db	fa		plx				plx
.b1dc	38		sec				sec
.b1dd					Comp_LessCont:
.b1dd	08		php				php
.b1de	ca		dex				dex
.b1df	38		sec				sec
.b1e0	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.b1e3	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b1e6	bd 00 07	lda $0700,x			lda 	highStack,x
.b1e9	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b1ec	50 02		bvc $b1f0			bvc 	_CLNoFlip 					; unsigned -> signed
.b1ee	49 80		eor #$80			eor 	#$80
.b1f0					_CLNoFlip:
.b1f0	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.b1f2	f0 d5		beq $b1c9			beq 	CompCheckFlip
.b1f4	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.b1f6	80 d1		bra $b1c9			bra 	CompCheckFlip
.b1f8					Comp_LessEqual:
.b1f8	fa		plx				plx
.b1f9	38		sec				sec
.b1fa	80 02		bra $b1fe			bra 	Comp_LessEqualCont
.b1fc					Comp_Greater:
.b1fc	fa		plx				plx
.b1fd	18		clc				clc
.b1fe					Comp_LessEqualCont:
.b1fe	08		php				php
.b1ff	ca		dex				dex
.b200	38		sec				sec
.b201	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.b204	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.b207	bd 01 07	lda $0701,x			lda 	highStack+1,x
.b20a	fd 00 07	sbc $0700,x			sbc 	highStack,x
.b20d	50 02		bvc $b211			bvc 	_CLENoFlip 					; unsigned -> signed
.b20f	49 80		eor #$80			eor 	#$80
.b211					_CLENoFlip:
.b211	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.b213	f0 b4		beq $b1c9			beq 	CompCheckFlip
.b215	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.b217	80 b0		bra $b1c9			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.b219					DivInteger16:
.b219	fa		plx				plx
.b21a	20 20 b2	jsr $b220			jsr 	IntegerDivide
.b21d	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b220					IntegerDivide:
.b220	ca		dex				dex
.b221	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.b224	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b227	d0 14		bne $b23d			bne 	_BFDOkay
.b229	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b22c	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>b234	20 42 59 20 5a 45 52 4f 00
.b23d					_BFDOkay:
.b23d	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.b23f	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.b241	64 10		stz $10				stz 	SignCount 					; Count of signs.
.b243	20 7f b2	jsr $b27f			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b246	e8		inx				inx
.b247	20 7f b2	jsr $b27f			jsr 	CheckIntegerNegate
.b24a	ca		dex				dex
.b24b	5a		phy				phy 								; Y is the counter
.b24c	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.b24e					_BFDLoop:
.b24e	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.b251	3e 00 07	rol $0700,x			rol 	highStack,x
.b254	26 04		rol $04				rol 	zTemp1
.b256	26 05		rol $05				rol 	zTemp1+1
.b258	38		sec				sec
.b259	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.b25b	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b25e	48		pha				pha
.b25f	a5 05		lda $05				lda 	zTemp1+1
.b261	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b264	90 0f		bcc $b275			bcc 	_BFDNoAdd
.b266	85 05		sta $05				sta 	zTemp1+1
.b268	68		pla				pla
.b269	85 04		sta $04				sta 	zTemp1+0
.b26b	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.b26e	09 01		ora #$01			ora 	#1
.b270	9d 00 06	sta $0600,x			sta 	lowStack,x
.b273	80 01		bra $b276			bra 	_BFDNext
.b275					_BFDNoAdd:
.b275	68		pla				pla 								; Throw away the intermediate calculations
.b276					_BFDNext:
.b276	88		dey				dey
.b277	d0 d5		bne $b24e			bne 	_BFDLoop
.b279	7a		ply				ply 								; restore Y
.b27a	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.b27c	b0 07		bcs $b285			bcs		IntegerNegateAlways 		; negate the result
.b27e	60		rts				rts
.b27f					CheckIntegerNegate:
.b27f	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.b282	30 01		bmi $b285			bmi 	IntegerNegateAlways 		; if so negate it
.b284	60		rts				rts
.b285					IntegerNegateAlways:
.b285	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.b287	4c e2 b2	jmp $b2e2			jmp 	Unary_Negate
.b28a					ModInteger16:
.b28a	fa		plx				plx
.b28b	20 20 b2	jsr $b220			jsr 	IntegerDivide
.b28e	a5 04		lda $04				lda 	zTemp1
.b290	9d 00 06	sta $0600,x			sta 	lowStack,x
.b293	a5 05		lda $05				lda 	zTemp1+1
.b295	9d 00 07	sta $0700,x			sta 	highStack,x
.b298	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.b29b					MulInteger16:
.b29b	fa		plx				plx
.b29c	ca		dex				dex
.b29d	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.b2a0	85 04		sta $04				sta 	zTemp1
.b2a2	bd 00 07	lda $0700,x			lda 	highStack,x
.b2a5	85 05		sta $05				sta 	zTemp1+1
.b2a7	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.b2aa	9e 00 07	stz $0700,x			stz 	highStack,x
.b2ad					_BFMMultiply:
.b2ad	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.b2af	29 01		and #$01			and 	#1
.b2b1	f0 13		beq $b2c6			beq 	_BFMNoAdd
.b2b3	18		clc				clc 								; add old tos to current tos.
.b2b4	bd 00 06	lda $0600,x			lda		lowStack,x
.b2b7	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.b2ba	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2bd	bd 00 07	lda $0700,x			lda		highStack,x
.b2c0	7d 01 07	adc $0701,x			adc 	highStack+1,x
.b2c3	9d 00 07	sta $0700,x			sta 	highStack,x
.b2c6					_BFMNoAdd:
.b2c6	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.b2c9	3e 01 07	rol $0701,x			rol 	highStack+1,x
.b2cc	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.b2ce	66 04		ror $04				ror 	zTemp1+0
.b2d0	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.b2d2	05 05		ora $05				ora 	zTemp1+1
.b2d4	d0 d7		bne $b2ad			bne 	_BFMMultiply
.b2d6	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.b2d9					Unary_Absolute:
.b2d9	fa		plx				plx
.b2da	bd 00 07	lda $0700,x			lda 	highStack,x
.b2dd	30 04		bmi $b2e3			bmi 	Unary_Negate_Code
.b2df	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b2e2					Unary_Negate:
.b2e2	fa		plx				plx
.b2e3					Unary_Negate_Code:
.b2e3	38		sec				sec
.b2e4	a9 00		lda #$00			lda		#0
.b2e6	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.b2e9	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2ec	a9 00		lda #$00			lda		#0
.b2ee	fd 00 07	sbc $0700,x			sbc 	highStack,x
.b2f1	9d 00 07	sta $0700,x			sta 	highStack,x
.b2f4	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b2f7					Unary_Not:
.b2f7	fa		plx				plx
.b2f8	bd 00 06	lda $0600,x			lda 	lowStack,x
.b2fb	49 ff		eor #$ff			eor 	#$FF
.b2fd	9d 00 06	sta $0600,x			sta 	lowStack,x
.b300	bd 00 07	lda $0700,x			lda 	highStack,x
.b303	49 ff		eor #$ff			eor 	#$FF
.b305	9d 00 07	sta $0700,x			sta 	highStack,x
.b308	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b30b					Unary_Increment:
.b30b	fa		plx				plx
.b30c	fe 00 06	inc $0600,x			inc 	lowStack,x
.b30f	d0 03		bne $b314			bne 	_UIExit
.b311	fe 00 07	inc $0700,x			inc 	highStack,x
.b314					_UIExit:
.b314	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b317					Unary_Decrement:
.b317	fa		plx				plx
.b318	bd 00 06	lda $0600,x			lda 	lowStack,x
.b31b	d0 03		bne $b320			bne 	_UDNoBorrow
.b31d	de 00 07	dec $0700,x			dec 	highStack,x
.b320					_UDNoBorrow:
.b320	de 00 06	dec $0600,x			dec 	lowStack,x
.b323	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b326					Unary_BSwap:
.b326	fa		plx				plx
.b327	bd 00 06	lda $0600,x			lda 	lowStack,x
.b32a	48		pha				pha
.b32b	bd 00 07	lda $0700,x			lda 	highStack,x
.b32e	9d 00 06	sta $0600,x			sta 	lowStack,x
.b331	68		pla				pla
.b332	9d 00 07	sta $0700,x			sta 	highStack,x
.b335	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b338					Unary_Shl:
.b338	fa		plx				plx
.b339	1e 00 06	asl $0600,x			asl 	lowStack,x
.b33c	3e 00 07	rol $0700,x			rol 	highStack,x
.b33f	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b342					Unary_Shr:
.b342	fa		plx				plx
.b343	5e 00 07	lsr $0700,x			lsr 	highStack,x
.b346	7e 00 06	ror $0600,x			ror 	lowStack,x
.b349	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b34c					Unary_Sgn:
.b34c	fa		plx				plx
.b34d	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.b350	10 0a		bpl $b35c			bpl 	_USNotNeg
.b352	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.b354	9d 00 06	sta $0600,x			sta 	lowStack,x
.b357	9d 00 07	sta $0700,x			sta 	highStack,x
.b35a	80 10		bra $b36c			bra 	_USExit
.b35c					_USNotNeg:
.b35c	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.b35f	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.b362	9e 00 07	stz $0700,x			stz 	highStack,x
.b365	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.b367	f0 03		beq $b36c			beq 	_USExit
.b369	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.b36c					_USExit:
.b36c	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b36f					Random_Handler:
.b36f	fa		plx				plx
.b370	a5 15		lda $15				lda 	randomSeed
.b372	05 16		ora $16				ora 	randomSeed+1
.b374	d0 08		bne $b37e			bne 	_RH_NoInit
.b376	a9 7c		lda #$7c			lda 	#$7C
.b378	85 15		sta $15				sta 	randomSeed
.b37a	a9 a1		lda #$a1			lda 	#$A1
.b37c	85 16		sta $16				sta 	randomSeed+1
.b37e					_RH_NoInit:
.b37e	a5 15		lda $15				lda 	randomSeed
.b380	4a		lsr a		        lsr		a
.b381	26 16		rol $16		        rol 	randomSeed+1
.b383	90 02		bcc $b387	        bcc 	_RH_NoEor
.b385	49 b4		eor #$b4	        eor 	#$B4
.b387					_RH_NoEor:
.b387	85 15		sta $15		        sta 	randomSeed
.b389	45 16		eor $16		        eor 	randomSeed+1
.b38b	e8		inx		        inx
.b38c	9d 00 07	sta $0700,x	        sta 	highStack,x
.b38f	a5 15		lda $15		        lda 	randomSeed
.b391	9d 00 06	sta $0600,x	        sta 	lowStack,x
.b394	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.b397					Command_Call:
.b397	fa		plx				plx
.b398	20 4e a8	jsr $a84e			jsr 	StackPushPosition 				; save stack position
.b39b	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.b39d	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b3a0	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.b3a2	85 02		sta $02				sta 	zTemp0
.b3a4	c8		iny				iny
.b3a5	b1 00		lda ($00),y			lda 	(codePtr),y
.b3a7	85 03		sta $03				sta 	zTemp0+1
.b3a9	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.b3ab	85 00		sta $00				sta 	codePtr
.b3ad	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.b3af	85 01		sta $01				sta 	codePtr+1
.b3b1	a0 01		ldy #$01			ldy 	#1
.b3b3					_CCSearch:
.b3b3	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.b3b5	f0 2d		beq $b3e4			beq		_CCFail
.b3b7	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.b3b9	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.b3bb	f0 0d		beq $b3ca			beq 	_CCCheckMSB
.b3bd	18		clc				clc 									; forward to next line.
.b3be	b2 00		lda ($00)			lda 	(codePtr)
.b3c0	65 00		adc $00				adc 	codePtr
.b3c2	85 00		sta $00				sta 	codePtr
.b3c4	90 ed		bcc $b3b3			bcc 	_CCSearch
.b3c6	e6 01		inc $01				inc 	codePtr+1
.b3c8	80 e9		bra $b3b3			bra 	_CCSearch
.b3ca					_CCCheckMSB:
.b3ca	c8		iny				iny 									; get MSB, keeping Y as 1
.b3cb	b1 00		lda ($00),y			lda 	(codePtr),y
.b3cd	88		dey				dey
.b3ce	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.b3d0	d0 e1		bne $b3b3			bne 	_CCSearch
.b3d2	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.b3d4	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.b3d6	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.b3d8	d0 0a		bne $b3e4			bne 	_CCFail
.b3da	c8		iny				iny 									; get the length of this.
.b3db	b1 00		lda ($00),y			lda 	(codePtr),y
.b3dd	18		clc				clc
.b3de	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.b3e0	a8		tay				tay
.b3e1	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b3e4					_CCFail:
.b3e4	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b3e7	43 41 4c 4c 3f 00				.text 	"CALL?",0
.b3ed					Command_Return:
.b3ed	fa		plx				plx
.b3ee	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.b3f0	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b3f3	90 0f		bcc $b404			bcc 	_CRFail
.b3f5	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.b3f7	20 6b a8	jsr $a86b			jsr 	StackRestorePosition
.b3fa	c8		iny				iny
.b3fb	c8		iny				iny
.b3fc	a9 04		lda #$04			lda 	#4 								; pop off stack
.b3fe	20 65 a8	jsr $a865			jsr 	StackPop
.b401	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b404					_CRFail:
.b404	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b407	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.b40d					Structure_If:
.b40d	fa		plx				plx
.b40e	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.b410	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b413	18		clc				clc
.b414	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.b417	1d 00 07	ora $0700,x			ora 	highStack,x
.b41a	ca		dex				dex 									; drop TOS
.b41b	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.b41d	d0 0e		bne $b42d			bne 	_SIFNoSkip 						; at this level.
.b41f	da		phx				phx
.b420	a9 38		lda #$38			lda 	#KWD_ELSE
.b422	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.b424	20 5a b4	jsr $b45a			jsr 	StructSkipForward
.b427	fa		plx				plx 									; restore X
.b428	c9 38		cmp #$38			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.b42a	d0 01		bne $b42d			bne 	_SIFNoSkip 						; clause.
.b42c	c8		iny				iny
.b42d					_SIFNoSkip:
.b42d	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b430					Structure_Else:
.b430	fa		plx				plx
.b431	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b433	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b436	90 0b		bcc $b443			bcc 	SIFail
.b438	da		phx				phx 									; got here by executing IF clause so skip
.b439	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.b43b	aa		tax				tax
.b43c	20 5a b4	jsr $b45a			jsr 	StructSkipForward
.b43f	fa		plx				plx
.b440	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b443					SIFail:
.b443	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b446	49 46 3f 00					.text 	"IF?",0
.b44a					Structure_Endif:
.b44a	fa		plx				plx
.b44b	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b44d	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b450	90 f1		bcc $b443			bcc 	SIFail
.b452	a9 01		lda #$01			lda 	#1 								; throw it.
.b454	20 65 a8	jsr $a865			jsr 	StackPop
.b457	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b45a					StructSkipForward:
.b45a	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.b45c	86 03		stx $03				stx 	zTemp0+1
.b45e	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.b460					_SSFLoop:
.b460	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.b462	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.b464	d0 08		bne $b46e			bne		_SSFFail
.b466	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.b468	f0 17		beq $b481			beq 	_SSFEnd
.b46a	c5 03		cmp $03				cmp 	zTemp0+1
.b46c	f0 13		beq $b481			beq 	_SSFEnd
.b46e					_SSFFail:
.b46e	20 82 b4	jsr $b482			jsr 	AdvanceInCode 					; skip over in code.
.b471	b0 ed		bcs $b460			bcs 	_SSFLoop 						; if not end of program, keep going.
.b473	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b476	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>b47e	45 3f 00
.b481					_SSFEnd:
.b481	60		rts				rts
.b482					AdvanceInCode:
.b482	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.b484	f0 28		beq $b4ae			beq 	_AICEndOfLine 					; end of line.
.b486	c8		iny				iny 									; advance one.
.b487	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.b489	90 10		bcc $b49b			bcc 	_AICControl
.b48b	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.b48d	b0 0a		bcs $b499			bcs 	_AICExit
.b48f	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.b491	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.b493	90 04		bcc $b499			bcc 	_AICExit
.b495	c6 04		dec $04				dec 	zTemp1
.b497	c6 04		dec $04				dec 	zTemp1
.b499					_AICExit:
.b499	38		sec				sec
.b49a	60		rts				rts
.b49b					_AICControl:
.b49b	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.b49d	f0 0b		beq $b4aa			beq 	_AICThree
.b49f	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.b4a1	f0 07		beq $b4aa			beq 	_AICThree
.b4a3	98		tya				tya										; skip over a string/comment/define.
.b4a4	38		sec				sec
.b4a5	71 00		adc ($00),y			adc 	(codePtr),y
.b4a7	a8		tay				tay
.b4a8	38		sec				sec
.b4a9	60		rts				rts
.b4aa					_AICThree:
.b4aa	c8		iny				iny
.b4ab	c8		iny				iny
.b4ac	38		sec				sec
.b4ad	60		rts				rts
.b4ae					_AICEndOfLine:
.b4ae	18		clc				clc 									; forward to next line.
.b4af	b2 00		lda ($00)			lda 	(codePtr)
.b4b1	65 00		adc $00				adc 	codePtr
.b4b3	85 00		sta $00				sta 	codePtr
.b4b5	90 02		bcc $b4b9			bcc 	_AICNoCarry
.b4b7	e6 01		inc $01				inc 	codePtr+1
.b4b9					_AICNoCarry:
.b4b9	a0 03		ldy #$03			ldy 	#3 								; start of new line
.b4bb	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.b4bd	d0 da		bne $b499			bne 	_AICExit
.b4bf	18		clc				clc 									; program end.
.b4c0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.b4c1					Struct_Repeat:
.b4c1	fa		plx				plx
.b4c2	20 4e a8	jsr $a84e			jsr 	StackPushPosition 				; save stack position
.b4c5	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.b4c7	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b4ca	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b4cd					Struct_Until:
.b4cd	fa		plx				plx
.b4ce	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.b4d0	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b4d3	90 1b		bcc $b4f0			bcc 	_SUFail
.b4d5	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.b4d8	1d 00 07	ora $0700,x			ora 	highStack,x
.b4db	ca		dex				dex
.b4dc	09 00		ora #$00			ora 	#0
.b4de	f0 08		beq $b4e8			beq 	_SULoopBack 					; if so keep going.
.b4e0	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.b4e2	20 65 a8	jsr $a865			jsr 	StackPop
.b4e5	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b4e8					_SULoopBack:
.b4e8	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b4ea	20 6b a8	jsr $a86b			jsr 	StackRestorePosition
.b4ed	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b4f0					_SUFail:
.b4f0	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b4f3	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>b4fb	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.b4fd					Struct_For:
.b4fd	fa		plx				plx
.b4fe	18		clc				clc
.b4ff	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.b502	49 ff		eor #$ff			eor 	#$FF
.b504	69 01		adc #$01			adc 	#1
.b506	08		php				php
.b507	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b50a	bd 00 07	lda $0700,x			lda 	highStack,x
.b50d	49 ff		eor #$ff			eor 	#$FF
.b50f	28		plp				plp
.b510	69 00		adc #$00			adc 	#0
.b512	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b515	ca		dex				dex 									; throw TOS
.b516	20 4e a8	jsr $a84e			jsr 	StackPushPosition 				; save stack position
.b519	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.b51b	20 3e a8	jsr $a83e			jsr 	StackPushByte
.b51e	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b521					Struct_Index:
.b521	fa		plx				plx
.b522	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b524	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b527	90 43		bcc $b56c			bcc 	SNFail
.b529	e8		inx				inx 									; new stack entry
.b52a	5a		phy				phy
.b52b	a0 04		ldy #$04			ldy 	#4 								; access index value
.b52d	b1 0e		lda ($0e),y			lda 	(iStack),y
.b52f	49 ff		eor #$ff			eor 	#$FF
.b531	9d 00 07	sta $0700,x			sta 	highStack,x
.b534	c8		iny				iny
.b535	b1 0e		lda ($0e),y			lda 	(iStack),y
.b537	49 ff		eor #$ff			eor 	#$FF
.b539	9d 00 06	sta $0600,x			sta 	lowStack,x
.b53c	7a		ply				ply 									; restore code pointer
.b53d	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b540					Struct_Next:
.b540	fa		plx				plx
.b541	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b543	20 5d a8	jsr $a85d			jsr 	StackCheckTop
.b546	90 24		bcc $b56c			bcc 	SNFail
.b548	5a		phy				phy 									; save code position
.b549	a0 05		ldy #$05			ldy 	#5 								; bump the count
.b54b	b1 0e		lda ($0e),y			lda 	(iStack),y
.b54d	1a		inc a				inc 	a
.b54e	91 0e		sta ($0e),y			sta 	(iStack),y
.b550	d0 11		bne $b563			bne 	_SNLoopBack
.b552	88		dey				dey
.b553	b1 0e		lda ($0e),y			lda 	(iStack),y
.b555	1a		inc a				inc 	a
.b556	91 0e		sta ($0e),y			sta 	(iStack),y
.b558	d0 09		bne $b563			bne 	_SNLoopBack  					; non-zero loop back.
.b55a	7a		ply				ply 									; restore code position.
.b55b	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.b55d	20 65 a8	jsr $a865			jsr 	StackPop
.b560	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b563					_SNLoopBack:
.b563	7a		ply				ply 									; restore code position, being junked anyway.
.b564	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b566	20 6b a8	jsr $a86b			jsr 	StackRestorePosition
.b569	4c 0c a5	jmp $a50c			jmp 	ExecuteLoop
.b56c					SNFail:
.b56c	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b56f	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
