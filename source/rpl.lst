
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Sun Nov 17 09:28:21 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer (must be on a page boundary)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					zTemp4:			.word ?
>000c					zTemp5:			.word ?
>000e					iStack:			.word ?						; stack pointer
>0010					signCount:		.byte ? 					; divide sign count.
>0011					allocPtr:		.word ? 					; memory allocation pointer (down)
>0013					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0015					randomSeed:		.word ? 					; random number seed
>0017					prefixCharacter:.byte ?						; char to print before listed element.
>0018					breakCount:		.byte ? 					; counter avoids repeated break checks
>0019					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	13 e8 03 03 0d 54 48 45			.byte	$13,$e8,$03,$03,$0d,$54,$48,$45,$20,$42,$41,$4c,$4c,$20,$44,$45,$4d,$4f,$00,$07,$f2,$03,$02,$ec,$04,$00,$10,$fc,$03,$01,$00,$04,$21,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$56,$04,$0b,$00,$05,$24,$04,$07,$00,$12,$2e,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$9c,$04,$0b,$00,$06,$38,$04,$80,$0a,$00,$05,$42,$04,$41,$00,$23,$4c,$04,$05,$0b,$c2,$c1,$cc,$cc,$db,$d3,$c5,$cc,$c5,$c3,$f4,$2e,$2e,$2e,$2e,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$3a,$00,$29,$56,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$31,$28,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$31,$28,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$60,$04,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$31,$87,$11,$2b,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$74,$04,$3a,$00,$1c,$6a,$04,$05,$0b,$d2,$c1,$ce,$c4,$cf,$cd,$db,$d3,$c9,$c7,$ee,$31,$81,$11,$06,$81,$38,$01,$ff,$ff,$09,$3a,$00,$0f,$74,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$7e,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2e,$01,$20,$9f,$1d,$00,$0f,$88,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$92,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$3a,$00,$0f,$9c,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$a6,$04,$a0,$02,$74,$04,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ba,$04,$34,$01,$50,$00,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ce,$04,$34,$bc,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$d8,$04,$01,$51,$00,$02,$74,$04,$00,$05,$e2,$04,$3a,$00,$15,$ec,$04,$05,$05,$c3,$cc,$c5,$c1,$f2,$80,$01,$20,$9f,$1f,$90,$01,$22,$9f,$1d,$00,$0a,$f6,$04,$01,$80,$00,$bc,$0c,$08,$00,$0e,$00,$05,$a0,$01,$23,$9f,$1d,$81,$01,$23,$9f,$1d,$00,$06,$0a,$05,$0b,$3a,$00
>1008	20 42 41 4c 4c 20 44 45 4d 4f 00 07 f2 03 02 ec
>1018	04 00 10 fc 03 01 00 04 21 22 c2 c1 cc cc cd c5
>1028	ed 00 0b 06 04 a0 22 c3 cf d5 ce f4 00 0d 10 04
>1038	01 8e 00 22 e1 01 d2 ff 25 00 12 1a 04 c3 cf d5
>1048	ce f4 08 39 02 4c 04 02 56 04 0b 00 05 24 04 07
>1058	00 12 2e 04 c3 cf d5 ce f4 08 39 02 4c 04 02 9c
>1068	04 0b 00 06 38 04 80 0a 00 05 42 04 41 00 23 4c
>1078	04 05 0b c2 c1 cc cc db d3 c5 cc c5 c3 f4 2e 2e
>1088	2e 2e c2 c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 3a
>1098	00 29 56 04 05 09 c2 c1 cc cc db c9 ce c9 f4 31
>10a8	28 01 50 00 0e 22 c2 c1 cc ec 23 80 24 31 28 bc
>10b8	0e 22 c2 c1 cc ec 23 81 24 00 2d 60 04 02 6a 04
>10c8	22 c2 c1 cc ec 23 82 24 02 6a 04 22 c2 c1 cc ec
>10d8	23 83 24 31 87 11 2b 22 c2 c1 cc ec 23 84 24 01
>10e8	51 00 02 74 04 3a 00 1c 6a 04 05 0b d2 c1 ce c4
>10f8	cf cd db d3 c9 c7 ee 31 81 11 06 81 38 01 ff ff
>1108	09 3a 00 0f 74 04 05 09 c2 c1 cc cc db c4 d2 c1
>1118	f7 00 10 7e 04 c2 c1 cc ec 23 80 24 2e 01 20 9f
>1128	1d 00 0f 88 04 c2 c1 cc ec 23 81 24 01 21 9f 1d
>1138	00 19 92 04 90 01 22 9f 1d 01 23 9f 1d c2 c1 cc
>1148	ec 23 84 24 01 23 9f 1d 3a 00 0f 9c 04 05 09 c2
>1158	c1 cc cc db cd cf d6 e5 00 08 a6 04 a0 02 74 04
>1168	00 1c b0 04 c2 c1 cc ec 23 80 24 c2 c1 cc ec 23
>1178	82 24 0f 34 22 c2 c1 cc ec 23 80 24 00 1f ba 04
>1188	34 01 50 00 1a 37 80 19 12 06 c2 c1 cc ec 23 82
>1198	24 29 22 c2 c1 cc ec 23 82 24 09 00 1c c4 04 c2
>11a8	c1 cc ec 23 81 24 c2 c1 cc ec 23 83 24 0f 34 22
>11b8	c2 c1 cc ec 23 81 24 00 1d ce 04 34 bc 1a 37 80
>11c8	19 12 06 c2 c1 cc ec 23 83 24 29 22 c2 c1 cc ec
>11d8	23 83 24 09 00 0a d8 04 01 51 00 02 74 04 00 05
>11e8	e2 04 3a 00 15 ec 04 05 05 c3 cc c5 c1 f2 80 01
>11f8	20 9f 1f 90 01 22 9f 1d 00 0a f6 04 01 80 00 bc
>1208	0c 08 00 0e 00 05 a0 01 23 9f 1d 81 01 23 9f 1d
>1218	00 06 0a 05 0b 3a 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 b5 a5	jsr $a5b5			jsr 	ExternInitialise			; set up external stuff.
.a006	a2 63		ldx #$63			ldx 	#BootPrompt & $FF 			; print start up.
.a008	a0 a0		ldy #$a0			ldy 	#BootPrompt >> 8
.a00a	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a00d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.a00f	a0 8f		ldy #$8f			ldy 	#(HighMemory-ProgramStart) >> 8
.a011	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.a014	a2 80		ldx #$80			ldx 	#BootPrompt2 & $FF
.a016	a0 a0		ldy #$a0			ldy 	#BootPrompt2 >> 8
.a018	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a01b					WarmStart:
.a01b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a01d	9a		txs				txs
.a01e	20 0a a6	jsr $a60a			jsr 	ExternInput					; input a line.
.a021	ad 00 08	lda $0800			lda 	InputBuffer 				; get the first character.
.a024	48		pha				pha
.a025	20 2c aa	jsr $aa2c			jsr 	TokeniseInputBuffer 		; tokenise it
.a028	68		pla				pla
.a029	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.a02b	f0 0d		beq $a03a			beq 	ExecuteLine
.a02d	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.a030	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.a032	f0 0d		beq $a041			beq 	LineNumber
.a034	29 c0		and #$c0			and 	#$C0
.a036	c9 80		cmp #$80			cmp 	#$80
.a038	f0 07		beq $a041			beq 	LineNumber
.a03a					ExecuteLine:
.a03a	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.a03c	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.a03e	4c f6 a4	jmp $a4f6			jmp 	ExecuteFromXY
.a041					LineNumber:
.a041	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.a044	a2 00		ldx #$00			ldx 	#0
.a046	a0 04		ldy #$04			ldy 	#4
.a048	38		sec				sec
.a049	e9 80		sbc #$80			sbc 	#$80
.a04b	c9 40		cmp #$40			cmp 	#$40
.a04d	90 08		bcc $a057			bcc 	_HaveLineNumber
.a04f	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.a052	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.a055	a0 06		ldy #$06			ldy 	#6
.a057					_HaveLineNumber:
.a057	48		pha				pha 								; a fudge. Because you use
.a058	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.a05b	c9 3c		cmp #$3c			cmp 	#KWD_LIST 					; this to be executed and not
.a05d	f0 db		beq $a03a			beq 	ExecuteLine 				; to be code.
.a05f	68		pla				pla
.a060	4c ff a6	jmp $a6ff			jmp 	EditProgram
.a063					BootPrompt:
>a063	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (16-NOV-19) ***",13,13
>a06b	36 35 20 28 31 36 2d 4e 4f 56 2d 31 39 29 20 2a
>a07b	2a 2a 0d 0d
>a07f	00						.byte 	0
.a080					BootPrompt2:
>a080	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>a088	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_HASH                       = $0027 ; #
=$0028					KWD_ABS                        = $0028 ; abs
=$0029					KWD_NEGATE                     = $0029 ; negate
=$002a					KWD_NOT                        = $002a ; not
=$002b					KWD_PLUSPLUS                   = $002b ; ++
=$002c					KWD_MINUSMINUS                 = $002c ; --
=$002d					KWD_BSWAP                      = $002d ; bswap
=$002e					KWD_LESSLESS                   = $002e ; <<
=$002f					KWD_GREATERGREATER             = $002f ; >>
=$0030					KWD_SGN                        = $0030 ; sgn
=$0031					KWD_RND                        = $0031 ; rnd
=$0032					KWD_CLR                        = $0032 ; clr
=$0033					KWD_DROP                       = $0033 ; drop
=$0034					KWD_DUP                        = $0034 ; dup
=$0035					KWD_NIP                        = $0035 ; nip
=$0036					KWD_OVER                       = $0036 ; over
=$0037					KWD_SWAP                       = $0037 ; swap
=$0038					KWD_ELSE                       = $0038 ; else
=$0039					KWD_INDEX                      = $0039 ; index
=$003a					KWD_SEMICOLON                  = $003a ; ;
=$003b					KWD_ASSERT                     = $003b ; assert
=$003c					KWD_LIST                       = $003c ; list
=$003d					KWD_NEW                        = $003d ; new
=$003e					KWD_OLD                        = $003e ; old
=$003f					KWD_STOP                       = $003f ; stop
=$0040					KWD_RUN                        = $0040 ; run
=$0041					KWD_END                        = $0041 ; end
=$0042					KWD_SAVE                       = $0042 ; save
=$0043					KWD_LOAD                       = $0043 ; load
.a094					KeywordText:
>a094	01 ff					.text $01,$ff                          ; $0000 %eol
>a096	01 ff					.text $01,$ff                          ; $0001 %const
>a098	01 ff					.text $01,$ff                          ; $0002 %call
>a09a	01 ff					.text $01,$ff                          ; $0003 %comment
>a09c	01 ff					.text $01,$ff                          ; $0004 %qstring
>a09e	01 ff					.text $01,$ff                          ; $0005 %define
>a0a0	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a0a3	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a0aa	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a0ae	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a0b4	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a0ba	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a0bf	01 aa					.text $01,$aa                          ; $000c *
>a0c1	01 af					.text $01,$af                          ; $000d /
>a0c3	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a0c7	01 ab					.text $01,$ab                          ; $000f +
>a0c9	01 ad					.text $01,$ad                          ; $0010 -
>a0cb	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a0cf	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a0d2	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a0d6	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a0da	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a0de	01 bd					.text $01,$bd                          ; $0016 =
>a0e0	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a0e3	01 be					.text $01,$be                          ; $0018 >
>a0e5	01 bc					.text $01,$bc                          ; $0019 <
>a0e7	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a0ea	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a0ed	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a0f0	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a0f3	01 c0					.text $01,$c0                          ; $001e @
>a0f5	01 a1					.text $01,$a1                          ; $001f !
>a0f7	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a0fa	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a100	01 de					.text $01,$de                          ; $0022 ^
>a102	01 db					.text $01,$db                          ; $0023 [
>a104	01 dd					.text $01,$dd                          ; $0024 ]
>a106	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a10a	01 bf					.text $01,$bf                          ; $0026 ?
>a10c	01 a3					.text $01,$a3                          ; $0027 #
>a10e	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0028 abs
>a112	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0029 negate
>a119	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $002a not
>a11d	02 2b ab				.text $02,$2b,$ab                      ; $002b ++
>a120	02 2d ad				.text $02,$2d,$ad                      ; $002c --
>a123	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002d bswap
>a129	02 3c bc				.text $02,$3c,$bc                      ; $002e <<
>a12c	02 3e be				.text $02,$3e,$be                      ; $002f >>
>a12f	03 53 47 ce				.text $03,$53,$47,$ce                  ; $0030 sgn
>a133	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0031 rnd
>a137	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0032 clr
>a13b	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0033 drop
>a140	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0034 dup
>a144	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0035 nip
>a148	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0036 over
>a14d	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0037 swap
>a152	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0038 else
>a157	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0039 index
>a15d	01 bb					.text $01,$bb                          ; $003a ;
>a15f	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003b assert
>a166	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003c list
>a16b	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003d new
>a16f	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003e old
>a173	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003f stop
>a178	03 52 55 ce				.text $03,$52,$55,$ce                  ; $0040 run
>a17c	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0041 end
>a180	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0042 save
>a185	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0043 load
>a18a	00					.byte 0
>a18b						.align 2
.a18c					DispatchHandler:
>a18c	76 a5					.word ExecuteNextLine          ; $0000 %eol
>a18e	8c a5					.word LongConstant             ; $0001 %const
>a190	80 b3					.word Command_Call             ; $0002 %call
>a192	76 a5					.word ExecuteComment           ; $0003 %comment
>a194	9d a5					.word StringConstant           ; $0004 %qstring
>a196	94 a4					.word SyntaxError              ; $0005 %define
>a198	f6 b3					.word Structure_If             ; $0006 if
>a19a	aa b4					.word Struct_Repeat            ; $0007 repeat
>a19c	e6 b4					.word Struct_For               ; $0008 for
>a19e	33 b4					.word Structure_Endif          ; $0009 endif
>a1a0	b6 b4					.word Struct_Until             ; $000a until
>a1a2	29 b5					.word Struct_Next              ; $000b next
>a1a4	84 b2					.word MulInteger16             ; $000c *
>a1a6	02 b2					.word DivInteger16             ; $000d /
>a1a8	73 b2					.word ModInteger16             ; $000e mod
>a1aa	ee b0					.word Stack_Add                ; $000f +
>a1ac	06 b1					.word Stack_Sub                ; $0010 -
>a1ae	1e b1					.word Stack_And                ; $0011 and
>a1b0	4c b1					.word Stack_Or                 ; $0012 or
>a1b2	35 b1					.word Stack_Xor                ; $0013 xor
>a1b4	63 b1					.word Stack_Shl                ; $0014 shl
>a1b6	67 b1					.word Stack_Shr                ; $0015 shr
>a1b8	98 b1					.word Comp_Equal               ; $0016 =
>a1ba	9c b1					.word Comp_NotEqual            ; $0017 <>
>a1bc	e5 b1					.word Comp_Greater             ; $0018 >
>a1be	c0 b1					.word Comp_Less                ; $0019 <
>a1c0	c4 b1					.word Comp_GreaterEqual        ; $001a >=
>a1c2	e1 b1					.word Comp_LessEqual           ; $001b <=
>a1c4	58 ae					.word Mem_Peek                 ; $001c c@
>a1c6	8a ae					.word Mem_Poke                 ; $001d c!
>a1c8	6e ae					.word Mem_WPeek                ; $001e @
>a1ca	9f ae					.word Mem_WPoke                ; $001f !
>a1cc	bd ae					.word Mem_DWPoke               ; $0020 d!
>a1ce	d7 ae					.word Mem_Alloc                ; $0021 alloc
>a1d0	f4 af					.word Command_Store            ; $0022 ^
>a1d2	94 a4					.word SyntaxError              ; $0023 [
>a1d4	94 a4					.word SyntaxError              ; $0024 ]
>a1d6	85 b0					.word Command_Sys              ; $0025 sys
>a1d8	a7 b0					.word Command_DumpStack        ; $0026 ?
>a1da	94 a4					.word SyntaxError              ; $0027 #
>a1dc	c2 b2					.word Unary_Absolute           ; $0028 abs
>a1de	cb b2					.word Unary_Negate             ; $0029 negate
>a1e0	e0 b2					.word Unary_Not                ; $002a not
>a1e2	f4 b2					.word Unary_Increment          ; $002b ++
>a1e4	00 b3					.word Unary_Decrement          ; $002c --
>a1e6	0f b3					.word Unary_BSwap              ; $002d bswap
>a1e8	21 b3					.word Unary_Shl                ; $002e <<
>a1ea	2b b3					.word Unary_Shr                ; $002f >>
>a1ec	35 b3					.word Unary_Sgn                ; $0030 sgn
>a1ee	58 b3					.word Random_Handler           ; $0031 rnd
>a1f0	94 af					.word Stack_Empty              ; $0032 clr
>a1f2	9a af					.word Stack_Drop               ; $0033 drop
>a1f4	9f af					.word Stack_Dup                ; $0034 dup
>a1f6	b0 af					.word Stack_Nip                ; $0035 nip
>a1f8	c1 af					.word Stack_Over               ; $0036 over
>a1fa	d2 af					.word Stack_Swap               ; $0037 swap
>a1fc	19 b4					.word Structure_Else           ; $0038 else
>a1fe	0a b5					.word Struct_Index             ; $0039 index
>a200	d6 b3					.word Command_Return           ; $003a ;
>a202	6e b0					.word Command_Assert           ; $003b assert
>a204	69 ac					.word Cmd_List                 ; $003c list
>a206	33 b0					.word Command_New              ; $003d new
>a208	3a b0					.word Command_Old              ; $003e old
>a20a	64 b0					.word Command_Stop             ; $003f stop
>a20c	f2 a4					.word ExecuteProgram           ; $0040 run
>a20e	60 b0					.word Command_End              ; $0041 end
>a210	05 af					.word System_Save              ; $0042 save
>a212	20 af					.word System_Load              ; $0043 load

;******  Return to file: main.asm


;******  Processing file: generated/assembler.inc

=2					ASM_FIRST_2BYTE = 2
=10					ASM_FIRST_3BYTE = 10
=0					ASM_MODE_IMP = 0
=1					ASM_MODE_A = 1
=2					ASM_MODE_IMM = 2
=3					ASM_MODE_RL = 3
=4					ASM_MODE_ZP = 4
=5					ASM_MODE_ZX = 5
=6					ASM_MODE_ZY = 6
=7					ASM_MODE_IX = 7
=8					ASM_MODE_IY = 8
=9					ASM_MODE_IN = 9
=10					ASM_MODE_AB = 10
=11					ASM_MODE_AX = 11
=12					ASM_MODE_AY = 12
=13					ASM_MODE_IA = 13
=14					ASM_MODE_IAX = 14
.a214					LowBytes:
>a214	2b 21 00 00 42 21 4c 00			.byte $2b,$21,$00,$00,$42,$21,$4c,$00,$f0,$21,$4c,$00,$42,$21,$4c,$00,$ec,$21,$21,$00,$22,$21,$4c,$00,$63,$21,$a3,$00,$22,$21,$4c,$00,$52,$a4,$00,$00,$14,$a4,$cc,$00,$70,$a4,$cc,$00,$14,$a4,$cc,$00,$89,$a4,$a4,$00,$14,$a4,$cc,$00,$83,$a4,$83,$00,$14,$a4,$cc,$00,$69,$d2,$00,$00,$00,$d2,$52,$00,$e1,$d2,$52,$00,$90,$d2,$52,$00,$a3,$d2,$d2,$00,$00,$d2,$52,$00,$69,$d2,$f9,$00,$00,$d2,$52,$00,$73,$63,$00,$00,$7a,$63,$d2,$00,$61,$63,$d2,$00,$90,$63,$d2,$00,$b3,$63,$63,$00,$7a,$63,$d2,$00,$89,$63,$79,$00,$90,$63,$d2,$00,$21,$61,$00,$00,$79,$61,$78,$00,$99,$14,$e1,$00,$79,$61,$78,$00,$43,$61,$61,$00,$79,$61,$78,$00,$01,$61,$f3,$00,$7a,$61,$7a,$00,$79,$61,$78,$00,$79,$61,$78,$00,$19,$61,$18,$00,$79,$61,$78,$00,$53,$61,$61,$00,$79,$61,$78,$00,$76,$61,$58,$00,$79,$61,$78,$00,$f9,$90,$00,$00,$f9,$90,$83,$00,$b9,$90,$98,$00,$f9,$90,$83,$00,$a5,$90,$90,$00,$00,$90,$83,$00,$64,$90,$f8,$00,$00,$90,$83,$00,$f8,$23,$00,$00,$f8,$23,$a3,$00,$b8,$23,$d0,$00,$f8,$23,$a3,$00,$91,$23,$23,$00,$00,$23,$a3,$00,$84,$23,$78,$00,$00,$23,$a3,$00
>a21c	f0 21 4c 00 42 21 4c 00 ec 21 21 00 22 21 4c 00
>a22c	63 21 a3 00 22 21 4c 00 52 a4 00 00 14 a4 cc 00
>a23c	70 a4 cc 00 14 a4 cc 00 89 a4 a4 00 14 a4 cc 00
>a24c	83 a4 83 00 14 a4 cc 00 69 d2 00 00 00 d2 52 00
>a25c	e1 d2 52 00 90 d2 52 00 a3 d2 d2 00 00 d2 52 00
>a26c	69 d2 f9 00 00 d2 52 00 73 63 00 00 7a 63 d2 00
>a27c	61 63 d2 00 90 63 d2 00 b3 63 63 00 7a 63 d2 00
>a28c	89 63 79 00 90 63 d2 00 21 61 00 00 79 61 78 00
>a29c	99 14 e1 00 79 61 78 00 43 61 61 00 79 61 78 00
>a2ac	01 61 f3 00 7a 61 7a 00 79 61 78 00 79 61 78 00
>a2bc	19 61 18 00 79 61 78 00 53 61 61 00 79 61 78 00
>a2cc	76 61 58 00 79 61 78 00 f9 90 00 00 f9 90 83 00
>a2dc	b9 90 98 00 f9 90 83 00 a5 90 90 00 00 90 83 00
>a2ec	64 90 f8 00 00 90 83 00 f8 23 00 00 f8 23 a3 00
>a2fc	b8 23 d0 00 f8 23 a3 00 91 23 23 00 00 23 a3 00
>a30c	84 23 78 00 00 23 a3 00
.a314					HighBytes:
>a314	0b 3f 00 00 53 3f 07 00			.byte $0b,$3f,$00,$00,$53,$3f,$07,$00,$41,$3f,$07,$00,$53,$3f,$07,$00,$0a,$3f,$3f,$00,$53,$3f,$07,$00,$0e,$3f,$26,$00,$53,$3f,$07,$00,$2b,$06,$00,$00,$0a,$06,$4a,$00,$42,$06,$4a,$00,$0a,$06,$4a,$00,$0a,$06,$06,$00,$0a,$06,$4a,$00,$4d,$06,$11,$00,$0a,$06,$4a,$00,$4b,$16,$00,$00,$00,$16,$33,$00,$41,$16,$33,$00,$2a,$16,$33,$00,$0b,$16,$16,$00,$00,$16,$33,$00,$0e,$16,$41,$00,$00,$16,$33,$00,$4b,$05,$00,$00,$4f,$05,$4a,$00,$42,$05,$4a,$00,$2a,$05,$4a,$00,$0b,$05,$05,$00,$4f,$05,$4a,$00,$4d,$05,$42,$00,$2a,$05,$4a,$00,$0b,$4f,$00,$00,$4f,$4f,$4f,$00,$11,$0a,$53,$00,$4f,$4f,$4f,$00,$09,$4f,$4f,$00,$4f,$4f,$4f,$00,$54,$4f,$53,$00,$4f,$4f,$4f,$00,$31,$31,$31,$00,$31,$31,$31,$00,$51,$31,$51,$00,$31,$31,$31,$00,$09,$31,$31,$00,$31,$31,$31,$00,$0e,$31,$53,$00,$31,$31,$31,$00,$0e,$0e,$00,$00,$0e,$0e,$11,$00,$26,$0e,$11,$00,$0e,$0e,$11,$00,$0a,$0e,$0e,$00,$00,$0e,$11,$00,$0e,$0e,$41,$00,$00,$0e,$11,$00,$0e,$4d,$00,$00,$0e,$4d,$26,$00,$26,$4d,$3a,$00,$0e,$4d,$26,$00,$09,$4d,$4d,$00,$00,$4d,$26,$00,$4d,$4d,$42,$00,$00,$4d,$26,$00
>a31c	41 3f 07 00 53 3f 07 00 0a 3f 3f 00 53 3f 07 00
>a32c	0e 3f 26 00 53 3f 07 00 2b 06 00 00 0a 06 4a 00
>a33c	42 06 4a 00 0a 06 4a 00 0a 06 06 00 0a 06 4a 00
>a34c	4d 06 11 00 0a 06 4a 00 4b 16 00 00 00 16 33 00
>a35c	41 16 33 00 2a 16 33 00 0b 16 16 00 00 16 33 00
>a36c	0e 16 41 00 00 16 33 00 4b 05 00 00 4f 05 4a 00
>a37c	42 05 4a 00 2a 05 4a 00 0b 05 05 00 4f 05 4a 00
>a38c	4d 05 42 00 2a 05 4a 00 0b 4f 00 00 4f 4f 4f 00
>a39c	11 0a 53 00 4f 4f 4f 00 09 4f 4f 00 4f 4f 4f 00
>a3ac	54 4f 53 00 4f 4f 4f 00 31 31 31 00 31 31 31 00
>a3bc	51 31 51 00 31 31 31 00 09 31 31 00 31 31 31 00
>a3cc	0e 31 53 00 31 31 31 00 0e 0e 00 00 0e 0e 11 00
>a3dc	26 0e 11 00 0e 0e 11 00 0a 0e 0e 00 00 0e 11 00
>a3ec	0e 0e 41 00 00 0e 11 00 0e 4d 00 00 0e 4d 26 00
>a3fc	26 4d 3a 00 0e 4d 26 00 09 4d 4d 00 00 4d 26 00
>a40c	4d 4d 42 00 00 4d 26 00
.a414					ModeNibbles:
>a414	07 ff 44 4f 02 1f aa af			.byte $07,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$45,$5f,$0c,$1f,$ab,$bf,$17,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$55,$5f,$0c,$1f,$bb,$bf,$07,$ff,$f4,$4f,$02,$1f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$07,$ff,$44,$4f,$02,$1f,$da,$af,$38,$9f,$55,$5f,$0c,$0f,$eb,$bf,$37,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$ab,$bf,$27,$2f,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$bb,$cf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf
>a41c	38 9f 45 5f 0c 1f ab bf 17 ff 44 4f 02 1f aa af
>a42c	38 9f 55 5f 0c 1f bb bf 07 ff f4 4f 02 1f aa af
>a43c	38 9f f5 5f 0c 0f fb bf 07 ff 44 4f 02 1f da af
>a44c	38 9f 55 5f 0c 0f eb bf 37 ff 44 4f 02 0f aa af
>a45c	38 9f 55 6f 0c 0f ab bf 27 2f 44 4f 02 0f aa af
>a46c	38 9f 55 6f 0c 0f bb cf 27 ff 44 4f 02 0f aa af
>a47c	38 9f f5 5f 0c 0f fb bf 27 ff 44 4f 02 0f aa af
>a48c	38 9f f5 5f 0c 0f fb bf

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a494					SyntaxError:
.a494	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a497	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a49e					ErrorHandler:
.a49e	fa		plx				plx 								; pull address off.
.a49f	7a		ply				ply
.a4a0	e8		inx				inx 								; point to message
.a4a1	d0 01		bne $a4a4			bne 	_EHNoCarry
.a4a3	c8		iny				iny
.a4a4					_EHNoCarry:
.a4a4	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY 				; print string at XY
.a4a7	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a4a9	f0 13		beq $a4be			beq 	_EHNoLine
.a4ab	a2 c6		ldx #$c6			ldx 	#_EHMessage & $FF 			; print " AT "
.a4ad	a0 a4		ldy #$a4			ldy 	#_EHMessage >> 8
.a4af	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a4b2	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a4b4	b1 00		lda ($00),y			lda 	(codePtr),y
.a4b6	aa		tax				tax
.a4b7	c8		iny				iny
.a4b8	b1 00		lda ($00),y			lda 	(codePtr),y
.a4ba	a8		tay				tay
.a4bb	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.a4be					_EHNoLine:
.a4be	a9 0d		lda #$0d			lda 	#13
.a4c0	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.a4c3	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a4c6					_EHMessage:
>a4c6	20 41 54 20 00					.text	" AT ",0
.a4cb					PrintIntegerUnsigned:
.a4cb	20 e7 a8	jsr $a8e7			jsr 	IntToString
.a4ce	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a4d0	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a4d2	20 d7 a4	jsr $a4d7			jsr 	PrintStringXY
.a4d5	98		tya				tya
.a4d6	60		rts				rts
.a4d7					PrintStringXY:
.a4d7	86 02		stx $02				stx 	zTemp0
.a4d9	84 03		sty $03				sty 	zTemp0+1
.a4db	a0 00		ldy #$00			ldy 	#0
.a4dd	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a4df	f0 06		beq $a4e7			beq 	_PSExit
.a4e1	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.a4e4	c8		iny				iny
.a4e5	80 f6		bra $a4dd			bra 	_PSLoop
.a4e7	60		rts		_PSExit:rts
.a4e8					PrintCharacter:
.a4e8	48		pha				pha
.a4e9	da		phx				phx
.a4ea	5a		phy				phy
.a4eb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a4ee	7a		ply				ply
.a4ef	fa		plx				plx
.a4f0	68		pla				pla
.a4f1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a4f2					ExecuteProgram:
.a4f2	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.a4f4	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.a4f6					ExecuteFromXY:
.a4f6	20 de a7	jsr $a7de			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a4f9	20 1a a8	jsr $a81a			jsr 	StackReset 					; reset the CPU stack.
.a4fc	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a4fe	80 0a		bra $a50a			bra 	ExecuteLoop
.a500					ShortConstant:
.a500	c8		iny				iny 								; skip short const
.a501	e8		inx				inx 								; space on stack
.a502	29 3f		and #$3f			and 	#$3F 						; the value
.a504	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a507	9e 00 07	stz $0700,x			stz 	highStack,x
.a50a					ExecuteLoop:
.a50a	e6 18		inc $18				inc 	breakCount 					; check break sometimes.
.a50c	d0 03		bne $a511			bne 	_EXNoBreak
.a50e	20 c9 a5	jsr $a5c9			jsr 	ExternCheckBreak
.a511					_EXNoBreak:
.a511	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a513	f0 57		beq $a56c			beq 	_ELUnderflow
.a515	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a517	30 07		bmi $a520			bmi 	_ELNotToken
.a519	c8		iny				iny 								; skip the token
.a51a	da		phx				phx 								; save X on the stack
.a51b	0a		asl a				asl 	a 							; double the token, put into X
.a51c	aa		tax				tax
.a51d	7c 8c a1	jmp ($a18c,x)			jmp 	(DispatchHandler,x)
.a520					_ELNotToken:
.a520	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a522	90 dc		bcc $a500			bcc 	ShortConstant 				; yes, it's a short constant
.a524	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a526	90 1e		bcc $a546			bcc 	_ELNotFastVariable
.a528	c8		iny				iny 								; get the next token.
.a529	b1 00		lda ($00),y			lda 	(codePtr),y
.a52b	88		dey				dey
.a52c	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a52e	f0 16		beq $a546			beq 	_ELNotFastVariable 			; which we can optimise.
.a530	5a		phy				phy 								; save Y
.a531	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a533	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a534	a8		tay				tay 								; access via Y
.a535	e8		inx				inx 								; make space on the stack.
.a536	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a539	9d 00 06	sta $0600,x			sta 	lowStack,x
.a53c	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a53f	9d 00 07	sta $0700,x			sta 	highStack,x
.a542	7a		ply				ply 								; restore code pointer
.a543	c8		iny				iny 								; skip variable.
.a544	80 c4		bra $a50a			bra 	ExecuteLoop
.a546					_ELNotFastVariable:
.a546	18		clc				clc									; do not autocreate if not found.
.a547	20 32 a9	jsr $a932			jsr 	VariableFind				; find the variable.
.a54a	90 14		bcc $a560			bcc 	_ELUnknown
.a54c	20 a5 a6	jsr $a6a5			jsr 	IndexCheck
.a54f	5a		phy				phy 								; copy to stack
.a550	e8		inx				inx
.a551	b2 02		lda ($02)			lda 	(zTemp0)
.a553	9d 00 06	sta $0600,x			sta 	lowStack,x
.a556	a0 01		ldy #$01			ldy 	#1
.a558	b1 02		lda ($02),y			lda 	(zTemp0),y
.a55a	9d 00 07	sta $0700,x			sta 	highStack,x
.a55d	7a		ply				ply
.a55e	80 aa		bra $a50a			bra 	ExecuteLoop
.a560					_ELUnknown:
.a560	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a563	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a56b	00
.a56c					_ELUnderflow:
.a56c	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a56f	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a576					ExecuteNextLine:
.a576					ExecuteComment:
.a576	fa		plx				plx
.a577	18		clc				clc 								; skip forward
.a578	b2 00		lda ($00)			lda 	(codePtr)
.a57a	18		clc				clc
.a57b	65 00		adc $00				adc 	codePtr
.a57d	85 00		sta $00				sta 	codePtr
.a57f	90 02		bcc $a583			bcc 	_ENLNoCarry
.a581	e6 01		inc $01				inc 	codePtr+1
.a583					_ENLNoCarry:
.a583	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a585	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a587	d0 81		bne $a50a			bne 	ExecuteLoop
.a589	4c 60 b0	jmp $b060			jmp	 	Command_End 				; if zero end program.
.a58c					LongConstant:
.a58c	fa		plx				plx
.a58d	e8		inx				inx 								; space for constant
.a58e	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a590	9d 00 06	sta $0600,x			sta 	lowStack,x
.a593	c8		iny				iny
.a594	b1 00		lda ($00),y			lda 	(codePtr),y
.a596	9d 00 07	sta $0700,x			sta 	highStack,x
.a599	c8		iny				iny
.a59a	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.a59d					StringConstant:
.a59d	fa		plx				plx
.a59e	e8		inx				inx
.a59f	18		clc				clc 								; copy Y + codePtr in.
.a5a0	98		tya				tya
.a5a1	65 00		adc $00				adc 	codePtr
.a5a3	9d 00 06	sta $0600,x			sta 	lowStack,x
.a5a6	a5 01		lda $01				lda 	codePtr+1
.a5a8	69 00		adc #$00			adc 	#0
.a5aa	9d 00 07	sta $0700,x			sta 	highStack,x
.a5ad	98		tya				tya 								; add 1 + length to Y
.a5ae	38		sec				sec
.a5af	71 00		adc ($00),y			adc 	(codePtr),y
.a5b1	a8		tay				tay
.a5b2	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a5b5					ExternInitialise:
.a5b5	a9 02		lda #$02			lda 	#$02 						; set colour
.a5b7	8d 86 02	sta $0286			sta 	646
.a5ba	a9 0e		lda #$0e			lda 	#14							; lower case
.a5bc	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5bf	a9 93		lda #$93			lda 	#147 						; clear screen
.a5c1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5c4	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a5c6	4c e7 a5	jmp $a5e7			jmp 	ExternColour
.a5c9					ExternCheckBreak:
.a5c9	da		phx				phx 								; make sure we keep XY
.a5ca	5a		phy				phy
.a5cb	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a5ce	f0 03		beq $a5d3			beq		_ECBExit 					; stopped
.a5d0	7a		ply				ply 								; restore and exit.
.a5d1	fa		plx				plx
.a5d2	60		rts				rts
.a5d3					_ECBExit:
.a5d3	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a5d6	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a5dd					ExternPrint:
.a5dd	48		pha				pha
.a5de	da		phx				phx
.a5df	5a		phy				phy
.a5e0	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a5e3	7a		ply				ply
.a5e4	fa		plx				plx
.a5e5	68		pla				pla
.a5e6	60		rts				rts
.a5e7					ExternColour:
.a5e7	48		pha				pha
.a5e8	da		phx				phx
.a5e9	48		pha				pha
.a5ea	29 08		and #$08			and 	#8
.a5ec	0a		asl a				asl 	a
.a5ed	0a		asl a				asl 	a
.a5ee	0a		asl a				asl 	a
.a5ef	0a		asl a				asl 	a
.a5f0	49 92		eor #$92			eor 	#$92
.a5f2	20 dd a5	jsr $a5dd			jsr 	ExternPrint
.a5f5	68		pla				pla
.a5f6	29 07		and #$07			and 	#7
.a5f8	aa		tax				tax
.a5f9	bd 02 a6	lda $a602,x			lda 	_ECTable,x
.a5fc	20 dd a5	jsr $a5dd			jsr 	ExternPrint
.a5ff	fa		plx				plx
.a600	68		pla				pla
.a601	60		rts				rts
.a602					_ECTable:
>a602	90						.byte 	144
>a603	1c						.byte 	28
>a604	1e						.byte 	30
>a605	9e						.byte 	158
>a606	1f						.byte 	31
>a607	9c						.byte 	156
>a608	9f						.byte 	159
>a609	05						.byte 	5
.a60a					ExternInput:
.a60a	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a60c	85 02		sta $02				sta 	zTemp0
.a60e	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a610	85 03		sta $03				sta 	zTemp0+1
.a612	a9 07		lda #$07			lda 	#COL_WHITE
.a614	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.a617	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a61a	29 7f		and #$7f			and 	#$7F
.a61c	c9 0d		cmp #$0d			cmp 	#13
.a61e	f0 0a		beq $a62a			beq 	_EIExit
.a620	92 02		sta ($02)			sta 	(zTemp0)
.a622	e6 02		inc $02				inc 	zTemp0
.a624	d0 f1		bne $a617			bne 	_EIRead
.a626	e6 03		inc $03				inc 	zTemp0+1
.a628	80 ed		bra $a617			bra 	_EIRead
.a62a	a9 00		lda #$00	_EIExit:lda 	#0
.a62c	92 02		sta ($02)			sta 	(zTemp0)
.a62e	a9 0d		lda #$0d			lda 	#13
.a630	20 dd a5	jsr $a5dd			jsr 	ExternPrint
.a633	60		rts				rts
.a634					ExternSave:
.a634	da		phx				phx
.a635	5a		phy				phy
.a636	85 06		sta $06				sta 	zTemp2 						; save start
.a638	84 07		sty $07				sty 	zTemp2+1
.a63a	20 9c a6	jsr $a69c			jsr 	EXGetLength 				; get length of file into A
.a63d	a6 02		ldx $02				ldx 	zTemp0
.a63f	a4 03		ldy $03				ldy 	zTemp0+1
.a641	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a644	a9 01		lda #$01			lda 	#1
.a646	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a648	a0 00		ldy #$00			ldy 	#0
.a64a	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a64d	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a64f	a4 05		ldy $05				ldy 	zTemp1+1
.a651	a9 06		lda #$06			lda 	#zTemp2
.a653	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a656	b0 03		bcs $a65b			bcs 	_ESSave
.a658	7a		ply				ply
.a659	fa		plx				plx
.a65a	60		rts				rts
.a65b					_ESSave:
.a65b	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a65e	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a666	4c 45 44 00
.a66a					ExternLoad:
.a66a	da		phx				phx 								; save XY
.a66b	5a		phy				phy
.a66c	48		pha				pha 								; save target
.a66d	5a		phy				phy
.a66e	20 9c a6	jsr $a69c			jsr 	EXGetLength 				; get length of file into A
.a671	a6 02		ldx $02				ldx 	zTemp0
.a673	a4 03		ldy $03				ldy 	zTemp0+1
.a675	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a678	a9 01		lda #$01			lda 	#1
.a67a	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a67c	a0 00		ldy #$00			ldy 	#0
.a67e	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a681	7a		ply				ply 								; restore target to YX and call load
.a682	fa		plx				plx
.a683	a9 00		lda #$00			lda 	#0 							; load command
.a685	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a688	b0 03		bcs $a68d			bcs 	_ESLoad
.a68a	7a		ply				ply
.a68b	fa		plx				plx
.a68c	60		rts				rts
.a68d					_ESLoad:
.a68d	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a690	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a698	4c 45 44 00
.a69c					EXGetLength:
.a69c	b2 02		lda ($02)			lda 	(zTemp0) 					; get name length
.a69e	e6 02		inc $02				inc 	zTemp0 						; bump ptr past it
.a6a0	d0 02		bne $a6a4			bne 	_EXGLExit
.a6a2	e6 03		inc $03				inc 	zTemp0+1
.a6a4					_EXGLExit:
.a6a4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a6a5					IndexCheck:
.a6a5	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a6a7	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a6a9	f0 01		beq $a6ac			beq 	_ICFound
.a6ab	60		rts				rts
.a6ac					_ICFound:
.a6ac	c8		iny				iny 							; get next
.a6ad	b1 00		lda ($00),y			lda 	(codePtr),y
.a6af	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a6b1	f0 2b		beq $a6de			beq 	_ICStackIndex
.a6b3	38		sec				sec
.a6b4	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a6b6	c9 40		cmp #$40			cmp 	#$40
.a6b8	b0 1a		bcs $a6d4			bcs 	_ICError
.a6ba	0a		asl a				asl 	a 						; double index clear carry
.a6bb	5a		phy				phy 							; put into Y
.a6bc	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a6be	48		pha				pha
.a6bf	a0 01		ldy #$01			ldy 	#1
.a6c1	b1 02		lda ($02),y			lda 	(zTemp0),y
.a6c3	69 00		adc #$00			adc 	#0
.a6c5	85 03		sta $03				sta 	zTemp0+1
.a6c7	68		pla				pla
.a6c8	85 02		sta $02				sta 	zTemp0
.a6ca	7a		ply				ply 							; restore position.
.a6cb	c8		iny				iny								; skip index
.a6cc	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a6ce	c8		iny				iny
.a6cf	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a6d1	d0 01		bne $a6d4			bne 	_ICError
.a6d3	60		rts				rts
.a6d4					_ICError:
.a6d4	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a6d7	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a6de					_ICStackIndex:
.a6de	c8		iny				iny 							; skip the ]
.a6df	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a6e2	0a		asl a				asl 	a
.a6e3	85 04		sta $04				sta 	zTemp1
.a6e5	bd 00 07	lda $0700,x			lda 	highStack,x
.a6e8	2a		rol a				rol 	a
.a6e9	85 05		sta $05				sta 	zTemp1+1
.a6eb	ca		dex				dex 							; throw TOS.
.a6ec	5a		phy				phy
.a6ed	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a6ef	b2 02		lda ($02)			lda 	(zTemp0)
.a6f1	65 04		adc $04				adc 	zTemp1
.a6f3	48		pha				pha
.a6f4	b1 02		lda ($02),y			lda 	(zTemp0),y
.a6f6	65 05		adc $05				adc 	zTemp1+1
.a6f8	85 03		sta $03				sta 	zTemp0+1
.a6fa	68		pla				pla
.a6fb	85 02		sta $02				sta 	zTemp0
.a6fd	7a		ply				ply 							; restore pos and exit.
.a6fe	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/program.asm

.a6ff					EditProgram:
.a6ff	86 0d		stx $0d				stx 	zTemp5+1 					; save line number.
.a701	85 0c		sta $0c				sta 	zTemp5
.a703	5a		phy				phy 								; save token buffer offset
.a704	20 27 a7	jsr $a727			jsr 	EDFindLine					; find line address -> zTemp1
.a707	90 0f		bcc $a718			bcc 	_EPNotFound 				; if missing don't delete it.
.a709	a5 04		lda $04				lda 	zTemp1 						; save line address
.a70b	48		pha				pha
.a70c	a5 05		lda $05				lda 	zTemp1+1
.a70e	48		pha				pha
.a70f	20 5c a7	jsr $a75c			jsr 	EDDeleteLine 				; delete the line
.a712	68		pla				pla 								; restore line address
.a713	85 05		sta $05				sta 	zTemp1+1
.a715	68		pla				pla
.a716	85 04		sta $04				sta 	zTemp1
.a718					_EPNotFound:
.a718	7a		ply				ply 								; get offset
.a719	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; if something after line#
.a71c	f0 03		beq $a721			beq 	_EPNoInsert
.a71e	20 7f a7	jsr $a77f			jsr 	EDInsertLine 				; insert line back in.
.a721					_EPNoInsert:
.a721	20 de a7	jsr $a7de			jsr 	ResetMemory
.a724	4c 1b a0	jmp $a01b			jmp 	WarmStart
.a727					EDFindLine:
.a727	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a729	85 04		sta $04				sta 	zTemp1
.a72b	a9 10		lda #$10			lda 	#ProgramStart >> 8
.a72d	85 05		sta $05				sta 	zTemp1+1
.a72f					_EDFLLoop:
.a72f	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a731	b1 04		lda ($04),y			lda 	(zTemp1),y
.a733	f0 23		beq $a758			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a735	c8		iny				iny
.a736	38		sec				sec
.a737	a5 0c		lda $0c				lda 	zTemp5						; subtract the current from the target
.a739	f1 04		sbc ($04),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a73b	aa		tax				tax	 								; this will return 10.
.a73c	a5 0d		lda $0d				lda 	zTemp5+1
.a73e	c8		iny				iny
.a73f	f1 04		sbc ($04),y			sbc 	(zTemp1),y
.a741	90 15		bcc $a758			bcc 	_EDFLFail					; if target < current then failed.
.a743	d0 04		bne $a749			bne 	_EDFLNext 					; if non-zero then goto next
.a745	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a747	f0 11		beq $a75a			beq 	_EDFLFound
.a749					_EDFLNext:
.a749	a0 00		ldy #$00			ldy 	#0 							; get offset
.a74b	18		clc				clc
.a74c	b1 04		lda ($04),y			lda 	(zTemp1),y
.a74e	65 04		adc $04				adc 	zTemp1 						; add to pointer
.a750	85 04		sta $04				sta 	zTemp1
.a752	90 db		bcc $a72f			bcc 	_EDFLLoop
.a754	e6 05		inc $05				inc 	zTemp1+1 					; carry out.
.a756	80 d7		bra $a72f			bra 	_EDFLLoop
.a758					_EDFLFail:
.a758	18		clc				clc
.a759	60		rts				rts
.a75a					_EDFLFound:
.a75a	38		sec				sec
.a75b	60		rts				rts
.a75c					EDDeleteLine:
.a75c	20 fc a7	jsr $a7fc			jsr 	ResetVarMemory
.a75f	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a761	a2 00		ldx #$00			ldx 	#0
.a763	b1 04		lda ($04),y			lda 	(zTemp1),y
.a765	a8		tay				tay 								; put in Y
.a766					_EDDelLoop:
.a766	b1 04		lda ($04),y			lda 	(zTemp1),y 					; get it
.a768	81 04		sta ($04,x)			sta 	(zTemp1,x) 					; write it.
.a76a	a5 04		lda $04				lda 	zTemp1 						; check if pointer has reached the end of
.a76c	c5 13		cmp $13				cmp		memVarPtr 					; low memory. We will have copied down an
.a76e	d0 06		bne $a776			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a770	a5 05		lda $05				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a772	c5 14		cmp $14				cmp 	memVarPtr+1					; doesn't really matter.
.a774	f0 08		beq $a77e			beq		_EDDelExit
.a776					_EDDelNext:
.a776	e6 04		inc $04				inc 	zTemp1 						; go to next byte.
.a778	d0 ec		bne $a766			bne 	_EDDelLoop
.a77a	e6 05		inc $05				inc 	zTemp1+1
.a77c	80 e8		bra $a766			bra 	_EDDelLoop
.a77e					_EDDelExit:
.a77e	60		rts				rts
.a77f					EDInsertLine:
.a77f	84 02		sty $02				sty 	zTemp0						; zTemp0 = address of code.
.a781	a9 0a		lda #$0a			lda 	#TokenBuffer >> 8
.a783	85 03		sta $03				sta 	zTemp0+1
.a785	20 fc a7	jsr $a7fc			jsr 	ResetVarMemory
.a788	a5 13		lda $13				lda 	memVarPtr 					; copy high memory to zTemp3
.a78a	85 08		sta $08				sta 	zTemp3
.a78c	a5 14		lda $14				lda 	memVarPtr+1
.a78e	85 09		sta $09				sta 	zTemp3+1
.a790	a5 19		lda $19				lda 	TokenOffset 				; work out the space needed.
.a792	38		sec				sec
.a793	e5 02		sbc $02				sbc 	zTemp0
.a795	18		clc				clc
.a796	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a798	48		pha				pha 								; save total size (e.g. offset)
.a799	85 0a		sta $0a				sta 	zTemp4 						; save for copying
.a79b	a8		tay				tay 								; in Y
.a79c	a2 00		ldx #$00			ldx 	#0
.a79e					_EDInsLoop:
.a79e	a1 08		lda ($08,x)			lda 	(zTemp3,x)					; copy it up
.a7a0	91 08		sta ($08),y			sta 	(zTemp3),y
.a7a2	a5 08		lda $08				lda 	zTemp3 						; reached the insert point (zTemp1)
.a7a4	c5 04		cmp $04				cmp 	zTemp1
.a7a6	d0 06		bne $a7ae			bne 	_EDINextShift
.a7a8	a5 09		lda $09				lda 	zTemp3+1
.a7aa	c5 05		cmp $05				cmp 	zTemp1+1
.a7ac	f0 0a		beq $a7b8			beq 	_EDIShiftOver
.a7ae					_EDINextShift:
.a7ae	a5 08		lda $08				lda 	zTemp3 					; decrement the copy pointer.
.a7b0	d0 02		bne $a7b4			bne 	_EDINoBorrow
.a7b2	c6 09		dec $09				dec 	zTemp3+1
.a7b4					_EDINoBorrow:
.a7b4	c6 08		dec $08				dec 	zTemp3
.a7b6	80 e6		bra $a79e			bra 	_EDInsLoop
.a7b8					_EDIShiftOver:
.a7b8	68		pla				pla 								; this is the size + others, e.g. offset
.a7b9	a0 00		ldy #$00			ldy 	#0
.a7bb	91 08		sta ($08),y			sta 	(zTemp3),y 					; write that out.
.a7bd	a5 0c		lda $0c				lda 	zTemp5 						; write Line# out
.a7bf	c8		iny				iny
.a7c0	91 08		sta ($08),y			sta 	(zTemp3),y
.a7c2	a5 0d		lda $0d				lda 	zTemp5+1
.a7c4	c8		iny				iny
.a7c5	91 08		sta ($08),y			sta 	(zTemp3),y
.a7c7	c8		iny				iny 								; where the code goes.
.a7c8	a2 00		ldx #$00			ldx 	#0 							; comes from
.a7ca					_EDICopyCode:
.a7ca	a1 02		lda ($02,x)			lda 	(zTemp0,x)					; read from the current line
.a7cc	91 08		sta ($08),y			sta 	(zTemp3),y 					; write out
.a7ce	c8		iny				iny 								; bump pointers
.a7cf	e6 02		inc $02				inc 	zTemp0
.a7d1	d0 02		bne $a7d5			bne 	_EDINoCarry
.a7d3	e6 03		inc $03				inc 	zTemp0+1
.a7d5					_EDINoCarry:
.a7d5	c6 0a		dec $0a				dec 	zTemp4 						; copy data in
.a7d7	a5 0a		lda $0a				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.a7d9	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.a7db	d0 ed		bne $a7ca			bne 	_EDICopyCode
.a7dd	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a7de					ResetMemory:
.a7de	da		phx				phx									; save run address
.a7df	5a		phy				phy
.a7e0	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a7e2	85 11		sta $11				sta 	allocPtr
.a7e4	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a7e6	85 12		sta $12				sta 	allocPtr+1
.a7e8	20 fc a7	jsr $a7fc			jsr 	ResetVarMemory
.a7eb	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a7ed					_RMEraseHash:
.a7ed	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a7f0	ca		dex				dex
.a7f1	10 fa		bpl $a7ed			bpl 	_RMEraseHash
.a7f3	7a		ply				ply 								; restore and set run address
.a7f4	fa		plx				plx
.a7f5	84 01		sty $01				sty 	codePtr+1
.a7f7	86 00		stx $00				stx 	codePtr
.a7f9	a0 03		ldy #$03			ldy 	#3
.a7fb	60		rts				rts
.a7fc					ResetVarMemory:
.a7fc	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a7fe	85 13		sta $13				sta 	memVarPtr
.a800	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a802	85 14		sta $14				sta 	memVarPtr+1
.a804					_RMFindEnd:
.a804	b2 13		lda ($13)			lda 	(memVarPtr)					; offset 0, found end.
.a806	f0 0b		beq $a813			beq 	_RMFoundEnd 				; advance to next.
.a808	18		clc				clc
.a809	65 13		adc $13				adc 	memVarPtr
.a80b	85 13		sta $13				sta 	memVarPtr
.a80d	90 f5		bcc $a804			bcc 	_RMFindEnd
.a80f	e6 14		inc $14				inc 	memVarPtr+1
.a811	80 f1		bra $a804			bra 	_RMFindEnd
.a813					_RMFoundEnd:
.a813	e6 13		inc $13				inc 	memVarPtr 					; advance past last offset $00
.a815	d0 02		bne $a819			bne 	_RMNoCarry
.a817	e6 14		inc $14				inc 	memVarPtr+1
.a819					_RMNoCarry:
.a819	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a81a					StackReset:
.a81a	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a81c	85 0e		sta $0e				sta 	iStack
.a81e	a9 09		lda #$09			lda 	#IntStack >> 8
.a820	85 0f		sta $0f				sta 	iStack+1
.a822	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a824	92 0e		sta ($0e)			sta 	(iStack)
.a826	60		rts				rts
.a827					StackPushByte:
.a827	c6 0e		dec $0e				dec 	iStack
.a829	92 0e		sta ($0e)			sta 	(iStack)
.a82b	f0 01		beq $a82e			beq 	_SPBUnderflow
.a82d	60		rts				rts
.a82e					_SPBUnderflow:
.a82e	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a831	53 54 41 43 4b 00				.text 	"STACK",0
.a837					StackPushPosition:
.a837	98		tya				tya
.a838	20 27 a8	jsr $a827			jsr 	StackPushByte
.a83b	a5 01		lda $01				lda 	codePtr+1
.a83d	20 27 a8	jsr $a827			jsr 	StackPushByte
.a840	a5 00		lda $00				lda 	codePtr
.a842	20 27 a8	jsr $a827			jsr 	StackPushByte
.a845	60		rts				rts
.a846					StackCheckTop:
.a846	d2 0e		cmp ($0e)			cmp 	(iStack)
.a848	f0 02		beq $a84c			beq 	_SCTOk
.a84a	18		clc				clc
.a84b	60		rts				rts
.a84c	38		sec		_SCTOk:	sec
.a84d	60		rts				rts
.a84e					StackPop:
.a84e	18		clc				clc
.a84f	65 0e		adc $0e				adc 	iStack
.a851	85 0e		sta $0e				sta 	iStack
.a853	60		rts				rts
.a854					StackRestorePosition:
.a854	b1 0e		lda ($0e),y			lda 	(iStack),y
.a856	85 00		sta $00				sta 	codePtr
.a858	c8		iny				iny
.a859	b1 0e		lda ($0e),y			lda 	(iStack),y
.a85b	85 01		sta $01				sta 	codePtr+1
.a85d	c8		iny				iny
.a85e	b1 0e		lda ($0e),y			lda 	(iStack),y
.a860	a8		tay				tay
.a861	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a862					StringToInt:
.a862	86 08		stx $08				stx 	zTemp3 						; save string
.a864	84 09		sty $09				sty 	zTemp3+1
.a866	64 10		stz $10				stz 	signCount 					; signcount is the number of chars copied.
.a868	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a86a	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a86c	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a86e	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a870	f0 03		beq $a875			beq 	_STIConvert 				; convert from character 1, base 16.
.a872	88		dey				dey 								; from character 0
.a873	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a875					_STIConvert:
.a875	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a877	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a879	f0 5f		beq $a8da			beq 	_STIFail 					; if zero, then it has failed anyway.
.a87b	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a87d	64 03		stz $03				stz 	zTemp0+1
.a87f					_STILoop:
.a87f	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a881	c9 30		cmp #$30			cmp 	#"0"
.a883	90 55		bcc $a8da			bcc 	_STIFail
.a885	c9 3a		cmp #$3a			cmp 	#"9"+1
.a887	90 08		bcc $a891			bcc 	_STIOkay
.a889	c9 41		cmp #$41			cmp 	#"A"
.a88b	90 4d		bcc $a8da			bcc 	_STIFail
.a88d	c9 47		cmp #$47			cmp 	#"F"+1
.a88f	b0 49		bcs $a8da			bcs 	_STIFail
.a891					_STIOkay:
.a891	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a893	85 06		sta $06				sta 	zTemp2
.a895	a5 03		lda $03				lda 	zTemp0+1
.a897	85 07		sta $07				sta 	zTemp2+1
.a899	64 02		stz $02				stz 	zTemp0 						; clear result
.a89b	64 03		stz $03				stz 	zTemp0+1
.a89d	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a89f					_STIMultiply:
.a89f	8a		txa				txa 								; shift Y right into carry.
.a8a0	4a		lsr a				lsr 	a
.a8a1	aa		tax				tax
.a8a2	90 0d		bcc $a8b1			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a8a4	18		clc				clc
.a8a5	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a8a7	65 02		adc $02				adc 	zTemp0
.a8a9	85 02		sta $02				sta 	zTemp0
.a8ab	a5 07		lda $07				lda 	zTemp2+1
.a8ad	65 03		adc $03				adc 	zTemp0+1
.a8af	85 03		sta $03				sta 	zTemp0+1
.a8b1					_STINoAdd:
.a8b1	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a8b3	26 07		rol $07				rol 	zTemp2+1
.a8b5	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a8b7	d0 e6		bne $a89f			bne 	_STIMultiply
.a8b9	38		sec				sec 								; hex adjust
.a8ba	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a8bc	c9 3a		cmp #$3a			cmp 	#58
.a8be	90 03		bcc $a8c3			bcc 	_STIDecimal
.a8c0	38		sec				sec
.a8c1	e9 07		sbc #$07			sbc 	#7
.a8c3					_STIDecimal:
.a8c3	38		sec				sec
.a8c4	e9 30		sbc #$30			sbc 	#48
.a8c6	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a8c8	b0 10		bcs $a8da			bcs 	_STIFail
.a8ca	d8		cld				cld
.a8cb	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a8cd	85 02		sta $02				sta 	zTemp0
.a8cf	90 02		bcc $a8d3			bcc 	_STINoCarry
.a8d1	e6 03		inc $03				inc 	zTemp0+1
.a8d3					_STINoCarry:
.a8d3	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a8d5	c8		iny				iny 								; point to next
.a8d6	e6 10		inc $10				inc 	SignCount
.a8d8	80 a5		bra $a87f			bra 	_STILoop 					; and go round again.
.a8da					_STIFail:
.a8da	a5 10		lda $10				lda 	SignCount 					; if converted 0 charactes, fail.
.a8dc	f0 07		beq $a8e5			beq 	_STINoConvert
.a8de	98		tya				tya 								; convert count in A.
.a8df	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a8e1	a4 03		ldy $03				ldy 	zTemp0+1
.a8e3	38		sec				sec
.a8e4	60		rts				rts
.a8e5					_STINoConvert:
.a8e5	18		clc				clc
.a8e6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a8e7					IntToString:
.a8e7	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a8e9	84 03		sty $03				sty 	zTemp0+1
.a8eb	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a8ed	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a8ef					_ITSLoop:
.a8ef	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a8f1					_ITSSubtractLoop:
.a8f1	38		sec				sec
.a8f2	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a8f4	fd 2a a9	sbc $a92a,x			sbc 	_ITSWords,x
.a8f7	48		pha				pha
.a8f8	a5 03		lda $03				lda 	zTemp0+1
.a8fa	fd 2b a9	sbc $a92b,x			sbc 	_ITSWords+1,x
.a8fd	90 09		bcc $a908			bcc 	_ITSEndSub 					; can't subtract any more.
.a8ff	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a901	68		pla				pla
.a902	85 02		sta $02				sta 	zTemp0
.a904	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a906	80 e9		bra $a8f1			bra 	_ITSSubtractLoop
.a908					_ITSEndSub:
.a908	68		pla				pla 								; throw away the interim result
.a909	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a90b	d0 04		bne $a911			bne 	_ITSWriteOut 				; always write it out
.a90d	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a90f	f0 06		beq $a917			beq 	_ITSNext 					; suppressing leading zeros.
.a911					_ITSWriteOut:
.a911	09 30		ora #$30			ora 	#48 						; output digit.
.a913	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a916	c8		iny				iny
.a917					_ITSNext:
.a917	e8		inx				inx
.a918	e8		inx				inx
.a919	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a91b	d0 d2		bne $a8ef			bne 	_ITSLoop 					; do the new digits
.a91d	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a91f	09 30		ora #$30			ora 	#48
.a921	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a924	a9 00		lda #$00			lda 	#0
.a926	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a929	60		rts				rts
.a92a					_ITSWords:
>a92a	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a932					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a932					VariableFind:
.a932	da		phx				phx 								; save the stack position
.a933	08		php				php 								; save the create flag
.a934	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a936	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a938	90 10		bcc $a94a			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a93a	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a93c	0a		asl a				asl 	a 							; double clear carry
.a93d	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a93f	85 02		sta $02				sta 	zTemp0
.a941	a9 0f		lda #$0f			lda		#FastVariables >>8
.a943	85 03		sta $03				sta 	zTemp0+1
.a945	28		plp				plp 								; create flag is irrelevant.
.a946	fa		plx				plx									; restore the old stack position
.a947	c8		iny				iny 								; skip over the single identifier character
.a948	38		sec				sec 								; return with CS
.a949	60		rts				rts
.a94a					_VFIsNotFastVariable:
.a94a	20 1c aa	jsr $aa1c			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a94d	20 77 a9	jsr $a977			jsr 	VFSearch 					; try to find the variable.
.a950	b0 0d		bcs $a95f			bcs 	_VFEndSearch 				; found it, so exit
.a952	28		plp				plp 								; do we want autocreate
.a953	b0 03		bcs $a958			bcs 	_VFCreate
.a955	fa		plx				plx 								; restore stack position and return CC
.a956	18		clc				clc
.a957	60		rts				rts
.a958					_VFCreate:
.a958	20 1c aa	jsr $aa1c			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a95b	20 b3 a9	jsr $a9b3			jsr 	VFCreate 					; create a new record and link it in.
.a95e	08		php				php 								; save a dummy P to be popped.
.a95f					_VFEndSearch:
.a95f	18		clc				clc 								; the data is at offset + 4
.a960	a5 04		lda $04				lda 	zTemp1
.a962	69 04		adc #$04			adc 	#4
.a964	85 02		sta $02				sta 	zTemp0
.a966	a5 05		lda $05				lda 	zTemp1+1
.a968	69 00		adc #$00			adc 	#0
.a96a	85 03		sta $03				sta 	zTemp0+1
.a96c	28		plp				plp 								; dump the create flag
.a96d					_VFSkipExit:
.a96d	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a96f	c8		iny				iny
.a970	c9 e0		cmp #$e0			cmp 	#$E0
.a972	90 f9		bcc $a96d			bcc 	_VFSkipExit
.a974	fa		plx				plx 								; restore X
.a975	38		sec				sec
.a976	60		rts				rts
.a977					VFSearch:
.a977	48		pha				pha 								; save AXY.
.a978	da		phx				phx
.a979	5a		phy				phy
.a97a	98		tya				tya									; add Y to codePtr, put in zTemp2
.a97b	18		clc				clc 								; so it points to the identifier.
.a97c	65 00		adc $00				adc 	codePtr
.a97e	85 06		sta $06				sta 	zTemp2
.a980	a5 01		lda $01				lda 	codePtr+1
.a982	69 00		adc #$00			adc 	#0
.a984	85 07		sta $07				sta 	zTemp2+1
.a986					_VFSLoop:
.a986	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a988	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a98a	f0 22		beq $a9ae			beq 	_VFSFailed 					; failed.
.a98c	aa		tax				tax 								; MSB in X
.a98d	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a98f	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a991	86 05		stx $05				stx 	zTemp1+1
.a993	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a995	b1 04		lda ($04),y			lda 	(zTemp1),y
.a997	85 08		sta $08				sta 	zTemp3
.a999	c8		iny				iny
.a99a	b1 04		lda ($04),y			lda 	(zTemp1),y
.a99c	85 09		sta $09				sta 	zTemp3+1
.a99e	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a9a0					_VFSCheckName:
.a9a0	c8		iny				iny
.a9a1	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a9a3	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a9a5	d0 df		bne $a986			bne 	_VFSLoop
.a9a7	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a9a9	90 f5		bcc $a9a0			bcc 	_VFSCheckName
.a9ab	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a9ac	80 01		bra $a9af			bra		_VFSExit
.a9ae					_VFSFailed:
.a9ae	18		clc				clc
.a9af					_VFSExit:
.a9af	7a		ply				ply 								; restore registers and exit.
.a9b0	fa		plx				plx
.a9b1	68		pla				pla
.a9b2	60		rts				rts
.a9b3					VFCreate:
.a9b3	48		pha				pha 								; save registers
.a9b4	da		phx				phx
.a9b5	5a		phy				phy
.a9b6	18		clc				clc 								; add 6 to memVarPtr, saving its
.a9b7	a5 13		lda $13				lda 	memVarPtr 					; address in zTemp0 as we go.
.a9b9	85 02		sta $02				sta 	zTemp0
.a9bb	69 06		adc #$06			adc 	#6
.a9bd	85 13		sta $13				sta 	memVarPtr
.a9bf	a5 14		lda $14				lda 	memVarPtr+1
.a9c1	85 03		sta $03				sta 	zTemp0+1
.a9c3	69 00		adc #$00			adc 	#0
.a9c5	85 14		sta $14				sta 	memVarPtr+1
.a9c7	c5 12		cmp $12				cmp 	allocPtr+1 					; out of memory ?
.a9c9	f0 46		beq $aa11			beq 	_VFCMemory
.a9cb	98		tya				tya 								; work out identifier address
.a9cc	18		clc				clc
.a9cd	65 00		adc $00				adc 	codePtr
.a9cf	48		pha				pha
.a9d0	c8		iny				iny
.a9d1	a5 01		lda $01				lda 	codePtr+1
.a9d3	69 00		adc #$00			adc 	#0
.a9d5	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.a9d7	b0 0b		bcs $a9e4			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.a9d9	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>a9dc	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.a9e4					_VFCInProgram:
.a9e4	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a9e6	91 02		sta ($02),y			sta 	(zTemp0),y
.a9e8	88		dey				dey
.a9e9	68		pla				pla
.a9ea	91 02		sta ($02),y			sta 	(zTemp0),y
.a9ec	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a9ee	a9 00		lda #$00			lda 	#0
.a9f0	91 02		sta ($02),y			sta 	(zTemp0),y
.a9f2	c8		iny				iny
.a9f3	91 02		sta ($02),y			sta 	(zTemp0),y
.a9f5	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a9f7	b2 04		lda ($04)			lda 	(zTemp1)
.a9f9	92 02		sta ($02)			sta 	(zTemp0)
.a9fb	b1 04		lda ($04),y			lda 	(zTemp1),y
.a9fd	91 02		sta ($02),y			sta 	(zTemp0),y
.a9ff	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.aa01	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.aa03	a5 03		lda $03				lda 	zTemp0+1
.aa05	91 04		sta ($04),y			sta 	(zTemp1),y
.aa07	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.aa09	a5 02		lda $02				lda 	zTemp0
.aa0b	85 04		sta $04				sta 	zTemp1
.aa0d	7a		ply				ply
.aa0e	fa		plx				plx
.aa0f	68		pla				pla
.aa10	60		rts				rts
.aa11					_VFCMemory:
.aa11	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>aa14	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.aa1c					VFSetupHashPointer:
.aa1c	48		pha				pha
.aa1d	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.aa1f	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.aa21	0a		asl a				asl 	a 							; double it, also clears carry
.aa22	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.aa24	85 04		sta $04				sta 	zTemp1
.aa26	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.aa28	85 05		sta $05				sta 	zTemp1+1
.aa2a	68		pla				pla
.aa2b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.aa2c					TokeniseInputBuffer:
.aa2c	48		pha				pha
.aa2d	da		phx				phx
.aa2e	5a		phy				phy
.aa2f	64 19		stz $19				stz 	TokenOffset					; reset index into TokenBuffer
.aa31	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.aa34	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.aa36	20 9f aa	jsr $aa9f			jsr 	TokWriteToken
.aa39	20 9f aa	jsr $aa9f			jsr 	TokWriteToken
.aa3c	20 9f aa	jsr $aa9f			jsr 	TokWriteToken
.aa3f	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.aa41					_TIBForward:
.aa41	e8		inx				inx
.aa42	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.aa45	d0 fa		bne $aa41			bne 	_TIBForward
.aa47					_TIBBackward:
.aa47	ca		dex				dex 								; back one.
.aa48	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.aa4a	f0 4f		beq $aa9b			beq 	_TIBExit					; return empty buffer
.aa4c	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.aa4f	c9 20		cmp #$20			cmp 	#" "
.aa51	f0 f4		beq $aa47			beq 	_TIBBackward
.aa53	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.aa56	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.aa58					_TIBMainLoop:
.aa58	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.aa5b	f0 3e		beq $aa9b			beq 	_TIBExit 					; done the buffer if zero.
.aa5d	e8		inx				inx
.aa5e	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.aa60	f0 f6		beq $aa58			beq 	_TIBMainLoop
.aa62	ca		dex				dex 								; undo the last inx.
.aa63	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.aa65	f0 08		beq $aa6f			beq 	_TIBConstant
.aa67	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.aa69	90 09		bcc $aa74			bcc 	_TIBNotConstant
.aa6b	c9 3a		cmp #$3a			cmp 	#"9"+1
.aa6d	b0 05		bcs $aa74			bcs 	_TIBNotConstant
.aa6f					_TIBConstant:
.aa6f	20 22 ab	jsr $ab22			jsr 	TOKConvertConstant
.aa72	80 e4		bra $aa58			bra 	_TIBMainLoop
.aa74					_TIBNotConstant:
.aa74	c9 3a		cmp #$3a			cmp 	#":"						; definition
.aa76	d0 05		bne $aa7d			bne 	_TIBNotDefinition
.aa78	20 74 ab	jsr $ab74			jsr 	TOKConvertDefinition
.aa7b	80 db		bra $aa58			bra 	_TIBMainLoop
.aa7d					_TIBNotDefinition:
.aa7d	c9 27		cmp #$27			cmp 	#"'"
.aa7f	f0 04		beq $aa85			beq 	_TIBIsCommentString
.aa81	c9 22		cmp #$22			cmp 	#'"'
.aa83	d0 05		bne $aa8a			bne 	_TIBNotCommentString
.aa85					_TIBIsCommentString:
.aa85	20 d8 ab	jsr $abd8			jsr 	TOKConvertCommentString
.aa88	80 ce		bra $aa58			bra 	_TIBMainLoop
.aa8a					_TIBNotCommentString:
.aa8a	20 1f ac	jsr $ac1f			jsr 	TOKCheckIsToken 			; check if a token.
.aa8d	b0 c9		bcs $aa58			bcs 	_TIBMainLoop
.aa8f	a5 19		lda $19				lda 	TokenOffset 				; save token offset.
.aa91	48		pha				pha
.aa92	20 b3 ab	jsr $abb3			jsr 	TOKCopyIdentifier 			; copy identifier.
.aa95	68		pla				pla
.aa96	20 d0 aa	jsr $aad0			jsr 	TOKCheckIdentifierIsCall 	; convert if call.
.aa99	80 bd		bra $aa58			bra 	_TIBMainLoop
.aa9b					_TIBExit:
.aa9b	7a		ply				ply
.aa9c	fa		plx				plx
.aa9d	68		pla				pla
.aa9e	60		rts				rts
.aa9f					TOKWriteToken:
.aa9f	da		phx				phx
.aaa0	a6 19		ldx $19				ldx 	TokenOffset
.aaa2	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.aaa5	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.aaa8	e6 19		inc $19				inc 	TokenOffset
.aaaa	fa		plx				plx
.aaab	60		rts				rts
.aaac					TOKFixUpLast:
.aaac	da		phx				phx
.aaad	a6 19		ldx $19				ldx 	TokenOffset
.aaaf	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.aab2	09 e0		ora #$e0			ora 	#$E0
.aab4	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.aab7	fa		plx				plx
.aab8	60		rts				rts
.aab9					TOKConvertIdentifier:
.aab9	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.aabb	f0 0f		beq $aacc			beq 	_TKCIDot
.aabd	38		sec				sec 								; A-Z -> 1-27
.aabe	e9 40		sbc #$40			sbc 	#64
.aac0	f0 08		beq $aaca			beq 	_TKCIFail
.aac2	c9 1b		cmp #$1b			cmp 	#27
.aac4	b0 04		bcs $aaca			bcs 	_TKCIFail
.aac6	09 c0		ora #$c0			ora 	#$C0 						; fix up
.aac8	38		sec				sec
.aac9	60		rts				rts
.aaca					_TKCIFail:
.aaca	18		clc				clc
.aacb	60		rts				rts
.aacc					_TKCIDot:
.aacc	a9 db		lda #$db			lda 	#$C0+27
.aace	38		sec				sec
.aacf	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_check_call.asm

.aad0					TOKCheckIdentifierIsCall:
.aad0	48		pha				pha
.aad1	da		phx				phx
.aad2	5a		phy				phy
.aad3	85 04		sta $04				sta 	zTemp1
.aad5	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.aad7	85 02		sta $02				sta 	zTemp0
.aad9	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aadb	85 03		sta $03				sta 	zTemp0+1
.aadd					_TKCIILoop:
.aadd	b2 02		lda ($02)			lda 	(zTemp0) 					; reached the end
.aadf	f0 3d		beq $ab1e			beq 	_TKCIIExit
.aae1	a0 03		ldy #$03			ldy 	#3							; check if definition
.aae3	b1 02		lda ($02),y			lda 	(zTemp0),y
.aae5	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.aae7	d0 28		bne $ab11			bne 	_TKCIINext 					; if not skip.
.aae9	a6 04		ldx $04				ldx 	zTemp1 						; position of identifier.
.aaeb	c8		iny				iny 								; skip count
.aaec					_TKCIICheck:
.aaec	c8		iny				iny
.aaed	bd 00 0a	lda $0a00,x			lda 	TokenBuffer,x 				; compare identifiers
.aaf0	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.aaf2	d0 1d		bne $ab11			bne 	_TKCIINext
.aaf4	e8		inx				inx
.aaf5	c9 e0		cmp #$e0			cmp 	#$E0						; go back if not end identifier.
.aaf7	90 f3		bcc $aaec			bcc 	_TKCIICheck
.aaf9	a5 04		lda $04				lda 	zTemp1 						; get identifier position
.aafb	85 19		sta $19				sta 	TokenOffset 				; reset it.
.aafd	a9 02		lda #$02			lda 	#KWD_SYS_CALL 				; write call
.aaff	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab02	a0 01		ldy #$01			ldy 	#1
.ab04	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab06	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab09	c8		iny				iny
.ab0a	b1 02		lda ($02),y			lda 	(zTemp0),y
.ab0c	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab0f	80 0d		bra $ab1e			bra 	_TKCIIExit 					; and exit.
.ab11					_TKCIINext:
.ab11	18		clc				clc
.ab12	b2 02		lda ($02)			lda 	(zTemp0)
.ab14	65 02		adc $02				adc 	zTemp0
.ab16	85 02		sta $02				sta 	zTemp0
.ab18	90 c3		bcc $aadd			bcc 	_TKCIILoop
.ab1a	e6 03		inc $03				inc 	zTemp0+1
.ab1c	80 bf		bra $aadd			bra 	_TKCIILoop
.ab1e					_TKCIIExit:
.ab1e	7a		ply				ply
.ab1f	fa		plx				plx
.ab20	68		pla				pla
.ab21	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.ab22					TOKConvertConstant:
.ab22	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.ab24	da		phx				phx 								; save X position
.ab25	20 62 a8	jsr $a862			jsr 	StringToInt 				; try to convert
.ab28	90 40		bcc $ab6a			bcc 	_TKCCError
.ab2a	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.ab2c	86 02		stx $02				stx 	zTemp0
.ab2e	85 04		sta $04				sta 	zTemp1 						; save count
.ab30	68		pla				pla 								; restore X position, add the count
.ab31	18		clc				clc
.ab32	65 04		adc $04				adc 	zTemp1
.ab34	aa		tax				tax
.ab35	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.ab38	c9 2d		cmp #$2d			cmp 	#"-"
.ab3a	d0 0e		bne $ab4a			bne 	_TKCCNotNegative
.ab3c	e8		inx				inx 								; consume the -
.ab3d	38		sec				sec
.ab3e	a9 00		lda #$00			lda 	#0 							; negate the constant.
.ab40	e5 02		sbc $02				sbc 	zTemp0
.ab42	85 02		sta $02				sta 	zTemp0
.ab44	a9 00		lda #$00			lda 	#0
.ab46	e5 03		sbc $03				sbc 	zTemp0+1
.ab48	85 03		sta $03				sta 	zTemp0+1
.ab4a					_TKCCNotNegative:
.ab4a	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.ab4c	d0 0c		bne $ab5a			bne 	_TKCCLongConstant
.ab4e	a5 02		lda $02				lda 	zTemp0
.ab50	c9 40		cmp #$40			cmp 	#$40
.ab52	b0 06		bcs $ab5a			bcs 	_TKCCLongConstant
.ab54	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.ab56	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab59	60		rts				rts
.ab5a					_TKCCLongConstant:
.ab5a	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.ab5c	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab5f	a5 02		lda $02				lda 	zTemp0
.ab61	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab64	a5 03		lda $03				lda 	zTemp0+1
.ab66	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab69	60		rts				rts
.ab6a					_TKCCError:
.ab6a	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>ab6d	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.ab74					TOKConvertDefinition:
.ab74	e8		inx				inx 								; skip over :
.ab75	a9 05		lda #$05			lda 	#KWD_SYS_DEFINE 			; output define token
.ab77	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab7a					TOKConvertIdentifierOnly:
.ab7a	64 02		stz $02				stz 	zTemp0 						; count how many identifiers.
.ab7c	da		phx				phx
.ab7d					_TKCDCount:
.ab7d	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.ab80	20 b9 aa	jsr $aab9			jsr 	TOKConvertIdentifier
.ab83	90 05		bcc $ab8a			bcc 	_TKCDCounted
.ab85	e8		inx				inx
.ab86	e6 02		inc $02				inc 	zTemp0
.ab88	80 f3		bra $ab7d			bra 	_TKCDCount
.ab8a					_TKCDCounted:
.ab8a	a5 02		lda $02				lda 	zTemp0 						; get count
.ab8c	f0 16		beq $aba4			beq 	_TKCDFail 					; can't be none
.ab8e	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken 				; write count
.ab91	fa		plx				plx 								; restore X
.ab92					_TKCDLoop:
.ab92	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; output that many tokens.
.ab95	e8		inx				inx
.ab96	20 b9 aa	jsr $aab9			jsr 	TOKConvertIdentifier
.ab99	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ab9c	c6 02		dec $02				dec 	zTemp0
.ab9e	d0 f2		bne $ab92			bne 	_TKCDLoop
.aba0	20 ac aa	jsr $aaac			jsr 	TOKFixUpLast 				; set bit for last character.
.aba3	60		rts				rts
.aba4					_TKCDFail:
.aba4	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>aba7	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>abaf	45 52 3f 00
.abb3					TOKCopyIdentifier:
.abb3	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.abb6	20 b9 aa	jsr $aab9			jsr 	TOKConvertIdentifier
.abb9	90 13		bcc $abce			bcc 	_TKCIError
.abbb					_TKCILoop:
.abbb	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get and output token till not found
.abbe	e8		inx				inx
.abbf	20 b9 aa	jsr $aab9			jsr 	TOKConvertIdentifier
.abc2	90 05		bcc $abc9			bcc 	_TKCIEnd
.abc4	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.abc7	80 f2		bra $abbb			bra 	_TKCILoop
.abc9					_TKCIEnd:
.abc9	ca		dex				dex
.abca	20 ac aa	jsr $aaac			jsr 	TOKFixUpLast 				; set bit for last character.
.abcd	60		rts				rts
.abce					_TKCIError:
.abce	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>abd1	50 41 52 53 45 3f 00				.text 	"PARSE?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.abd8					TOKConvertCommentString:
.abd8	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.abda	f0 06		beq $abe2			beq 	_TKCCSComment
.abdc	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.abde	a0 22		ldy #$22			ldy 	#'"'						; match character
.abe0	80 04		bra $abe6			bra 	_TKCCSContinue
.abe2					_TKCCSComment:
.abe2	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.abe4	a0 00		ldy #$00			ldy 	#0 							; match character
.abe6					_TKCCSContinue:
.abe6	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken 				; write initial token
.abe9	e8		inx				inx 								; skip over ' or "
.abea	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.abec	a0 00		ldy #$00			ldy 	#0 							; count of characters
.abee	da		phx				phx 								; save start position
.abef					_TKCCSFindSize:
.abef	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.abf2	c5 02		cmp $02				cmp 	zTemp0
.abf4	f0 10		beq $ac06			beq 	_TKCCSFoundEnd
.abf6	e8		inx				inx 								; bump pos, count
.abf7	c8		iny				iny
.abf8	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.abfa	d0 f3		bne $abef			bne 	_TKCCSFindSize
.abfc	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>abff	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.ac06					_TKCCSFoundEnd:
.ac06	98		tya				tya 								; length of element in Y
.ac07	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ac0a	fa		plx				plx 								; restore start position and copy out
.ac0b					_TKCCSCopyOut:
.ac0b	c0 00		cpy #$00			cpy 	#0 							; complete ?
.ac0d	f0 0a		beq $ac19			beq 	_TKCCSExit
.ac0f	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.ac12	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken
.ac15	e8		inx				inx
.ac16	88		dey				dey
.ac17	80 f2		bra $ac0b			bra 	_TKCCSCopyOut
.ac19					_TKCCSExit:
.ac19	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.ac1b	f0 01		beq $ac1e			beq 	_TKCSSNotComment
.ac1d	e8		inx				inx
.ac1e					_TKCSSNotComment:
.ac1e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.ac1f					TOKCheckIsToken:
.ac1f	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.ac21	85 02		sta $02				sta 	zTemp0
.ac23	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.ac25	85 03		sta $03				sta 	zTemp0+1
.ac27	64 04		stz $04				stz 	zTemp1 						; best match length
.ac29	64 06		stz $06				stz 	zTemp2 						; current token.
.ac2b					_TCTLoop:
.ac2b	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.ac2d	da		phx				phx 								; save start
.ac2e					_TCTCompare:
.ac2e	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.ac30	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.ac33	e8		inx				inx 								; bump both pointers.
.ac34	c8		iny				iny
.ac35	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.ac36	d0 0e		bne $ac46			bne 	_TCTNext 					; different, go to next.
.ac38	90 f4		bcc $ac2e			bcc 	_TCTCompare 				; still comparing.
.ac3a	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.ac3c	c5 04		cmp $04				cmp 	zTemp1						; best so far
.ac3e	90 06		bcc $ac46			bcc 	_TCTNext 					; if not, skip to next.
.ac40	85 04		sta $04				sta 	zTemp1 						; new best score
.ac42	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.ac44	85 07		sta $07				sta 	zTemp2+1
.ac46					_TCTNext:
.ac46	fa		plx				plx 								; restore start position.
.ac47	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.ac49	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.ac4b	38		sec				sec
.ac4c	65 02		adc $02				adc 	zTemp0
.ac4e	85 02		sta $02				sta 	zTemp0
.ac50	90 02		bcc $ac54			bcc		_TCTNoCarry
.ac52	e6 03		inc $03				inc 	zTemp0+1
.ac54					_TCTNoCarry:
.ac54	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.ac56	d0 d3		bne $ac2b			bne 	_TCTLoop 					; no, check the next keyword.
.ac58	18		clc				clc
.ac59	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.ac5b	f0 0b		beq $ac68			beq 	_TCTExit
.ac5d	8a		txa				txa 								; add that length to the input index.
.ac5e	18		clc				clc
.ac5f	65 04		adc $04				adc 	zTemp1
.ac61	aa		tax				tax
.ac62	a5 07		lda $07				lda 	zTemp2+1 					; token number
.ac64	20 9f aa	jsr $aa9f			jsr 	TOKWriteToken 				; write it out.
.ac67	38		sec				sec 								; set carry and exit
.ac68					_TCTExit:
.ac68	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.ac69					Cmd_List:
.ac69	fa		plx				plx
.ac6a	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.ac6c	64 07		stz $07				stz 	zTemp2+1
.ac6e	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.ac70	f0 0b		beq $ac7d			beq 	_CLNoStart
.ac72	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.ac75	85 06		sta $06				sta 	zTemp2
.ac77	bd 00 07	lda $0700,x			lda 	highStack,x
.ac7a	85 07		sta $07				sta 	zTemp2+1
.ac7c	ca		dex				dex
.ac7d					_CLNoStart:
.ac7d					_CLNoStartLine:
.ac7d	a9 00		lda #$00			lda 	#(programStart) & $FF
.ac7f	85 00		sta $00				sta 	codePtr
.ac81	a9 10		lda #$10			lda 	#(programStart) >> 8
.ac83	85 01		sta $01				sta 	codePtr+1
.ac85					_CLILoop:
.ac85	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.ac87	f0 24		beq $acad			beq 	_CLIEnd
.ac89	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.ac8b	38		sec				sec
.ac8c	b1 00		lda ($00),y			lda 	(codePtr),y
.ac8e	e5 06		sbc $06				sbc 	zTemp2
.ac90	c8		iny				iny
.ac91	b1 00		lda ($00),y			lda 	(codePtr),y
.ac93	e5 07		sbc $07				sbc 	zTemp2+1
.ac95	90 09		bcc $aca0			bcc 	_CLISkip
.ac97	da		phx				phx
.ac98	20 b0 ac	jsr $acb0			jsr 	ListCurrent 				; list the line.
.ac9b	fa		plx				plx
.ac9c	c6 08		dec $08				dec 	zTemp3 						; done all lines
.ac9e	f0 0d		beq $acad			beq 	_CLIEnd
.aca0					_CLISkip:
.aca0	18		clc				clc
.aca1	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.aca3	65 00		adc $00				adc 	codePtr
.aca5	85 00		sta $00				sta 	codePtr
.aca7	90 dc		bcc $ac85			bcc 	_CLILoop
.aca9	e6 01		inc $01				inc 	codePtr+1
.acab	80 d8		bra $ac85			bra 	_CLILoop
.acad					_CLIEnd:
.acad	4c 1b a0	jmp $a01b			jmp 	WarmStart
.acb0					ListCurrent:
.acb0	a9 02		lda #$02			lda 	#COL_GREEN
.acb2	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.acb5	a0 01		ldy #$01			ldy 	#1							; print line#
.acb7	b1 00		lda ($00),y			lda 	(codePtr),y
.acb9	aa		tax				tax
.acba	c8		iny				iny
.acbb	b1 00		lda ($00),y			lda 	(codePtr),y
.acbd	a8		tay				tay
.acbe	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.acc1	a8		tay				tay
.acc2					_LCPadOut:
.acc2	a9 20		lda #$20			lda 	#' '
.acc4	20 dd a5	jsr $a5dd			jsr 	ExternPrint
.acc7	c8		iny				iny
.acc8	c0 06		cpy #$06			cpy 	#6
.acca	d0 f6		bne $acc2			bne 	_LCPadOut
.accc	a0 03		ldy #$03			ldy 	#3 							; start here
.acce	64 17		stz $17				stz 	PrefixCharacter				; no prefix
.acd0					_LCLoop:
.acd0	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.acd2	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.acd4	f0 0b		beq $ace1			beq 	_LCNoPrefix
.acd6	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.acd8	f0 07		beq $ace1			beq 	_LCNoPrefix
.acda	a5 17		lda $17				lda 	PrefixCharacter 			; output prefix, reset to space
.acdc	f0 03		beq $ace1			beq		_LCNoPrefix
.acde	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ace1					_LCNoPrefix:
.ace1	a9 20		lda #$20			lda 	#32
.ace3	85 17		sta $17				sta 	PrefixCharacter
.ace5	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.ace7	f0 13		beq $acfc			beq 	_LCExit
.ace9	10 4d		bpl $ad38			bpl 	_LCIsToken 					; +ve goto token.
.aceb	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.aced	b0 13		bcs $ad02			bcs 	_LCIsIdentifier
.acef	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.acf1	aa		tax				tax
.acf2	c8		iny				iny
.acf3	5a		phy				phy 								; push pos
.acf4	a0 00		ldy #$00			ldy 	#0
.acf6	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.acf9	7a		ply				ply
.acfa	80 d4		bra $acd0			bra 	_LCLoop
.acfc					_LCExit:
.acfc	a9 0d		lda #$0d			lda 	#13
.acfe	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad01	60		rts				rts
.ad02					_LCIsIdentifier:
.ad02					_LCIdentLoop:
.ad02	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.ad04	20 15 ae	jsr $ae15			jsr 	ListPrintIDChar
.ad07	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.ad09	c8		iny				iny
.ad0a	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.ad0c	b0 c2		bcs $acd0			bcs 	_LCLoop 					; if so, do next
.ad0e	80 f2		bra $ad02			bra 	_LCIdentLoop				; if not loop round
.ad10					_LCConstant:
.ad10	c8		iny				iny
.ad11	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.ad13	aa		tax				tax
.ad14	c8		iny				iny 								; get MSB into Y
.ad15	b1 00		lda ($00),y			lda 	(codePtr),y
.ad17	c8		iny				iny
.ad18	5a		phy				phy
.ad19	a8		tay				tay
.ad1a	5a		phy				phy 								; save sign
.ad1b	10 0c		bpl $ad29			bpl 	_LCNotNegative
.ad1d	98		tya				tya 								; YX = |YX|
.ad1e	49 ff		eor #$ff			eor 	#$FF
.ad20	a8		tay				tay
.ad21	8a		txa				txa
.ad22	49 ff		eor #$ff			eor 	#$FF
.ad24	aa		tax				tax
.ad25	e8		inx				inx
.ad26	d0 01		bne $ad29			bne 	_LCNotNegative
.ad28	c8		iny				iny
.ad29					_LCNotNegative:
.ad29					_LCPrintYX:
.ad29	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.ad2c	68		pla				pla 								; restore sign
.ad2d	10 05		bpl $ad34			bpl 	_LCNoTrail
.ad2f	a9 2d		lda #$2d			lda 	#"-"
.ad31	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad34					_LCNoTrail:
.ad34	7a		ply				ply 								; restore Y
.ad35	4c d0 ac	jmp $acd0			jmp 	_LCLoop
.ad38					_LCIsToken:
.ad38	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.ad3a	f0 d4		beq $ad10			beq 	_LCConstant
.ad3c	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.ad3e	90 3e		bcc $ad7e			bcc 	_LCControl
.ad40					_LCIsKeywordToken:
.ad40	85 02		sta $02				sta 	zTemp0 						; save token #
.ad42	a9 94		lda #$94			lda 	#(KeywordText) & $FF
.ad44	85 04		sta $04				sta 	zTemp1
.ad46	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.ad48	85 05		sta $05				sta 	zTemp1+1
.ad4a	5a		phy				phy 								; save code offset
.ad4b					_LCForward:
.ad4b	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.ad4d	f0 0f		beq $ad5e			beq 	_LCFoundToken
.ad4f	c6 02		dec $02				dec 	zTemp0						; dec count.
.ad51	38		sec				sec 								; go to next keyword.
.ad52	b2 04		lda ($04)			lda 	(zTemp1)
.ad54	65 04		adc $04				adc 	zTemp1
.ad56	85 04		sta $04				sta 	zTemp1
.ad58	90 f1		bcc $ad4b			bcc 	_LCForward
.ad5a	e6 05		inc $05				inc 	zTemp1+1
.ad5c	80 ed		bra $ad4b			bra 	_LCForward
.ad5e					_LCFoundToken:
.ad5e	a0 01		ldy #$01			ldy 	#1 							; output the token.
.ad60					_LCOutToken:
.ad60	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.ad62	29 7f		and #$7f			and 	#$7F
.ad64	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad67	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.ad69	c8		iny				iny
.ad6a	0a		asl a				asl 	a
.ad6b	90 f3		bcc $ad60			bcc 	_LCOutToken
.ad6d	7a		ply				ply 								; restore code offset
.ad6e	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.ad70	c8		iny				iny
.ad71	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.ad73	f0 04		beq $ad79			beq 	_LCCancelPrefix
.ad75	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.ad77	d0 02		bne $ad7b			bne 	_LCGoLoop
.ad79					_LCCancelPrefix:
.ad79	64 17		stz $17				stz 	PrefixCharacter
.ad7b					_LCGoLoop:
.ad7b	4c d0 ac	jmp $acd0			jmp 	_LCLoop
.ad7e					_LCControl:
.ad7e	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.ad80	f0 3b		beq $adbd			beq 	_LCDecodeCall
.ad82	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ad84	f0 22		beq $ada8			beq 	_LCDecodeDefine
.ad86	5a		phy				phy 								; save Y
.ad87	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.ad89	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.ad8b	f0 07		beq $ad94			beq 	_LCDecodeString
.ad8d	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.ad8f	a9 07		lda #$07			lda 	#COL_WHITE 					; highlight comment.
.ad91	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.ad94					_LCDecodeString
.ad94	98		tya				tya
.ad95	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ad98	7a		ply				ply 								; restore Y pos
.ad99	48		pha				pha 								; save end character on stack.
.ad9a	20 f5 ad	jsr $adf5			jsr 	ListPrintCodeIdentifier
.ad9d	68		pla				pla 								; last character
.ad9e	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.ada0	f0 03		beq $ada5			beq 	_LCEDNoQuote
.ada2	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ada5					_LCEDNoQuote:
.ada5	4c d0 ac	jmp $acd0			jmp 	_LCLoop
.ada8					_LCDecodeDefine:
.ada8	a9 03		lda #$03			lda 	#COL_YELLOW 				; highlight definition.
.adaa	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.adad	a9 3a		lda #$3a			lda 	#":"
.adaf	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.adb2	20 f5 ad	jsr $adf5			jsr 	ListPrintCodeIdentifier
.adb5	a9 02		lda #$02			lda 	#COL_GREEN
.adb7	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.adba	4c d0 ac	jmp $acd0			jmp 	_LCLoop
.adbd					_LCDecodeCall:
.adbd	a9 06		lda #$06			lda 	#COL_CYAN
.adbf	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.adc2	c8		iny				iny 								; get line number into XA
.adc3	b1 00		lda ($00),y			lda 	(codePtr),y
.adc5	48		pha				pha
.adc6	c8		iny				iny
.adc7	b1 00		lda ($00),y			lda 	(codePtr),y
.adc9	c8		iny				iny
.adca	aa		tax				tax
.adcb	68		pla				pla
.adcc	20 27 ae	jsr $ae27			jsr 	ListFindLine 				; find that line.
.adcf	90 19		bcc $adea			bcc 	_LCNoDefinition
.add1	5a		phy				phy
.add2	a0 03		ldy #$03			ldy 	#3 							; look at first character
.add4	b1 02		lda ($02),y			lda 	(zTemp0),y
.add6	7a		ply				ply
.add7	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.add9	d0 0f		bne $adea			bne 	_LCNoDefinition 			; not define
.addb	5a		phy				phy
.addc	a0 03		ldy #$03			ldy 	#3
.adde	20 ff ad	jsr $adff			jsr 	ListPrintIdentifier
.ade1	7a		ply				ply
.ade2	a9 02		lda #$02			lda 	#COL_GREEN
.ade4	20 e7 a5	jsr $a5e7			jsr 	ExternColour
.ade7	4c d0 ac	jmp $acd0			jmp 	_LCLoop
.adea					_LCNoDefinition:
.adea	a9 25		lda #$25			lda 	#"%"						; print a %
.adec	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.adef	88		dey				dey 								; unpick Y changes
.adf0	88		dey				dey
.adf1	88		dey				dey
.adf2	4c 10 ad	jmp $ad10			jmp 	_LCConstant 				; output # as constant
.adf5					ListPrintCodeIdentifier:
.adf5	48		pha				pha 								; copy codePtr -> zTemp0
.adf6	a5 00		lda $00				lda 	codePtr
.adf8	85 02		sta $02				sta 	zTemp0
.adfa	a5 01		lda $01				lda 	codePtr+1
.adfc	85 03		sta $03				sta 	zTemp0+1
.adfe	68		pla				pla
.adff					ListPrintIdentifier:
.adff	48		pha				pha
.ae00	da		phx				phx
.ae01	c8		iny				iny 								; skip over the type
.ae02	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.ae04	aa		tax				tax
.ae05					_LPILoop:
.ae05	c8		iny				iny
.ae06	e0 00		cpx #$00			cpx 	#0
.ae08	f0 08		beq $ae12			beq 	_LPIExit
.ae0a	b1 02		lda ($02),y			lda 	(zTemp0),y
.ae0c	20 15 ae	jsr $ae15			jsr 	ListPrintIDChar
.ae0f	ca		dex				dex
.ae10	80 f3		bra $ae05			bra 	_LPILoop
.ae12					_LPIExit:
.ae12	fa		plx				plx
.ae13	68		pla				pla
.ae14	60		rts				rts
.ae15					ListPrintIDChar:
.ae15	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.ae17	10 0a		bpl $ae23			bpl	 	_LCNotDot
.ae19	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.ae1b	09 40		ora #$40			ora 	#$40 						; ASCII except .
.ae1d	c9 5b		cmp #$5b			cmp 	#$40+27
.ae1f	d0 02		bne $ae23			bne 	_LCNotDot
.ae21	a9 2e		lda #$2e			lda 	#"."
.ae23					_LCNotDot:
.ae23	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.ae26	60		rts				rts
.ae27					ListFindLine:
.ae27	5a		phy				phy
.ae28	86 05		stx $05				stx 	zTemp1+1
.ae2a	85 04		sta $04				sta 	zTemp1
.ae2c	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ae2e	85 02		sta $02				sta 	zTemp0
.ae30	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ae32	85 03		sta $03				sta 	zTemp0+1
.ae34					_LFLSearch:
.ae34	18		clc				clc									; reached the end.
.ae35	b2 02		lda ($02)			lda 	(zTemp0)
.ae37	f0 1d		beq $ae56			beq 	_LFLExit 					; exit with CC
.ae39	a0 01		ldy #$01			ldy 	#1
.ae3b	a5 04		lda $04				lda 	zTemp1
.ae3d	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.ae3f	d0 07		bne $ae48			bne 	_LFLNext
.ae41	c8		iny				iny
.ae42	a5 05		lda $05				lda 	zTemp1+1
.ae44	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.ae46	f0 0d		beq $ae55			beq 	_LFLFound
.ae48					_LFLNext:
.ae48	18		clc				clc
.ae49	b2 02		lda ($02)			lda 	(zTemp0)
.ae4b	65 02		adc $02				adc 	zTemp0
.ae4d	85 02		sta $02				sta 	zTemp0
.ae4f	90 e3		bcc $ae34			bcc 	_LFLSearch
.ae51	e6 03		inc $03				inc 	zTemp0+1
.ae53	80 df		bra $ae34			bra 	_LFLSearch
.ae55					_LFLFound:
.ae55	38		sec				sec
.ae56					_LFLExit:
.ae56	7a		ply				ply
.ae57	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.ae58					Mem_Peek:
.ae58	fa		plx				plx
.ae59	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ae5c	85 02		sta $02				sta 	zTemp0
.ae5e	bd 00 07	lda $0700,x			lda 	highStack,x
.ae61	85 03		sta $03				sta 	zTemp0+1
.ae63	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.ae65	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.ae68	9e 00 07	stz $0700,x			stz 	highStack,x
.ae6b	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.ae6e					Mem_WPeek:
.ae6e	fa		plx				plx
.ae6f	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ae72	85 02		sta $02				sta 	zTemp0
.ae74	bd 00 07	lda $0700,x			lda 	highStack,x
.ae77	85 03		sta $03				sta 	zTemp0+1
.ae79	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.ae7b	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.ae7e	5a		phy				phy 								; read msb
.ae7f	a0 01		ldy #$01			ldy 	#1
.ae81	b1 02		lda ($02),y			lda 	(zTemp0),y
.ae83	7a		ply				ply
.ae84	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.ae87	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.ae8a					Mem_Poke:
.ae8a	fa		plx				plx
.ae8b	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.ae8e	85 02		sta $02				sta 	zTemp0
.ae90	bd 00 07	lda $0700,x			lda 	highStack,x
.ae93	85 03		sta $03				sta 	zTemp0+1
.ae95	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.ae98	92 02		sta ($02)			sta 	(zTemp0)
.ae9a	ca		dex				dex
.ae9b	ca		dex				dex
.ae9c	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.ae9f					Mem_WPoke:
.ae9f	fa		plx				plx
.aea0	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aea3	85 02		sta $02				sta 	zTemp0
.aea5	bd 00 07	lda $0700,x			lda 	highStack,x
.aea8	85 03		sta $03				sta 	zTemp0+1
.aeaa	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aead	92 02		sta ($02)			sta 	(zTemp0)
.aeaf	5a		phy				phy
.aeb0	a0 01		ldy #$01			ldy 	#1
.aeb2	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aeb5	91 02		sta ($02),y			sta 	(zTemp0),y
.aeb7	7a		ply				ply
.aeb8	ca		dex				dex
.aeb9	ca		dex				dex
.aeba	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.aebd					Mem_DWPoke:
.aebd	fa		plx				plx
.aebe	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.aec1	85 02		sta $02				sta 	zTemp0
.aec3	bd 00 07	lda $0700,x			lda 	highStack,x
.aec6	85 03		sta $03				sta 	zTemp0+1
.aec8	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.aecb	92 02		sta ($02)			sta 	(zTemp0)
.aecd	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.aed0	92 02		sta ($02)			sta 	(zTemp0)
.aed2	ca		dex				dex
.aed3	ca		dex				dex
.aed4	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.aed7					Mem_Alloc:
.aed7	fa		plx				plx
.aed8	38		sec				sec 								; subtract count from alloc ptr
.aed9	a5 11		lda $11				lda 	allocPtr
.aedb	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.aede	85 11		sta $11				sta 	allocPtr
.aee0	48		pha				pha 								; save low.
.aee1	a5 12		lda $12				lda 	allocPtr+1
.aee3	fd 00 07	sbc $0700,x			sbc 	highStack,x
.aee6	85 12		sta $12				sta 	allocPtr+1
.aee8	90 10		bcc $aefa			bcc 	_MAError 					; borrow ?
.aeea	c5 14		cmp $14				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.aeec	90 0c		bcc $aefa			bcc 	_MAError
.aeee	f0 0a		beq $aefa			beq 	_MAError
.aef0	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.aef3	68		pla				pla
.aef4	9d 00 06	sta $0600,x			sta 	lowStack,x
.aef7	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.aefa					_MAError:
.aefa	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>aefd	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/saveload.asm

.af05					System_Save:
.af05	fa		plx				plx
.af06	da		phx				phx
.af07	20 fc a7	jsr $a7fc			jsr 	ResetVarMemory 				; make sure start/end are right
.af0a	20 31 af	jsr $af31			jsr 	SLGetFileName 				; get filename -> zTemp0
.af0d	a5 13		lda $13				lda 	memVarPtr 					; end address
.af0f	85 04		sta $04				sta 	zTemp1
.af11	a5 14		lda $14				lda 	memVarPtr+1
.af13	85 05		sta $05				sta 	zTemp1+1
.af15	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.af17	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.af19	20 34 a6	jsr $a634			jsr 	ExternSave
.af1c	7a		ply				ply
.af1d	4c 1b a0	jmp $a01b			jmp 	WarmStart
.af20					System_Load:
.af20	fa		plx				plx
.af21	20 31 af	jsr $af31			jsr 	SLGetFileName 				; get filename -> zTemp0
.af24	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.af26	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.af28	20 6a a6	jsr $a66a			jsr 	ExternLoad
.af2b	20 de a7	jsr $a7de			jsr 	ResetMemory 				; reset everything.
.af2e	4c 1b a0	jmp $a01b			jmp 	WarmStart
.af31					SLGetFileName:
.af31	e0 ff		cpx #$ff			cpx 	#255 						; gotta be something on the stack
.af33	f0 4a		beq $af7f			beq 	_SLFNFail
.af35	bd 00 07	lda $0700,x			lda 	highStack,x 				; should be something in token buffer
.af38	c9 0a		cmp #$0a			cmp 	#TokenBuffer >> 8
.af3a	d0 43		bne $af7f			bne 	_SLFNFail
.af3c	85 05		sta $05				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.af3e	bd 00 06	lda $0600,x			lda 	lowStack,x
.af41	85 04		sta $04				sta 	zTemp1
.af43	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.af45	85 02		sta $02				sta 	zTemp0
.af47	a9 08		lda #$08			lda 	#InputBuffer >> 8
.af49	85 03		sta $03				sta 	zTemp0+1
.af4b	b2 04		lda ($04)			lda 	(zTemp1) 					; copy string to input buffer
.af4d	1a		inc a				inc 	a
.af4e	aa		tax				tax
.af4f	a0 00		ldy #$00			ldy 	#0
.af51	b1 04		lda ($04),y	_SLCopy:lda 	(zTemp1),y
.af53	91 02		sta ($02),y			sta 	(zTemp0),y
.af55	c8		iny				iny
.af56	ca		dex				dex
.af57	d0 f8		bne $af51			bne 	_SLCopy
.af59	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.af5b					_SLCheckEnd:
.af5b	88		dey				dey
.af5c	bd 8f af	lda $af8f,x			lda 	_SLFNExtension,x
.af5f	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.af61	d0 05		bne $af68			bne 	_SLNoExtension
.af63	ca		dex				dex
.af64	10 f5		bpl $af5b			bpl 	_SLCheckEnd
.af66	80 16		bra $af7e			bra 	_SLExit
.af68					_SLNoExtension:
.af68	a0 00		ldy #$00			ldy 	#0							; add the extension.
.af6a					_SLExtend:
.af6a	ee 00 08	inc $0800			inc 	InputBuffer
.af6d	ae 00 08	ldx $0800			ldx 	InputBuffer
.af70	b9 8f af	lda $af8f,y			lda 	_SLFNExtension,y
.af73	c8		iny				iny
.af74	9d 00 08	sta $0800,x			sta 	InputBuffer,x
.af77	c9 00		cmp #$00			cmp		#0
.af79	d0 ef		bne $af6a			bne 	_SLExtend
.af7b	ce 00 08	dec $0800			dec 	InputBuffer 				; because wrote the $00
.af7e					_SLExit:
.af7e	60		rts				rts
.af7f					_SLFNFail:
.af7f	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>af82	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>af8a	4e 41 4d 45 00
.af8f					_SLFNExtension:
>af8f	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.af94					Stack_Empty:
.af94	fa		plx				plx
.af95	a2 00		ldx #$00			ldx 	#0
.af97	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.af9a					Stack_Drop:
.af9a	fa		plx				plx
.af9b	ca		dex				dex
.af9c	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.af9f					Stack_Dup:
.af9f	fa		plx				plx
.afa0	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.afa3	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.afa6	bd 00 07	lda $0700,x			lda 	highStack,x
.afa9	9d 01 07	sta $0701,x			sta 	highStack+1,x
.afac	e8		inx				inx 								; bump stack pointer
.afad	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.afb0					Stack_Nip:
.afb0	fa		plx				plx
.afb1	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.afb4	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.afb7	bd 00 07	lda $0700,x			lda 	highStack,x
.afba	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.afbd	ca		dex				dex 								; drop tos
.afbe	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.afc1					Stack_Over:
.afc1	fa		plx				plx
.afc2	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.afc5	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.afc8	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.afcb	9d 01 07	sta $0701,x			sta 	highStack+1,x
.afce	e8		inx				inx 							; bump stack pointer
.afcf	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.afd2					Stack_Swap:
.afd2	fa		plx				plx
.afd3	5a		phy				phy
.afd4	bd 00 06	lda $0600,x			lda 	lowStack,x
.afd7	a8		tay				tay
.afd8	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.afdb	9d 00 06	sta $0600,x			sta 	lowStack,x
.afde	98		tya				tya
.afdf	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.afe2	bd 00 07	lda $0700,x			lda 	highStack,x
.afe5	a8		tay				tay
.afe6	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.afe9	9d 00 07	sta $0700,x			sta 	highStack,x
.afec	98		tya				tya
.afed	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.aff0	7a		ply				ply
.aff1	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.aff4					Command_Store:
.aff4	fa		plx				plx
.aff5	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.aff7	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.aff9	90 1f		bcc $b01a			bcc 	_CSLongVariable
.affb	c8		iny				iny 								; get the next
.affc	b1 00		lda ($00),y			lda 	(codePtr),y
.affe	88		dey				dey
.afff	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.b001	f0 17		beq $b01a			beq 	_CSLongVariable
.b003	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.b005	c8		iny				iny 								; skip over it and push on stack
.b006	5a		phy				phy
.b007	0a		asl a				asl 	a 							; double it, now C0-FE
.b008	a8		tay				tay 								; put in Y
.b009	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.b00c	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.b00f	bd 00 07	lda $0700,x			lda 	highStack,x
.b012	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.b015	ca		dex				dex 								; pop off stack
.b016	7a		ply				ply 								; restore position and do next
.b017	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b01a					_CSLongVariable:
.b01a	38		sec				sec 								; create variable if not found.
.b01b	20 32 a9	jsr $a932			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.b01e	20 a5 a6	jsr $a6a5			jsr 	IndexCheck 					; check indexing.
.b021	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.b024	92 02		sta ($02)			sta 	(zTemp0)
.b026	5a		phy				phy
.b027	a0 01		ldy #$01			ldy 	#1
.b029	bd 00 07	lda $0700,x			lda 	highStack,x
.b02c	91 02		sta ($02),y			sta 	(zTemp0),y
.b02e	7a		ply				ply
.b02f	ca		dex				dex 								; pop off stack
.b030	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.b033					Command_New:
.b033	fa		plx				plx
.b034	9c 00 10	stz $1000			stz 	ProgramStart
.b037	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b03a					Command_Old:
.b03a	fa		plx				plx
.b03b	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.b03d	85 00		sta $00				sta 	codePtr
.b03f	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.b041	85 01		sta $01				sta 	codePtr+1
.b043	a0 03		ldy #$03			ldy 	#3
.b045					_COAdvance:
.b045	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.b047	b0 0e		bcs $b057			bcs		_COFail
.b049	20 6b b4	jsr $b46b			jsr 	AdvanceInCode
.b04c	b1 00		lda ($00),y			lda 	(codePtr),y
.b04e	d0 f5		bne $b045			bne 	_COAdvance
.b050	c8		iny				iny 								; byte after end of line
.b051	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.b054					_CONotDeleted:
.b054	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b057					_COFail:
.b057	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b05a	43 41 4e 54 3f 00				.text 	"CANT?",0
.b060					Command_End:
.b060	fa		plx				plx
.b061	4c 1b a0	jmp $a01b			jmp 	WarmStart
.b064					Command_Stop:
>b064	ff						.byte 	$FF
.b065	fa		plx				plx
.b066	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b069	53 54 4f 50 00					.text 	"STOP",0
.b06e					Command_Assert:
.b06e	fa		plx				plx
.b06f	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.b072	1d 00 07	ora $0700,x			ora 	highStack,x
.b075	f0 04		beq $b07b			beq 	_CAFail
.b077	ca		dex				dex 								; throw if not.
.b078	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b07b					_CAFail:
.b07b	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b07e	41 53 53 45 52 54 00				.text 	"ASSERT",0
.b085					Command_Sys:
.b085	fa		plx				plx
.b086	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.b089	85 02		sta $02				sta 	zTemp0
.b08b	bd 00 07	lda $0700,x			lda 	highStack,x
.b08e	85 03		sta $03				sta 	zTemp0+1
.b090	ca		dex				dex 								; pop tos
.b091	da		phx				phx 								; save XY
.b092	5a		phy				phy
.b093	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.b096	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.b099	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.b09c	20 a4 b0	jsr $b0a4			jsr 	_CSCallInd
.b09f	7a		ply				ply 								; restore XY
.b0a0	fa		plx				plx
.b0a1	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b0a4					_CSCallInd:
.b0a4	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.b0a7					Command_DumpStack:
.b0a7	fa		plx				plx
.b0a8	da		phx				phx 								; save pos and sp
.b0a9	5a		phy				phy
.b0aa	86 10		stx $10				stx 	SignCount
.b0ac	a2 ff		ldx #$ff			ldx 	#$FF
.b0ae					_CDSLoop:
.b0ae	e4 10		cpx $10				cpx 	SignCount 					; done all ?
.b0b0	f0 2a		beq $b0dc			beq 	_CDSExit
.b0b2	e8		inx				inx
.b0b3	da		phx				phx 								; save SP
.b0b4	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.b0b7	a8		tay				tay
.b0b8	bd 00 06	lda $0600,x			lda 	lowStack,x
.b0bb	aa		tax				tax
.b0bc	c0 00		cpy #$00			cpy 	#0
.b0be	10 11		bpl $b0d1			bpl 	_CDSPositive
.b0c0	a9 2d		lda #$2d			lda 	#"-" 						; minus
.b0c2	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0c5	98		tya				tya 								; negate YX
.b0c6	49 ff		eor #$ff			eor 	#$FF
.b0c8	a8		tay				tay
.b0c9	8a		txa				txa
.b0ca	49 ff		eor #$ff			eor 	#$FF
.b0cc	aa		tax				tax
.b0cd	e8		inx				inx
.b0ce	d0 01		bne $b0d1			bne 	_CDSPositive
.b0d0	c8		iny				iny
.b0d1					_CDSPositive:
.b0d1	20 cb a4	jsr $a4cb			jsr 	PrintIntegerUnsigned
.b0d4	a9 20		lda #$20			lda 	#" " 						; space
.b0d6	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0d9	fa		plx				plx
.b0da	80 d2		bra $b0ae			bra 	_CDSLoop
.b0dc					_CDSExit:
.b0dc	a9 3c		lda #$3c			lda 	#"<"
.b0de	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0e1	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0e4	a9 0d		lda #$0d			lda 	#13 						; CR
.b0e6	20 e8 a4	jsr $a4e8			jsr 	PrintCharacter
.b0e9	7a		ply				ply
.b0ea	fa		plx				plx
.b0eb	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.b0ee					Stack_Add:
.b0ee	fa		plx				plx
.b0ef	ca		dex				dex
.b0f0	18		clc				clc
.b0f1	bd 00 06	lda $0600,x			lda		lowStack,x
.b0f4	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.b0f7	9d 00 06	sta $0600,x			sta 	lowStack,x
.b0fa	bd 00 07	lda $0700,x			lda		highStack,x
.b0fd	7d 01 07	adc $0701,x			adc 	highStack+1,x
.b100	9d 00 07	sta $0700,x			sta 	highStack,x
.b103	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b106					Stack_Sub:
.b106	fa		plx				plx
.b107	ca		dex				dex
.b108	38		sec				sec
.b109	bd 00 06	lda $0600,x			lda		lowStack,x
.b10c	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b10f	9d 00 06	sta $0600,x			sta 	lowStack,x
.b112	bd 00 07	lda $0700,x			lda		highStack,x
.b115	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b118	9d 00 07	sta $0700,x			sta 	highStack,x
.b11b	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b11e					Stack_And:
.b11e	fa		plx				plx
.b11f	ca		dex				dex
.b120	bd 00 06	lda $0600,x			lda		lowStack,x
.b123	3d 01 06	and $0601,x			and		lowStack+1,x
.b126	9d 00 06	sta $0600,x			sta 	lowStack,x
.b129	bd 00 07	lda $0700,x			lda		highStack,x
.b12c	3d 01 07	and $0701,x			and 	highStack+1,x
.b12f	9d 00 07	sta $0700,x			sta 	highStack,x
.b132	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b135					Stack_Xor:
.b135	fa		plx				plx
.b136	ca		dex				dex
.b137	bd 00 06	lda $0600,x			lda		lowStack,x
.b13a	5d 01 06	eor $0601,x			eor		lowStack+1,x
.b13d	9d 00 06	sta $0600,x			sta 	lowStack,x
.b140	bd 00 07	lda $0700,x			lda		highStack,x
.b143	5d 01 07	eor $0701,x			eor 	highStack+1,x
.b146	9d 00 07	sta $0700,x			sta 	highStack,x
.b149	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b14c					Stack_Or:
.b14c	fa		plx				plx
.b14d	ca		dex				dex
.b14e	bd 00 06	lda $0600,x			lda		lowStack,x
.b151	1d 01 06	ora $0601,x			ora		lowStack+1,x
.b154	9d 00 06	sta $0600,x			sta 	lowStack,x
.b157	bd 00 07	lda $0700,x			lda		highStack,x
.b15a	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b15d	9d 00 07	sta $0700,x			sta 	highStack,x
.b160	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b163					Stack_Shl:
.b163	fa		plx				plx
.b164	38		sec				sec
.b165	80 02		bra $b169			bra 	StackShift
.b167					Stack_Shr:
.b167	fa		plx				plx
.b168	18		clc				clc
.b169					StackShift:
.b169	08		php				php
.b16a	ca		dex				dex
.b16b	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.b16e	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.b170	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b173	d0 19		bne $b18e			bne 	_SSZero
.b175					_SSLoop:
.b175	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.b178	30 1a		bmi $b194			bmi 	_SSDone 					; completed ?
.b17a	28		plp				plp 								; restore flag
.b17b	08		php				php
.b17c	b0 08		bcs $b186			bcs 	_SSLeft 					; do either shift.
.b17e	5e 00 07	lsr $0700,x			lsr 	highStack,x
.b181	7e 00 06	ror $0600,x			ror 	lowStack,x
.b184	80 ef		bra $b175			bra 	_SSLoop
.b186					_SSLeft:
.b186	1e 00 06	asl $0600,x			asl 	lowStack,x
.b189	3e 00 07	rol $0700,x			rol 	highStack,x
.b18c	80 e7		bra $b175			bra 	_SSLoop
.b18e					_SSZero:
.b18e	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.b191	9e 00 07	stz $0700,x			stz 	highStack,x
.b194					_SSDone:
.b194	28		plp				plp 								; throw flag.
.b195	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.b198					Comp_Equal:
.b198	fa		plx				plx
.b199	38		sec				sec
.b19a	80 02		bra $b19e			bra 	Comp_CheckEqual
.b19c					Comp_NotEqual:
.b19c	fa		plx				plx
.b19d	18		clc				clc
.b19e					Comp_CheckEqual:
.b19e	08		php				php
.b19f	ca		dex				dex
.b1a0	bd 00 06	lda $0600,x			lda		lowStack,x
.b1a3	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.b1a6	d0 06		bne $b1ae			bne 	_CCENonZero
.b1a8	bd 00 07	lda $0700,x			lda		highStack,x
.b1ab	5d 01 07	eor $0701,x			eor 	highStack+1,x
.b1ae					_CCENonZero:
.b1ae	f0 02		beq $b1b2			beq 	_CCENotSet
.b1b0	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.b1b2					_CCENotSet:
.b1b2					CompCheckFlip:
.b1b2	28		plp				plp 								; if carry set, we want $FF if equal
.b1b3	90 02		bcc $b1b7			bcc 	CompReturn
.b1b5	49 ff		eor #$ff			eor 	#$FF
.b1b7					CompReturn:
.b1b7	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.b1ba	9d 00 07	sta $0700,x			sta 	highStack,x
.b1bd	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b1c0					Comp_Less:
.b1c0	fa		plx				plx
.b1c1	18		clc				clc
.b1c2	80 02		bra $b1c6			bra 	Comp_LessCont
.b1c4					Comp_GreaterEqual:
.b1c4	fa		plx				plx
.b1c5	38		sec				sec
.b1c6					Comp_LessCont:
.b1c6	08		php				php
.b1c7	ca		dex				dex
.b1c8	38		sec				sec
.b1c9	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.b1cc	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b1cf	bd 00 07	lda $0700,x			lda 	highStack,x
.b1d2	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b1d5	50 02		bvc $b1d9			bvc 	_CLNoFlip 					; unsigned -> signed
.b1d7	49 80		eor #$80			eor 	#$80
.b1d9					_CLNoFlip:
.b1d9	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.b1db	f0 d5		beq $b1b2			beq 	CompCheckFlip
.b1dd	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.b1df	80 d1		bra $b1b2			bra 	CompCheckFlip
.b1e1					Comp_LessEqual:
.b1e1	fa		plx				plx
.b1e2	38		sec				sec
.b1e3	80 02		bra $b1e7			bra 	Comp_LessEqualCont
.b1e5					Comp_Greater:
.b1e5	fa		plx				plx
.b1e6	18		clc				clc
.b1e7					Comp_LessEqualCont:
.b1e7	08		php				php
.b1e8	ca		dex				dex
.b1e9	38		sec				sec
.b1ea	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.b1ed	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.b1f0	bd 01 07	lda $0701,x			lda 	highStack+1,x
.b1f3	fd 00 07	sbc $0700,x			sbc 	highStack,x
.b1f6	50 02		bvc $b1fa			bvc 	_CLENoFlip 					; unsigned -> signed
.b1f8	49 80		eor #$80			eor 	#$80
.b1fa					_CLENoFlip:
.b1fa	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.b1fc	f0 b4		beq $b1b2			beq 	CompCheckFlip
.b1fe	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.b200	80 b0		bra $b1b2			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.b202					DivInteger16:
.b202	fa		plx				plx
.b203	20 09 b2	jsr $b209			jsr 	IntegerDivide
.b206	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b209					IntegerDivide:
.b209	ca		dex				dex
.b20a	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.b20d	1d 01 07	ora $0701,x			ora 	highStack+1,x
.b210	d0 14		bne $b226			bne 	_BFDOkay
.b212	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b215	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>b21d	20 42 59 20 5a 45 52 4f 00
.b226					_BFDOkay:
.b226	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.b228	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.b22a	64 10		stz $10				stz 	SignCount 					; Count of signs.
.b22c	20 68 b2	jsr $b268			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b22f	e8		inx				inx
.b230	20 68 b2	jsr $b268			jsr 	CheckIntegerNegate
.b233	ca		dex				dex
.b234	5a		phy				phy 								; Y is the counter
.b235	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.b237					_BFDLoop:
.b237	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.b23a	3e 00 07	rol $0700,x			rol 	highStack,x
.b23d	26 04		rol $04				rol 	zTemp1
.b23f	26 05		rol $05				rol 	zTemp1+1
.b241	38		sec				sec
.b242	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.b244	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.b247	48		pha				pha
.b248	a5 05		lda $05				lda 	zTemp1+1
.b24a	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.b24d	90 0f		bcc $b25e			bcc 	_BFDNoAdd
.b24f	85 05		sta $05				sta 	zTemp1+1
.b251	68		pla				pla
.b252	85 04		sta $04				sta 	zTemp1+0
.b254	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.b257	09 01		ora #$01			ora 	#1
.b259	9d 00 06	sta $0600,x			sta 	lowStack,x
.b25c	80 01		bra $b25f			bra 	_BFDNext
.b25e					_BFDNoAdd:
.b25e	68		pla				pla 								; Throw away the intermediate calculations
.b25f					_BFDNext:
.b25f	88		dey				dey
.b260	d0 d5		bne $b237			bne 	_BFDLoop
.b262	7a		ply				ply 								; restore Y
.b263	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.b265	b0 07		bcs $b26e			bcs		IntegerNegateAlways 		; negate the result
.b267	60		rts				rts
.b268					CheckIntegerNegate:
.b268	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.b26b	30 01		bmi $b26e			bmi 	IntegerNegateAlways 		; if so negate it
.b26d	60		rts				rts
.b26e					IntegerNegateAlways:
.b26e	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.b270	4c cb b2	jmp $b2cb			jmp 	Unary_Negate
.b273					ModInteger16:
.b273	fa		plx				plx
.b274	20 09 b2	jsr $b209			jsr 	IntegerDivide
.b277	a5 04		lda $04				lda 	zTemp1
.b279	9d 00 06	sta $0600,x			sta 	lowStack,x
.b27c	a5 05		lda $05				lda 	zTemp1+1
.b27e	9d 00 07	sta $0700,x			sta 	highStack,x
.b281	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.b284					MulInteger16:
.b284	fa		plx				plx
.b285	ca		dex				dex
.b286	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.b289	85 04		sta $04				sta 	zTemp1
.b28b	bd 00 07	lda $0700,x			lda 	highStack,x
.b28e	85 05		sta $05				sta 	zTemp1+1
.b290	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.b293	9e 00 07	stz $0700,x			stz 	highStack,x
.b296					_BFMMultiply:
.b296	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.b298	29 01		and #$01			and 	#1
.b29a	f0 13		beq $b2af			beq 	_BFMNoAdd
.b29c	18		clc				clc 								; add old tos to current tos.
.b29d	bd 00 06	lda $0600,x			lda		lowStack,x
.b2a0	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.b2a3	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2a6	bd 00 07	lda $0700,x			lda		highStack,x
.b2a9	7d 01 07	adc $0701,x			adc 	highStack+1,x
.b2ac	9d 00 07	sta $0700,x			sta 	highStack,x
.b2af					_BFMNoAdd:
.b2af	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.b2b2	3e 01 07	rol $0701,x			rol 	highStack+1,x
.b2b5	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.b2b7	66 04		ror $04				ror 	zTemp1+0
.b2b9	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.b2bb	05 05		ora $05				ora 	zTemp1+1
.b2bd	d0 d7		bne $b296			bne 	_BFMMultiply
.b2bf	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.b2c2					Unary_Absolute:
.b2c2	fa		plx				plx
.b2c3	bd 00 07	lda $0700,x			lda 	highStack,x
.b2c6	30 04		bmi $b2cc			bmi 	Unary_Negate_Code
.b2c8	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b2cb					Unary_Negate:
.b2cb	fa		plx				plx
.b2cc					Unary_Negate_Code:
.b2cc	38		sec				sec
.b2cd	a9 00		lda #$00			lda		#0
.b2cf	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.b2d2	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2d5	a9 00		lda #$00			lda		#0
.b2d7	fd 00 07	sbc $0700,x			sbc 	highStack,x
.b2da	9d 00 07	sta $0700,x			sta 	highStack,x
.b2dd	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b2e0					Unary_Not:
.b2e0	fa		plx				plx
.b2e1	bd 00 06	lda $0600,x			lda 	lowStack,x
.b2e4	49 ff		eor #$ff			eor 	#$FF
.b2e6	9d 00 06	sta $0600,x			sta 	lowStack,x
.b2e9	bd 00 07	lda $0700,x			lda 	highStack,x
.b2ec	49 ff		eor #$ff			eor 	#$FF
.b2ee	9d 00 07	sta $0700,x			sta 	highStack,x
.b2f1	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b2f4					Unary_Increment:
.b2f4	fa		plx				plx
.b2f5	fe 00 06	inc $0600,x			inc 	lowStack,x
.b2f8	d0 03		bne $b2fd			bne 	_UIExit
.b2fa	fe 00 07	inc $0700,x			inc 	highStack,x
.b2fd					_UIExit:
.b2fd	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b300					Unary_Decrement:
.b300	fa		plx				plx
.b301	bd 00 06	lda $0600,x			lda 	lowStack,x
.b304	d0 03		bne $b309			bne 	_UDNoBorrow
.b306	de 00 07	dec $0700,x			dec 	highStack,x
.b309					_UDNoBorrow:
.b309	de 00 06	dec $0600,x			dec 	lowStack,x
.b30c	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b30f					Unary_BSwap:
.b30f	fa		plx				plx
.b310	bd 00 06	lda $0600,x			lda 	lowStack,x
.b313	48		pha				pha
.b314	bd 00 07	lda $0700,x			lda 	highStack,x
.b317	9d 00 06	sta $0600,x			sta 	lowStack,x
.b31a	68		pla				pla
.b31b	9d 00 07	sta $0700,x			sta 	highStack,x
.b31e	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b321					Unary_Shl:
.b321	fa		plx				plx
.b322	1e 00 06	asl $0600,x			asl 	lowStack,x
.b325	3e 00 07	rol $0700,x			rol 	highStack,x
.b328	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b32b					Unary_Shr:
.b32b	fa		plx				plx
.b32c	5e 00 07	lsr $0700,x			lsr 	highStack,x
.b32f	7e 00 06	ror $0600,x			ror 	lowStack,x
.b332	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b335					Unary_Sgn:
.b335	fa		plx				plx
.b336	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.b339	10 0a		bpl $b345			bpl 	_USNotNeg
.b33b	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.b33d	9d 00 06	sta $0600,x			sta 	lowStack,x
.b340	9d 00 07	sta $0700,x			sta 	highStack,x
.b343	80 10		bra $b355			bra 	_USExit
.b345					_USNotNeg:
.b345	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.b348	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.b34b	9e 00 07	stz $0700,x			stz 	highStack,x
.b34e	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.b350	f0 03		beq $b355			beq 	_USExit
.b352	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.b355					_USExit:
.b355	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b358					Random_Handler:
.b358	fa		plx				plx
.b359	a5 15		lda $15				lda 	randomSeed
.b35b	05 16		ora $16				ora 	randomSeed+1
.b35d	d0 08		bne $b367			bne 	_RH_NoInit
.b35f	a9 7c		lda #$7c			lda 	#$7C
.b361	85 15		sta $15				sta 	randomSeed
.b363	a9 a1		lda #$a1			lda 	#$A1
.b365	85 16		sta $16				sta 	randomSeed+1
.b367					_RH_NoInit:
.b367	a5 15		lda $15				lda 	randomSeed
.b369	4a		lsr a		        lsr		a
.b36a	26 16		rol $16		        rol 	randomSeed+1
.b36c	90 02		bcc $b370	        bcc 	_RH_NoEor
.b36e	49 b4		eor #$b4	        eor 	#$B4
.b370					_RH_NoEor:
.b370	85 15		sta $15		        sta 	randomSeed
.b372	45 16		eor $16		        eor 	randomSeed+1
.b374	e8		inx		        inx
.b375	9d 00 07	sta $0700,x	        sta 	highStack,x
.b378	a5 15		lda $15		        lda 	randomSeed
.b37a	9d 00 06	sta $0600,x	        sta 	lowStack,x
.b37d	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.b380					Command_Call:
.b380	fa		plx				plx
.b381	20 37 a8	jsr $a837			jsr 	StackPushPosition 				; save stack position
.b384	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.b386	20 27 a8	jsr $a827			jsr 	StackPushByte
.b389	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.b38b	85 02		sta $02				sta 	zTemp0
.b38d	c8		iny				iny
.b38e	b1 00		lda ($00),y			lda 	(codePtr),y
.b390	85 03		sta $03				sta 	zTemp0+1
.b392	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.b394	85 00		sta $00				sta 	codePtr
.b396	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.b398	85 01		sta $01				sta 	codePtr+1
.b39a	a0 01		ldy #$01			ldy 	#1
.b39c					_CCSearch:
.b39c	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.b39e	f0 2d		beq $b3cd			beq		_CCFail
.b3a0	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.b3a2	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.b3a4	f0 0d		beq $b3b3			beq 	_CCCheckMSB
.b3a6	18		clc				clc 									; forward to next line.
.b3a7	b2 00		lda ($00)			lda 	(codePtr)
.b3a9	65 00		adc $00				adc 	codePtr
.b3ab	85 00		sta $00				sta 	codePtr
.b3ad	90 ed		bcc $b39c			bcc 	_CCSearch
.b3af	e6 01		inc $01				inc 	codePtr+1
.b3b1	80 e9		bra $b39c			bra 	_CCSearch
.b3b3					_CCCheckMSB:
.b3b3	c8		iny				iny 									; get MSB, keeping Y as 1
.b3b4	b1 00		lda ($00),y			lda 	(codePtr),y
.b3b6	88		dey				dey
.b3b7	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.b3b9	d0 e1		bne $b39c			bne 	_CCSearch
.b3bb	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.b3bd	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.b3bf	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.b3c1	d0 0a		bne $b3cd			bne 	_CCFail
.b3c3	c8		iny				iny 									; get the length of this.
.b3c4	b1 00		lda ($00),y			lda 	(codePtr),y
.b3c6	18		clc				clc
.b3c7	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.b3c9	a8		tay				tay
.b3ca	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b3cd					_CCFail:
.b3cd	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b3d0	43 41 4c 4c 3f 00				.text 	"CALL?",0
.b3d6					Command_Return:
.b3d6	fa		plx				plx
.b3d7	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.b3d9	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b3dc	90 0f		bcc $b3ed			bcc 	_CRFail
.b3de	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.b3e0	20 54 a8	jsr $a854			jsr 	StackRestorePosition
.b3e3	c8		iny				iny
.b3e4	c8		iny				iny
.b3e5	a9 04		lda #$04			lda 	#4 								; pop off stack
.b3e7	20 4e a8	jsr $a84e			jsr 	StackPop
.b3ea	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b3ed					_CRFail:
.b3ed	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b3f0	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.b3f6					Structure_If:
.b3f6	fa		plx				plx
.b3f7	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.b3f9	20 27 a8	jsr $a827			jsr 	StackPushByte
.b3fc	18		clc				clc
.b3fd	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.b400	1d 00 07	ora $0700,x			ora 	highStack,x
.b403	ca		dex				dex 									; drop TOS
.b404	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.b406	d0 0e		bne $b416			bne 	_SIFNoSkip 						; at this level.
.b408	da		phx				phx
.b409	a9 38		lda #$38			lda 	#KWD_ELSE
.b40b	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.b40d	20 43 b4	jsr $b443			jsr 	StructSkipForward
.b410	fa		plx				plx 									; restore X
.b411	c9 38		cmp #$38			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.b413	d0 01		bne $b416			bne 	_SIFNoSkip 						; clause.
.b415	c8		iny				iny
.b416					_SIFNoSkip:
.b416	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b419					Structure_Else:
.b419	fa		plx				plx
.b41a	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b41c	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b41f	90 0b		bcc $b42c			bcc 	SIFail
.b421	da		phx				phx 									; got here by executing IF clause so skip
.b422	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.b424	aa		tax				tax
.b425	20 43 b4	jsr $b443			jsr 	StructSkipForward
.b428	fa		plx				plx
.b429	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b42c					SIFail:
.b42c	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b42f	49 46 3f 00					.text 	"IF?",0
.b433					Structure_Endif:
.b433	fa		plx				plx
.b434	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.b436	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b439	90 f1		bcc $b42c			bcc 	SIFail
.b43b	a9 01		lda #$01			lda 	#1 								; throw it.
.b43d	20 4e a8	jsr $a84e			jsr 	StackPop
.b440	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b443					StructSkipForward:
.b443	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.b445	86 03		stx $03				stx 	zTemp0+1
.b447	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.b449					_SSFLoop:
.b449	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.b44b	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.b44d	d0 08		bne $b457			bne		_SSFFail
.b44f	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.b451	f0 17		beq $b46a			beq 	_SSFEnd
.b453	c5 03		cmp $03				cmp 	zTemp0+1
.b455	f0 13		beq $b46a			beq 	_SSFEnd
.b457					_SSFFail:
.b457	20 6b b4	jsr $b46b			jsr 	AdvanceInCode 					; skip over in code.
.b45a	b0 ed		bcs $b449			bcs 	_SSFLoop 						; if not end of program, keep going.
.b45c	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b45f	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>b467	45 3f 00
.b46a					_SSFEnd:
.b46a	60		rts				rts
.b46b					AdvanceInCode:
.b46b	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.b46d	f0 28		beq $b497			beq 	_AICEndOfLine 					; end of line.
.b46f	c8		iny				iny 									; advance one.
.b470	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.b472	90 10		bcc $b484			bcc 	_AICControl
.b474	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.b476	b0 0a		bcs $b482			bcs 	_AICExit
.b478	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.b47a	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.b47c	90 04		bcc $b482			bcc 	_AICExit
.b47e	c6 04		dec $04				dec 	zTemp1
.b480	c6 04		dec $04				dec 	zTemp1
.b482					_AICExit:
.b482	38		sec				sec
.b483	60		rts				rts
.b484					_AICControl:
.b484	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.b486	f0 0b		beq $b493			beq 	_AICThree
.b488	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.b48a	f0 07		beq $b493			beq 	_AICThree
.b48c	98		tya				tya										; skip over a string/comment/define.
.b48d	38		sec				sec
.b48e	71 00		adc ($00),y			adc 	(codePtr),y
.b490	a8		tay				tay
.b491	38		sec				sec
.b492	60		rts				rts
.b493					_AICThree:
.b493	c8		iny				iny
.b494	c8		iny				iny
.b495	38		sec				sec
.b496	60		rts				rts
.b497					_AICEndOfLine:
.b497	18		clc				clc 									; forward to next line.
.b498	b2 00		lda ($00)			lda 	(codePtr)
.b49a	65 00		adc $00				adc 	codePtr
.b49c	85 00		sta $00				sta 	codePtr
.b49e	90 02		bcc $b4a2			bcc 	_AICNoCarry
.b4a0	e6 01		inc $01				inc 	codePtr+1
.b4a2					_AICNoCarry:
.b4a2	a0 03		ldy #$03			ldy 	#3 								; start of new line
.b4a4	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.b4a6	d0 da		bne $b482			bne 	_AICExit
.b4a8	18		clc				clc 									; program end.
.b4a9	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.b4aa					Struct_Repeat:
.b4aa	fa		plx				plx
.b4ab	20 37 a8	jsr $a837			jsr 	StackPushPosition 				; save stack position
.b4ae	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.b4b0	20 27 a8	jsr $a827			jsr 	StackPushByte
.b4b3	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b4b6					Struct_Until:
.b4b6	fa		plx				plx
.b4b7	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.b4b9	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b4bc	90 1b		bcc $b4d9			bcc 	_SUFail
.b4be	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.b4c1	1d 00 07	ora $0700,x			ora 	highStack,x
.b4c4	ca		dex				dex
.b4c5	09 00		ora #$00			ora 	#0
.b4c7	f0 08		beq $b4d1			beq 	_SULoopBack 					; if so keep going.
.b4c9	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.b4cb	20 4e a8	jsr $a84e			jsr 	StackPop
.b4ce	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b4d1					_SULoopBack:
.b4d1	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b4d3	20 54 a8	jsr $a854			jsr 	StackRestorePosition
.b4d6	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b4d9					_SUFail:
.b4d9	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b4dc	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>b4e4	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.b4e6					Struct_For:
.b4e6	fa		plx				plx
.b4e7	18		clc				clc
.b4e8	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.b4eb	49 ff		eor #$ff			eor 	#$FF
.b4ed	69 01		adc #$01			adc 	#1
.b4ef	08		php				php
.b4f0	20 27 a8	jsr $a827			jsr 	StackPushByte
.b4f3	bd 00 07	lda $0700,x			lda 	highStack,x
.b4f6	49 ff		eor #$ff			eor 	#$FF
.b4f8	28		plp				plp
.b4f9	69 00		adc #$00			adc 	#0
.b4fb	20 27 a8	jsr $a827			jsr 	StackPushByte
.b4fe	ca		dex				dex 									; throw TOS
.b4ff	20 37 a8	jsr $a837			jsr 	StackPushPosition 				; save stack position
.b502	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.b504	20 27 a8	jsr $a827			jsr 	StackPushByte
.b507	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b50a					Struct_Index:
.b50a	fa		plx				plx
.b50b	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b50d	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b510	90 43		bcc $b555			bcc 	SNFail
.b512	e8		inx				inx 									; new stack entry
.b513	5a		phy				phy
.b514	a0 04		ldy #$04			ldy 	#4 								; access index value
.b516	b1 0e		lda ($0e),y			lda 	(iStack),y
.b518	49 ff		eor #$ff			eor 	#$FF
.b51a	9d 00 07	sta $0700,x			sta 	highStack,x
.b51d	c8		iny				iny
.b51e	b1 0e		lda ($0e),y			lda 	(iStack),y
.b520	49 ff		eor #$ff			eor 	#$FF
.b522	9d 00 06	sta $0600,x			sta 	lowStack,x
.b525	7a		ply				ply 									; restore code pointer
.b526	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b529					Struct_Next:
.b529	fa		plx				plx
.b52a	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.b52c	20 46 a8	jsr $a846			jsr 	StackCheckTop
.b52f	90 24		bcc $b555			bcc 	SNFail
.b531	5a		phy				phy 									; save code position
.b532	a0 05		ldy #$05			ldy 	#5 								; bump the count
.b534	b1 0e		lda ($0e),y			lda 	(iStack),y
.b536	1a		inc a				inc 	a
.b537	91 0e		sta ($0e),y			sta 	(iStack),y
.b539	d0 11		bne $b54c			bne 	_SNLoopBack
.b53b	88		dey				dey
.b53c	b1 0e		lda ($0e),y			lda 	(iStack),y
.b53e	1a		inc a				inc 	a
.b53f	91 0e		sta ($0e),y			sta 	(iStack),y
.b541	d0 09		bne $b54c			bne 	_SNLoopBack  					; non-zero loop back.
.b543	7a		ply				ply 									; restore code position.
.b544	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.b546	20 4e a8	jsr $a84e			jsr 	StackPop
.b549	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b54c					_SNLoopBack:
.b54c	7a		ply				ply 									; restore code position, being junked anyway.
.b54d	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.b54f	20 54 a8	jsr $a854			jsr 	StackRestorePosition
.b552	4c 0a a5	jmp $a50a			jmp 	ExecuteLoop
.b555					SNFail:
.b555	20 9e a4	jsr $a49e			jsr 	ErrorHandler
>b558	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
