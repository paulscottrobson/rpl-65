
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Thu Nov 14 14:14:36 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					iStack:			.word ?						; stack pointer
>000c					signCount:		.byte ? 					; divide sign count.
>000d					allocPtr:		.word ? 					; memory allocation pointer (down)
>000f					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0011					randomSeed:		.word ? 					; random number seed
>0013					prefixCharacter:.byte ?						; char to print before listed element.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1664					highStack = StackAddress+128				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=5					CTH_ERROR = COL_MAGENTA
=7					CTH_TOKEN = COL_WHITE
=3					CTH_IDENT = COL_YELLOW
=15					CTH_COMMENT = COL_WHITE|COL_RVS
=5					CTH_STRING = COL_MAGENTA
=2					CTH_CALLWORD = COL_GREEN
=6					CTH_NUMBER = COL_CYAN
=6					CTH_LINENO = COL_CYAN
=14					CTH_DEFINITION = COL_CYAN|COL_RVS

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	0d e8 03 01 fc ff aa 3b			.byte	$0d,$e8,$03,$01,$fc,$ff,$aa,$3b,$02,$60,$04,$aa,$00,$29,$f2,$03,$04,$10,$54,$48,$49,$53,$20,$49,$53,$20,$41,$20,$53,$54,$52,$49,$4e,$47,$03,$11,$54,$48,$49,$53,$20,$49,$53,$20,$41,$20,$43,$4f,$4d,$4d,$45,$4e,$54,$00,$0f,$fc,$03,$01,$00,$60,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$60,$04,$02,$6a,$04,$0b,$00,$04,$24,$04,$00,$05,$2e,$04,$07,$00,$12,$38,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$60,$04,$02,$b0,$04,$0b,$00,$04,$42,$04,$00,$06,$4c,$04,$80,$0a,$00,$04,$56,$04,$00,$1e,$60,$04,$05,$06,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$6a,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$74,$04,$02,$7e,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$7e,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$88,$04,$39,$00,$15,$7e,$04,$05,$04,$d2,$d3,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$88,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$92,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$9c,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$a6,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$b0,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$ba,$04,$a0,$02,$88,$04,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ce,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$d8,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$e2,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$ec,$04,$01,$51,$00,$02,$88,$04,$00,$05,$f6,$04,$39,$00,$04,$00,$05,$00
>1008	02 60 04 aa 00 29 f2 03 04 10 54 48 49 53 20 49
>1018	53 20 41 20 53 54 52 49 4e 47 03 11 54 48 49 53
>1028	20 49 53 20 41 20 43 4f 4d 4d 45 4e 54 00 0f fc
>1038	03 01 00 60 22 c2 c1 cc cc cd c5 ed 00 0b 06 04
>1048	a0 22 c3 cf d5 ce f4 00 0d 10 04 01 8e 00 22 e1
>1058	01 d2 ff 25 00 12 1a 04 c3 cf d5 ce f4 08 38 02
>1068	60 04 02 6a 04 0b 00 04 24 04 00 05 2e 04 07 00
>1078	12 38 04 c3 cf d5 ce f4 08 38 02 60 04 02 b0 04
>1088	0b 00 04 42 04 00 06 4c 04 80 0a 00 04 56 04 00
>1098	1e 60 04 05 06 d3 c5 cc c5 c3 f4 2d 2d 2d 2d c2
>10a8	c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 39 00 29 6a
>10b8	04 05 09 c2 c1 cc cc db c9 ce c9 f4 30 27 01 50
>10c8	00 0e 22 c2 c1 cc ec 23 80 24 30 27 bc 0e 22 c2
>10d8	c1 cc ec 23 81 24 00 2d 74 04 02 7e 04 22 c2 c1
>10e8	cc ec 23 82 24 02 7e 04 22 c2 c1 cc ec 23 83 24
>10f8	30 87 11 2a 22 c2 c1 cc ec 23 84 24 01 51 00 02
>1108	88 04 39 00 15 7e 04 05 04 d2 d3 c7 ee 30 81 11
>1118	06 81 37 01 ff ff 09 39 00 0f 88 04 05 09 c2 c1
>1128	cc cc db c4 d2 c1 f7 00 10 92 04 c2 c1 cc ec 23
>1138	80 24 2d 01 20 9f 1d 00 0f 9c 04 c2 c1 cc ec 23
>1148	81 24 01 21 9f 1d 00 19 a6 04 90 01 22 9f 1d 01
>1158	23 9f 1d c2 c1 cc ec 23 84 24 01 23 9f 1d 39 00
>1168	0f b0 04 05 09 c2 c1 cc cc db cd cf d6 e5 00 08
>1178	ba 04 a0 02 88 04 00 1c c4 04 c2 c1 cc ec 23 80
>1188	24 c2 c1 cc ec 23 82 24 0f 33 22 c2 c1 cc ec 23
>1198	80 24 00 1f ce 04 33 01 50 00 1a 36 80 19 12 06
>11a8	c2 c1 cc ec 23 82 24 28 22 c2 c1 cc ec 23 82 24
>11b8	09 00 1c d8 04 c2 c1 cc ec 23 81 24 c2 c1 cc ec
>11c8	23 83 24 0f 33 22 c2 c1 cc ec 23 81 24 00 1d e2
>11d8	04 33 bc 1a 36 80 19 12 06 c2 c1 cc ec 23 83 24
>11e8	28 22 c2 c1 cc ec 23 83 24 09 00 0a ec 04 01 51
>11f8	00 02 88 04 00 05 f6 04 39 00 04 00 05 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 8e a2	jsr $a28e			jsr 	ExternInitialise
.a006	4c e3 a1	jmp $a1e3			jmp 	ExecuteProgram
.a009					WarmStart:
>a009	ff						.byte 	$FF
.a00a	a2 55		ldx #$55			ldx 	#$55

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a00c					KeywordText:
>a00c	01 ff					.text $01,$ff                          ; $0000 %eol
>a00e	01 ff					.text $01,$ff                          ; $0001 %const
>a010	01 ff					.text $01,$ff                          ; $0002 %call
>a012	01 ff					.text $01,$ff                          ; $0003 %comment
>a014	01 ff					.text $01,$ff                          ; $0004 %qstring
>a016	01 ff					.text $01,$ff                          ; $0005 %define
>a018	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a01b	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a022	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a026	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a02c	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a032	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a037	01 aa					.text $01,$aa                          ; $000c *
>a039	01 af					.text $01,$af                          ; $000d /
>a03b	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a03f	01 ab					.text $01,$ab                          ; $000f +
>a041	01 ad					.text $01,$ad                          ; $0010 -
>a043	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a047	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a04a	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a04e	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a052	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a056	01 bd					.text $01,$bd                          ; $0016 =
>a058	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a05b	01 be					.text $01,$be                          ; $0018 >
>a05d	01 bc					.text $01,$bc                          ; $0019 <
>a05f	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a062	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a065	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a068	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a06b	01 c0					.text $01,$c0                          ; $001e @
>a06d	01 a1					.text $01,$a1                          ; $001f !
>a06f	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a072	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a078	01 de					.text $01,$de                          ; $0022 ^
>a07a	01 db					.text $01,$db                          ; $0023 [
>a07c	01 dd					.text $01,$dd                          ; $0024 ]
>a07e	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a082	01 bf					.text $01,$bf                          ; $0026 ?
>a084	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a088	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a08f	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a093	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a096	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a099	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a09f	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a0a2	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a0a5	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a0a9	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a0ad	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a0b1	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a0b6	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a0ba	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a0be	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a0c3	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a0c8	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a0cd	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a0d3	01 bb					.text $01,$bb                          ; $0039 ;
>a0d5	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a0dc	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a0e1	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a0e5	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a0e9	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a0ee	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a0f2	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a0f6	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a0fb	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a100	00					.byte 0
>a101						.align 2
.a102					DispatchHandler:
>a102	4f a2					.word ExecuteNextLine          ; $0000 %eol
>a104	65 a2					.word LongConstant             ; $0001 %const
>a106	79 ac					.word Command_Call             ; $0002 %call
>a108	4f a2					.word ExecuteComment           ; $0003 %comment
>a10a	76 a2					.word StringConstant           ; $0004 %qstring
>a10c	88 a1					.word SyntaxError              ; $0005 %define
>a10e	ef ac					.word Structure_If             ; $0006 if
>a110	a3 ad					.word Struct_Repeat            ; $0007 repeat
>a112	df ad					.word Struct_For               ; $0008 for
>a114	2c ad					.word Structure_Endif          ; $0009 endif
>a116	af ad					.word Struct_Until             ; $000a until
>a118	22 ae					.word Struct_Next              ; $000b next
>a11a	7d ab					.word MulInteger16             ; $000c *
>a11c	fb aa					.word DivInteger16             ; $000d /
>a11e	6c ab					.word ModInteger16             ; $000e mod
>a120	e7 a9					.word Stack_Add                ; $000f +
>a122	ff a9					.word Stack_Sub                ; $0010 -
>a124	17 aa					.word Stack_And                ; $0011 and
>a126	45 aa					.word Stack_Or                 ; $0012 or
>a128	2e aa					.word Stack_Xor                ; $0013 xor
>a12a	5c aa					.word Stack_Shl                ; $0014 shl
>a12c	60 aa					.word Stack_Shr                ; $0015 shr
>a12e	91 aa					.word Comp_Equal               ; $0016 =
>a130	95 aa					.word Comp_NotEqual            ; $0017 <>
>a132	de aa					.word Comp_Greater             ; $0018 >
>a134	b9 aa					.word Comp_Less                ; $0019 <
>a136	bd aa					.word Comp_GreaterEqual        ; $001a >=
>a138	da aa					.word Comp_LessEqual           ; $001b <=
>a13a	06 a8					.word Mem_Peek                 ; $001c c@
>a13c	38 a8					.word Mem_Poke                 ; $001d c!
>a13e	1c a8					.word Mem_WPeek                ; $001e @
>a140	4d a8					.word Mem_WPoke                ; $001f !
>a142	6b a8					.word Mem_DWPoke               ; $0020 d!
>a144	85 a8					.word Mem_Alloc                ; $0021 alloc
>a146	13 a9					.word Command_Store            ; $0022 ^
>a148	88 a1					.word SyntaxError              ; $0023 [
>a14a	88 a1					.word SyntaxError              ; $0024 ]
>a14c	7e a9					.word Command_Sys              ; $0025 sys
>a14e	a0 a9					.word Command_DumpStack        ; $0026 ?
>a150	bb ab					.word Unary_Absolute           ; $0027 abs
>a152	c4 ab					.word Unary_Negate             ; $0028 negate
>a154	d9 ab					.word Unary_Not                ; $0029 not
>a156	ed ab					.word Unary_Increment          ; $002a ++
>a158	f9 ab					.word Unary_Decrement          ; $002b --
>a15a	08 ac					.word Unary_BSwap              ; $002c bswap
>a15c	1a ac					.word Unary_Shl                ; $002d <<
>a15e	24 ac					.word Unary_Shr                ; $002e >>
>a160	2e ac					.word Unary_Sgn                ; $002f sgn
>a162	51 ac					.word Random_Handler           ; $0030 rnd
>a164	b3 a8					.word Stack_Empty              ; $0031 clr
>a166	b9 a8					.word Stack_Drop               ; $0032 drop
>a168	be a8					.word Stack_Dup                ; $0033 dup
>a16a	cf a8					.word Stack_Nip                ; $0034 nip
>a16c	e0 a8					.word Stack_Over               ; $0035 over
>a16e	f1 a8					.word Stack_Swap               ; $0036 swap
>a170	12 ad					.word Structure_Else           ; $0037 else
>a172	03 ae					.word Struct_Index             ; $0038 index
>a174	cf ac					.word Command_Return           ; $0039 ;
>a176	67 a9					.word Command_Assert           ; $003a assert
>a178	1e a6					.word Cmd_List                 ; $003b list
>a17a	52 a9					.word Command_New              ; $003c new
>a17c	88 a1					.word SyntaxError              ; $003d old
>a17e	5d a9					.word Command_Stop             ; $003e stop
>a180	e3 a1					.word ExecuteProgram           ; $003f run
>a182	59 a9					.word Command_End              ; $0040 end
>a184	88 a1					.word SyntaxError              ; $0041 save
>a186	88 a1					.word SyntaxError              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a188					SyntaxError:
.a188	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a18b	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a192					ErrorHandler:
.a192	fa		plx				plx 								; pull address off.
.a193	7a		ply				ply
.a194	e8		inx				inx 								; point to message
.a195	d0 01		bne $a198			bne 	_EHNoCarry
.a197	c8		iny				iny
.a198					_EHNoCarry:
.a198	20 c8 a1	jsr $a1c8			jsr 	PrintStringXY 				; print string at XY
.a19b	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a19d	f0 13		beq $a1b2			beq 	_EHNoLine
.a19f	a2 b7		ldx #$b7			ldx 	#_EHMessage & $FF 			; print " AT "
.a1a1	a0 a1		ldy #$a1			ldy 	#_EHMessage >> 8
.a1a3	20 c8 a1	jsr $a1c8			jsr 	PrintStringXY
.a1a6	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a1a8	b1 00		lda ($00),y			lda 	(codePtr),y
.a1aa	aa		tax				tax
.a1ab	c8		iny				iny
.a1ac	b1 00		lda ($00),y			lda 	(codePtr),y
.a1ae	a8		tay				tay
.a1af	20 bc a1	jsr $a1bc			jsr 	PrintIntegerUnsigned
.a1b2					_EHNoLine:
.a1b2	80 fe		bra $a1b2			bra 	_EHNoLine
.a1b4	4c 09 a0	jmp $a009			jmp 	WarmStart
.a1b7					_EHMessage:
>a1b7	20 41 54 20 00					.text	" AT ",0
.a1bc					PrintIntegerUnsigned:
.a1bc	20 e8 a4	jsr $a4e8			jsr 	IntToString
.a1bf	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a1c1	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a1c3	20 c8 a1	jsr $a1c8			jsr 	PrintStringXY
.a1c6	98		tya				tya
.a1c7	60		rts				rts
.a1c8					PrintStringXY:
.a1c8	86 02		stx $02				stx 	zTemp0
.a1ca	84 03		sty $03				sty 	zTemp0+1
.a1cc	a0 00		ldy #$00			ldy 	#0
.a1ce	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a1d0	f0 06		beq $a1d8			beq 	_PSExit
.a1d2	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a1d5	c8		iny				iny
.a1d6	80 f6		bra $a1ce			bra 	_PSLoop
.a1d8	60		rts		_PSExit:rts
.a1d9					PrintCharacter:
.a1d9	48		pha				pha
.a1da	da		phx				phx
.a1db	5a		phy				phy
.a1dc	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1df	7a		ply				ply
.a1e0	fa		plx				plx
.a1e1	68		pla				pla
.a1e2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a1e3					ExecuteProgram:
.a1e3	20 10 a4	jsr $a410			jsr 	StackReset 					; reset the CPU stack.
.a1e6	20 d8 a3	jsr $a3d8			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a1e9	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a1eb	80 0a		bra $a1f7			bra 	ExecuteLoop
.a1ed					ShortConstant:
.a1ed	c8		iny				iny 								; skip short const
.a1ee	e8		inx				inx 								; space on stack
.a1ef	29 3f		and #$3f			and 	#$3F 						; the value
.a1f1	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a1f4	9e 80 06	stz $0680,x			stz 	highStack,x
.a1f7					ExecuteLoop:
.a1f7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a1f9	30 07		bmi $a202			bmi 	_ELNotToken
.a1fb	c8		iny				iny 								; skip the token
.a1fc	da		phx				phx 								; save X on the stack
.a1fd	0a		asl a				asl 	a 							; double the token, put into X
.a1fe	aa		tax				tax
.a1ff	7c 02 a1	jmp ($a102,x)			jmp 	(DispatchHandler,x)
.a202					_ELNotToken:
.a202	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a204	90 e7		bcc $a1ed			bcc 	ShortConstant 				; yes, it's a short constant
.a206	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a208	90 1e		bcc $a228			bcc 	_ELNotFastVariable
.a20a	c8		iny				iny 								; get the next token.
.a20b	b1 00		lda ($00),y			lda 	(codePtr),y
.a20d	88		dey				dey
.a20e	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a210	f0 16		beq $a228			beq 	_ELNotFastVariable 			; which we can optimise.
.a212	5a		phy				phy 								; save Y
.a213	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a215	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a216	a8		tay				tay 								; access via Y
.a217	e8		inx				inx 								; make space on the stack.
.a218	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a21b	9d 00 06	sta $0600,x			sta 	lowStack,x
.a21e	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a221	9d 80 06	sta $0680,x			sta 	highStack,x
.a224	7a		ply				ply 								; restore code pointer
.a225	c8		iny				iny 								; skip variable.
.a226	80 cf		bra $a1f7			bra 	ExecuteLoop
.a228					_ELNotFastVariable:
.a228	18		clc				clc									; do not autocreate if not found.
.a229	20 33 a5	jsr $a533			jsr 	VariableFind				; find the variable.
.a22c	90 14		bcc $a242			bcc 	_ELUnknown
.a22e	20 7e a3	jsr $a37e			jsr 	IndexCheck
.a231	5a		phy				phy 								; copy to stack
.a232	e8		inx				inx
.a233	b2 02		lda ($02)			lda 	(zTemp0)
.a235	9d 00 06	sta $0600,x			sta 	lowStack,x
.a238	a0 01		ldy #$01			ldy 	#1
.a23a	b1 02		lda ($02),y			lda 	(zTemp0),y
.a23c	9d 80 06	sta $0680,x			sta 	highStack,x
.a23f	7a		ply				ply
.a240	80 b5		bra $a1f7			bra 	ExecuteLoop
.a242					_ELUnknown:
>a242	ff						.byte 	$FF
.a243	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a246	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a24e	00
.a24f					ExecuteNextLine:
.a24f					ExecuteComment:
.a24f	fa		plx				plx
.a250	18		clc				clc 								; skip forward
.a251	b2 00		lda ($00)			lda 	(codePtr)
.a253	18		clc				clc
.a254	65 00		adc $00				adc 	codePtr
.a256	85 00		sta $00				sta 	codePtr
.a258	90 02		bcc $a25c			bcc 	_ENLNoCarry
.a25a	e6 01		inc $01				inc 	codePtr+1
.a25c					_ENLNoCarry:
.a25c	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a25e	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a260	d0 95		bne $a1f7			bne 	ExecuteLoop
.a262	4c 59 a9	jmp $a959			jmp	 	Command_End 				; if zero end program.
.a265					LongConstant:
.a265	fa		plx				plx
.a266	e8		inx				inx 								; space for constant
.a267	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a269	9d 00 06	sta $0600,x			sta 	lowStack,x
.a26c	c8		iny				iny
.a26d	b1 00		lda ($00),y			lda 	(codePtr),y
.a26f	9d 80 06	sta $0680,x			sta 	highStack,x
.a272	c8		iny				iny
.a273	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a276					StringConstant:
.a276	fa		plx				plx
.a277	e8		inx				inx
.a278	18		clc				clc 								; copy Y + codePtr in.
.a279	98		tya				tya
.a27a	65 00		adc $00				adc 	codePtr
.a27c	9d 00 06	sta $0600,x			sta 	lowStack,x
.a27f	a5 01		lda $01				lda 	codePtr+1
.a281	69 00		adc #$00			adc 	#0
.a283	9d 80 06	sta $0680,x			sta 	highStack,x
.a286	98		tya				tya 								; add 1 + length to Y
.a287	38		sec				sec
.a288	71 00		adc ($00),y			adc 	(codePtr),y
.a28a	a8		tay				tay
.a28b	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a28e					ExternInitialise:
.a28e	a9 07		lda #$07			lda 	#$07 						; set colour
.a290	8d 86 02	sta $0286			sta 	646
.a293	a9 93		lda #$93			lda 	#147 						; clear screen
.a295	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a298	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a29a	4c bb a2	jmp $a2bb			jmp 	ExternColour
.a29d					ExternCheckBreak:
.a29d	da		phx				phx 								; make sure we keep XY
.a29e	5a		phy				phy
.a29f	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a2a2	f0 03		beq $a2a7			beq		_ECBExit 					; stopped
.a2a4	7a		ply				ply 								; restore and exit.
.a2a5	fa		plx				plx
.a2a6	60		rts				rts
.a2a7					_ECBExit:
.a2a7	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a2aa	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a2b1					ExternPrint:
.a2b1	48		pha				pha
.a2b2	da		phx				phx
.a2b3	5a		phy				phy
.a2b4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2b7	7a		ply				ply
.a2b8	fa		plx				plx
.a2b9	68		pla				pla
.a2ba	60		rts				rts
.a2bb					ExternColour:
.a2bb	48		pha				pha
.a2bc	da		phx				phx
.a2bd	48		pha				pha
.a2be	29 08		and #$08			and 	#8
.a2c0	0a		asl a				asl 	a
.a2c1	0a		asl a				asl 	a
.a2c2	0a		asl a				asl 	a
.a2c3	0a		asl a				asl 	a
.a2c4	49 92		eor #$92			eor 	#$92
.a2c6	20 b1 a2	jsr $a2b1			jsr 	ExternPrint
.a2c9	a9 0e		lda #$0e			lda 	#14							; lower case
.a2cb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2ce	68		pla				pla
.a2cf	29 07		and #$07			and 	#7
.a2d1	aa		tax				tax
.a2d2	bd db a2	lda $a2db,x			lda 	_ECTable,x
.a2d5	20 b1 a2	jsr $a2b1			jsr 	ExternPrint
.a2d8	fa		plx				plx
.a2d9	68		pla				pla
.a2da	60		rts				rts
.a2db					_ECTable:
>a2db	90						.byte 	144
>a2dc	1c						.byte 	28
>a2dd	1e						.byte 	30
>a2de	9e						.byte 	158
>a2df	1f						.byte 	31
>a2e0	9c						.byte 	156
>a2e1	9f						.byte 	159
>a2e2	05						.byte 	5
.a2e3					ExternInput:
.a2e3	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a2e5	85 02		sta $02				sta 	zTemp0
.a2e7	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a2e9	85 03		sta $03				sta 	zTemp0+1
.a2eb	a9 07		lda #$07			lda 	#COL_WHITE
.a2ed	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a2f0	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a2f3	29 7f		and #$7f			and 	#$7F
.a2f5	c9 0d		cmp #$0d			cmp 	#13
.a2f7	f0 0a		beq $a303			beq 	_EIExit
.a2f9	92 02		sta ($02)			sta 	(zTemp0)
.a2fb	e6 02		inc $02				inc 	zTemp0
.a2fd	d0 f1		bne $a2f0			bne 	_EIRead
.a2ff	e6 03		inc $03				inc 	zTemp0+1
.a301	80 ed		bra $a2f0			bra 	_EIRead
.a303	a9 00		lda #$00	_EIExit:lda 	#0
.a305	92 02		sta ($02)			sta 	(zTemp0)
.a307	a9 0d		lda #$0d			lda 	#13
.a309	20 b1 a2	jsr $a2b1			jsr 	ExternPrint
.a30c	60		rts				rts
.a30d					ExternSave:
.a30d	da		phx				phx
.a30e	5a		phy				phy
.a30f	85 06		sta $06				sta 	zTemp2 						; save start
.a311	84 07		sty $07				sty 	zTemp2+1
.a313	20 75 a3	jsr $a375			jsr 	EXGetLength 				; get length of file into A
.a316	a6 02		ldx $02				ldx 	zTemp0
.a318	a4 03		ldy $03				ldy 	zTemp0+1
.a31a	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a31d	a9 01		lda #$01			lda 	#1
.a31f	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a321	a0 00		ldy #$00			ldy 	#0
.a323	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a326	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a328	a4 05		ldy $05				ldy 	zTemp1+1
.a32a	a9 06		lda #$06			lda 	#zTemp2
.a32c	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a32f	b0 03		bcs $a334			bcs 	_ESSave
.a331	7a		ply				ply
.a332	fa		plx				plx
.a333	60		rts				rts
.a334					_ESSave:
.a334	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a337	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a33f	4c 45 44 00
.a343					ExternLoad:
.a343	da		phx				phx 								; save XY
.a344	5a		phy				phy
.a345	48		pha				pha 								; save target
.a346	5a		phy				phy
.a347	20 75 a3	jsr $a375			jsr 	EXGetLength 				; get length of file into A
.a34a	a6 02		ldx $02				ldx 	zTemp0
.a34c	a4 03		ldy $03				ldy 	zTemp0+1
.a34e	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a351	a9 01		lda #$01			lda 	#1
.a353	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a355	a0 00		ldy #$00			ldy 	#0
.a357	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a35a	7a		ply				ply 								; restore target to YX and call load
.a35b	fa		plx				plx
.a35c	a9 00		lda #$00			lda 	#0 							; load command
.a35e	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a361	b0 03		bcs $a366			bcs 	_ESLoad
.a363	7a		ply				ply
.a364	fa		plx				plx
.a365	60		rts				rts
.a366					_ESLoad:
.a366	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a369	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a371	4c 45 44 00
.a375					EXGetLength:
.a375	a0 ff		ldy #$ff			ldy 	#255
.a377	c8		iny		_EXGL:	iny
.a378	b1 02		lda ($02),y			lda 	(zTemp0),y
.a37a	d0 fb		bne $a377			bne 	_EXGL
.a37c	98		tya				tya
.a37d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a37e					IndexCheck:
.a37e	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a380	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a382	f0 01		beq $a385			beq 	_ICFound
.a384	60		rts				rts
.a385					_ICFound:
.a385	c8		iny				iny 							; get next
.a386	b1 00		lda ($00),y			lda 	(codePtr),y
.a388	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a38a	f0 2b		beq $a3b7			beq 	_ICStackIndex
.a38c	38		sec				sec
.a38d	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a38f	c9 40		cmp #$40			cmp 	#$40
.a391	b0 1a		bcs $a3ad			bcs 	_ICError
.a393	0a		asl a				asl 	a 						; double index clear carry
.a394	5a		phy				phy 							; put into Y
.a395	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a397	48		pha				pha
.a398	a0 01		ldy #$01			ldy 	#1
.a39a	b1 02		lda ($02),y			lda 	(zTemp0),y
.a39c	69 00		adc #$00			adc 	#0
.a39e	85 03		sta $03				sta 	zTemp0+1
.a3a0	68		pla				pla
.a3a1	85 02		sta $02				sta 	zTemp0
.a3a3	7a		ply				ply 							; restore position.
.a3a4	c8		iny				iny								; skip index
.a3a5	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a3a7	c8		iny				iny
.a3a8	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a3aa	d0 01		bne $a3ad			bne 	_ICError
.a3ac	60		rts				rts
.a3ad					_ICError:
.a3ad	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a3b0	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a3b7					_ICStackIndex:
.a3b7	c8		iny				iny 							; skip the ]
.a3b8	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a3bb	0a		asl a				asl 	a
.a3bc	85 04		sta $04				sta 	zTemp1
.a3be	bd 80 06	lda $0680,x			lda 	highStack,x
.a3c1	2a		rol a				rol 	a
.a3c2	85 05		sta $05				sta 	zTemp1+1
.a3c4	ca		dex				dex 							; throw TOS.
.a3c5	5a		phy				phy
.a3c6	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a3c8	b2 02		lda ($02)			lda 	(zTemp0)
.a3ca	65 04		adc $04				adc 	zTemp1
.a3cc	48		pha				pha
.a3cd	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3cf	65 05		adc $05				adc 	zTemp1+1
.a3d1	85 03		sta $03				sta 	zTemp0+1
.a3d3	68		pla				pla
.a3d4	85 02		sta $02				sta 	zTemp0
.a3d6	7a		ply				ply 							; restore pos and exit.
.a3d7	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a3d8					ResetMemory:
.a3d8	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a3da	85 0d		sta $0d				sta 	allocPtr
.a3dc	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a3de	85 0e		sta $0e				sta 	allocPtr+1
.a3e0	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a3e2	85 0f		sta $0f				sta 	memVarPtr
.a3e4	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a3e6	85 10		sta $10				sta 	memVarPtr+1
.a3e8					_RMFindEnd:
.a3e8	b2 0f		lda ($0f)			lda 	(memVarPtr)					; offset 0, found end.
.a3ea	f0 0b		beq $a3f7			beq 	_RMFoundEnd 				; advance to next.
.a3ec	18		clc				clc
.a3ed	65 0f		adc $0f				adc 	memVarPtr
.a3ef	85 0f		sta $0f				sta 	memVarPtr
.a3f1	90 f5		bcc $a3e8			bcc 	_RMFindEnd
.a3f3	e6 10		inc $10				inc 	memVarPtr+1
.a3f5	80 f1		bra $a3e8			bra 	_RMFindEnd
.a3f7					_RMFoundEnd:
.a3f7	e6 0f		inc $0f				inc 	memVarPtr 					; advance past last offset $00
.a3f9	d0 02		bne $a3fd			bne 	_RMNoCarry
.a3fb	e6 10		inc $10				inc 	memVarPtr+1
.a3fd					_RMNoCarry:
.a3fd	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a3ff					_RMEraseHash:
.a3ff	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a402	ca		dex				dex
.a403	10 fa		bpl $a3ff			bpl 	_RMEraseHash
.a405	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a407	85 00		sta $00				sta 	codePtr
.a409	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a40b	85 01		sta $01				sta 	codePtr+1
.a40d	a0 03		ldy #$03			ldy 	#3
.a40f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a410					StackReset:
.a410	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a412	85 0a		sta $0a				sta 	iStack
.a414	a9 09		lda #$09			lda 	#IntStack >> 8
.a416	85 0b		sta $0b				sta 	iStack+1
.a418	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a41a	92 0a		sta ($0a)			sta 	(iStack)
.a41c	60		rts				rts
.a41d					StackPushByte:
.a41d	c6 0a		dec $0a				dec 	iStack
.a41f	92 0a		sta ($0a)			sta 	(iStack)
.a421	f0 01		beq $a424			beq 	_SPBUnderflow
.a423	60		rts				rts
.a424					_SPBUnderflow:
.a424	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a427	53 54 41 43 4b 00				.text 	"STACK",0
.a42d					StackPushPosition:
.a42d	98		tya				tya
.a42e	20 1d a4	jsr $a41d			jsr 	StackPushByte
.a431	a5 01		lda $01				lda 	codePtr+1
.a433	20 1d a4	jsr $a41d			jsr 	StackPushByte
.a436	a5 00		lda $00				lda 	codePtr
.a438	20 1d a4	jsr $a41d			jsr 	StackPushByte
.a43b	60		rts				rts
.a43c					StackCheckTop:
.a43c	d2 0a		cmp ($0a)			cmp 	(iStack)
.a43e	f0 02		beq $a442			beq 	_SCTOk
.a440	18		clc				clc
.a441	60		rts				rts
.a442	38		sec		_SCTOk:	sec
.a443	60		rts				rts
.a444					StackPop:
.a444	18		clc				clc
.a445	65 0a		adc $0a				adc 	iStack
.a447	85 0a		sta $0a				sta 	iStack
.a449	60		rts				rts
.a44a					StackRestorePosition:
.a44a	b1 0a		lda ($0a),y			lda 	(iStack),y
.a44c	85 00		sta $00				sta 	codePtr
.a44e	c8		iny				iny
.a44f	b1 0a		lda ($0a),y			lda 	(iStack),y
.a451	85 01		sta $01				sta 	codePtr+1
.a453	c8		iny				iny
.a454	b1 0a		lda ($0a),y			lda 	(iStack),y
.a456	a8		tay				tay
.a457	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a458					StringToInt:
.a458	86 08		stx $08				stx 	zTemp3 						; save string
.a45a	84 09		sty $09				sty 	zTemp3+1
.a45c	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a45e	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a460	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a462	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a464	f0 1b		beq $a481			beq 	_STIConvert 				; convert from character 1, base 16.
.a466	88		dey				dey 								; from character 0
.a467	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a469	c9 2d		cmp #$2d			cmp 	#"-"						; first char is unary minus ?
.a46b	d0 14		bne $a481			bne 	_STIConvert 				; no, convert as +ve decimal
.a46d	c8		iny				iny 								; skip the minus
.a46e	20 81 a4	jsr $a481			jsr 	_STIConvert 				; convert the unsigned part.
.a471	90 0d		bcc $a480			bcc 	_STIExit 					; failed
.a473	8a		txa				txa 								; 1's complement YX
.a474	49 ff		eor #$ff			eor 	#$FF
.a476	aa		tax				tax
.a477	98		tya				tya
.a478	49 ff		eor #$ff			eor 	#$FF
.a47a	a8		tay				tay
.a47b	e8		inx				inx 								; +1 to make it negative
.a47c	38		sec				sec
.a47d	d0 01		bne $a480			bne 	_STIExit
.a47f	c8		iny				iny
.a480					_STIExit:
.a480	60		rts				rts
.a481					_STIConvert:
.a481	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a483	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a485	f0 5f		beq $a4e6			beq 	_STIFail 					; if zero, then it has failed anyway.
.a487	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a489	64 03		stz $03				stz 	zTemp0+1
.a48b					_STILoop:
.a48b	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a48d	85 06		sta $06				sta 	zTemp2
.a48f	a5 03		lda $03				lda 	zTemp0+1
.a491	85 07		sta $07				sta 	zTemp2+1
.a493	64 02		stz $02				stz 	zTemp0 						; clear result
.a495	64 03		stz $03				stz 	zTemp0+1
.a497	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a499					_STIMultiply:
.a499	8a		txa				txa 								; shift Y right into carry.
.a49a	4a		lsr a				lsr 	a
.a49b	aa		tax				tax
.a49c	90 0d		bcc $a4ab			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a49e	18		clc				clc
.a49f	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a4a1	65 02		adc $02				adc 	zTemp0
.a4a3	85 02		sta $02				sta 	zTemp0
.a4a5	a5 07		lda $07				lda 	zTemp2+1
.a4a7	65 03		adc $03				adc 	zTemp0+1
.a4a9	85 03		sta $03				sta 	zTemp0+1
.a4ab					_STINoAdd:
.a4ab	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a4ad	26 07		rol $07				rol 	zTemp2+1
.a4af	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a4b1	d0 e6		bne $a499			bne 	_STIMultiply
.a4b3	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a4b5	29 7f		and #$7f			and 	#$7F 						; remove End of Token bit if set
.a4b7	c9 30		cmp #$30			cmp 	#"0"
.a4b9	90 2b		bcc $a4e6			bcc 	_STIFail
.a4bb	c9 3a		cmp #$3a			cmp 	#"9"+1
.a4bd	90 0b		bcc $a4ca			bcc 	_STIOkay
.a4bf	c9 41		cmp #$41			cmp 	#"A"
.a4c1	90 23		bcc $a4e6			bcc 	_STIFail
.a4c3	c9 47		cmp #$47			cmp 	#"F"+1
.a4c5	b0 1f		bcs $a4e6			bcs 	_STIFail
.a4c7	38		sec				sec 								; hex adjust
.a4c8	e9 07		sbc #$07			sbc 	#7
.a4ca					_STIOkay:
.a4ca	38		sec				sec
.a4cb	e9 30		sbc #$30			sbc 	#48
.a4cd	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a4cf	b0 15		bcs $a4e6			bcs 	_STIFail
.a4d1	d8		cld				cld
.a4d2	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a4d4	85 02		sta $02				sta 	zTemp0
.a4d6	90 02		bcc $a4da			bcc 	_STINoCarry
.a4d8	e6 03		inc $03				inc 	zTemp0+1
.a4da					_STINoCarry:
.a4da	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a4dc	c8		iny				iny 								; point to next
.a4dd	0a		asl a				asl 	a 							; shift bit 7 into carry
.a4de	90 ab		bcc $a48b			bcc 	_STILoop 					; not reached the end.
.a4e0	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a4e2	a4 03		ldy $03				ldy 	zTemp0+1
.a4e4	38		sec				sec
.a4e5	60		rts				rts
.a4e6					_STIFail:
.a4e6	18		clc				clc
.a4e7	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a4e8					IntToString:
.a4e8	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a4ea	84 03		sty $03				sty 	zTemp0+1
.a4ec	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a4ee	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a4f0					_ITSLoop:
.a4f0	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a4f2					_ITSSubtractLoop:
.a4f2	38		sec				sec
.a4f3	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a4f5	fd 2b a5	sbc $a52b,x			sbc 	_ITSWords,x
.a4f8	48		pha				pha
.a4f9	a5 03		lda $03				lda 	zTemp0+1
.a4fb	fd 2c a5	sbc $a52c,x			sbc 	_ITSWords+1,x
.a4fe	90 09		bcc $a509			bcc 	_ITSEndSub 					; can't subtract any more.
.a500	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a502	68		pla				pla
.a503	85 02		sta $02				sta 	zTemp0
.a505	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a507	80 e9		bra $a4f2			bra 	_ITSSubtractLoop
.a509					_ITSEndSub:
.a509	68		pla				pla 								; throw away the interim result
.a50a	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a50c	d0 04		bne $a512			bne 	_ITSWriteOut 				; always write it out
.a50e	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a510	f0 06		beq $a518			beq 	_ITSNext 					; suppressing leading zeros.
.a512					_ITSWriteOut:
.a512	09 30		ora #$30			ora 	#48 						; output digit.
.a514	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a517	c8		iny				iny
.a518					_ITSNext:
.a518	e8		inx				inx
.a519	e8		inx				inx
.a51a	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a51c	d0 d2		bne $a4f0			bne 	_ITSLoop 					; do the new digits
.a51e	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a520	09 30		ora #$30			ora 	#48
.a522	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a525	a9 00		lda #$00			lda 	#0
.a527	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a52a	60		rts				rts
.a52b					_ITSWords:
>a52b	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a533					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a533					VariableFind:
.a533	da		phx				phx 								; save the stack position
.a534	08		php				php 								; save the create flag
.a535	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a537	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a539	90 10		bcc $a54b			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a53b	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a53d	0a		asl a				asl 	a 							; double clear carry
.a53e	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a540	85 02		sta $02				sta 	zTemp0
.a542	a9 0f		lda #$0f			lda		#FastVariables >>8
.a544	85 03		sta $03				sta 	zTemp0+1
.a546	28		plp				plp 								; create flag is irrelevant.
.a547	fa		plx				plx									; restore the old stack position
.a548	c8		iny				iny 								; skip over the single identifier character
.a549	38		sec				sec 								; return with CS
.a54a	60		rts				rts
.a54b					_VFIsNotFastVariable:
.a54b	20 0e a6	jsr $a60e			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a54e	20 78 a5	jsr $a578			jsr 	VFSearch 					; try to find the variable.
.a551	b0 0d		bcs $a560			bcs 	_VFEndSearch 				; found it, so exit
.a553	28		plp				plp 								; do we want autocreate
.a554	b0 03		bcs $a559			bcs 	_VFCreate
.a556	fa		plx				plx 								; restore stack position and return CC
.a557	18		clc				clc
.a558	60		rts				rts
.a559					_VFCreate:
.a559	20 0e a6	jsr $a60e			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a55c	20 b4 a5	jsr $a5b4			jsr 	VFCreate 					; create a new record and link it in.
.a55f	08		php				php 								; save a dummy P to be popped.
.a560					_VFEndSearch:
.a560	18		clc				clc 								; the data is at offset + 4
.a561	a5 04		lda $04				lda 	zTemp1
.a563	69 04		adc #$04			adc 	#4
.a565	85 02		sta $02				sta 	zTemp0
.a567	a5 05		lda $05				lda 	zTemp1+1
.a569	69 00		adc #$00			adc 	#0
.a56b	85 03		sta $03				sta 	zTemp0+1
.a56d	28		plp				plp 								; dump the create flag
.a56e					_VFSkipExit:
.a56e	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a570	c8		iny				iny
.a571	c9 e0		cmp #$e0			cmp 	#$E0
.a573	90 f9		bcc $a56e			bcc 	_VFSkipExit
.a575	fa		plx				plx 								; restore X
.a576	38		sec				sec
.a577	60		rts				rts
.a578					VFSearch:
.a578	48		pha				pha 								; save AXY.
.a579	da		phx				phx
.a57a	5a		phy				phy
.a57b	98		tya				tya									; add Y to codePtr, put in zTemp2
.a57c	18		clc				clc 								; so it points to the identifier.
.a57d	65 00		adc $00				adc 	codePtr
.a57f	85 06		sta $06				sta 	zTemp2
.a581	a5 01		lda $01				lda 	codePtr+1
.a583	69 00		adc #$00			adc 	#0
.a585	85 07		sta $07				sta 	zTemp2+1
.a587					_VFSLoop:
.a587	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a589	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a58b	f0 22		beq $a5af			beq 	_VFSFailed 					; failed.
.a58d	aa		tax				tax 								; MSB in X
.a58e	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a590	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a592	86 05		stx $05				stx 	zTemp1+1
.a594	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a596	b1 04		lda ($04),y			lda 	(zTemp1),y
.a598	85 08		sta $08				sta 	zTemp3
.a59a	c8		iny				iny
.a59b	b1 04		lda ($04),y			lda 	(zTemp1),y
.a59d	85 09		sta $09				sta 	zTemp3+1
.a59f	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a5a1					_VFSCheckName:
.a5a1	c8		iny				iny
.a5a2	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a5a4	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a5a6	d0 df		bne $a587			bne 	_VFSLoop
.a5a8	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a5aa	90 f5		bcc $a5a1			bcc 	_VFSCheckName
.a5ac	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a5ad	80 01		bra $a5b0			bra		_VFSExit
.a5af					_VFSFailed:
.a5af	18		clc				clc
.a5b0					_VFSExit:
.a5b0	7a		ply				ply 								; restore registers and exit.
.a5b1	fa		plx				plx
.a5b2	68		pla				pla
.a5b3	60		rts				rts
.a5b4					VFCreate:
.a5b4	48		pha				pha 								; save registers
.a5b5	da		phx				phx
.a5b6	5a		phy				phy
.a5b7	18		clc				clc 								; add 6 to memVarPtr, saving its
.a5b8	a5 0f		lda $0f				lda 	memVarPtr 					; address in zTemp0 as we go.
.a5ba	85 02		sta $02				sta 	zTemp0
.a5bc	69 06		adc #$06			adc 	#6
.a5be	85 0f		sta $0f				sta 	memVarPtr
.a5c0	a5 10		lda $10				lda 	memVarPtr+1
.a5c2	85 03		sta $03				sta 	zTemp0+1
.a5c4	69 00		adc #$00			adc 	#0
.a5c6	85 10		sta $10				sta 	memVarPtr+1
.a5c8	c5 0e		cmp $0e				cmp 	allocPtr+1 					; out of memory ?
.a5ca	f0 37		beq $a603			beq 	_VFCMemory
.a5cc	98		tya				tya 								; work out identifier address
.a5cd	18		clc				clc
.a5ce	65 00		adc $00				adc 	codePtr
.a5d0	48		pha				pha
.a5d1	c8		iny				iny
.a5d2	a5 01		lda $01				lda 	codePtr+1
.a5d4	69 00		adc #$00			adc 	#0
.a5d6	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a5d8	91 02		sta ($02),y			sta 	(zTemp0),y
.a5da	88		dey				dey
.a5db	68		pla				pla
.a5dc	91 02		sta ($02),y			sta 	(zTemp0),y
.a5de	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a5e0	a9 00		lda #$00			lda 	#0
.a5e2	91 02		sta ($02),y			sta 	(zTemp0),y
.a5e4	c8		iny				iny
.a5e5	91 02		sta ($02),y			sta 	(zTemp0),y
.a5e7	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a5e9	b2 04		lda ($04)			lda 	(zTemp1)
.a5eb	92 02		sta ($02)			sta 	(zTemp0)
.a5ed	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5ef	91 02		sta ($02),y			sta 	(zTemp0),y
.a5f1	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a5f3	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a5f5	a5 03		lda $03				lda 	zTemp0+1
.a5f7	91 04		sta ($04),y			sta 	(zTemp1),y
.a5f9	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a5fb	a5 02		lda $02				lda 	zTemp0
.a5fd	85 04		sta $04				sta 	zTemp1
.a5ff	7a		ply				ply
.a600	fa		plx				plx
.a601	68		pla				pla
.a602	60		rts				rts
.a603					_VFCMemory:
.a603	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a606	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a60e					VFSetupHashPointer:
.a60e	48		pha				pha
.a60f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a611	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a613	0a		asl a				asl 	a 							; double it, also clears carry
.a614	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a616	85 04		sta $04				sta 	zTemp1
.a618	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a61a	85 05		sta $05				sta 	zTemp1+1
.a61c	68		pla				pla
.a61d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a61e					Cmd_List:
.a61e	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a620	64 07		stz $07				stz 	zTemp2+1
.a622					_CLNoStartLine:
.a622	a9 00		lda #$00			lda 	#(programStart) & $FF
.a624	85 00		sta $00				sta 	codePtr
.a626	a9 10		lda #$10			lda 	#(programStart) >> 8
.a628	85 01		sta $01				sta 	codePtr+1
.a62a					_CLILoop:
.a62a	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a62c	f0 24		beq $a652			beq 	_CLIEnd
.a62e	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a630	38		sec				sec
.a631	b1 00		lda ($00),y			lda 	(codePtr),y
.a633	e5 06		sbc $06				sbc 	zTemp2
.a635	c8		iny				iny
.a636	b1 00		lda ($00),y			lda 	(codePtr),y
.a638	e5 07		sbc $07				sbc 	zTemp2+1
.a63a	90 09		bcc $a645			bcc 	_CLISkip
.a63c	da		phx				phx
.a63d	20 57 a6	jsr $a657			jsr 	ListCurrent 				; list the line.
.a640	fa		plx				plx
.a641	c6 08		dec $08				dec 	zTemp3 						; done all lines
.a643	f0 0d		beq $a652			beq 	_CLIEnd
.a645					_CLISkip:
.a645	18		clc				clc
.a646	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a648	65 00		adc $00				adc 	codePtr
.a64a	85 00		sta $00				sta 	codePtr
.a64c	90 dc		bcc $a62a			bcc 	_CLILoop
.a64e	e6 01		inc $01				inc 	codePtr+1
.a650	80 d8		bra $a62a			bra 	_CLILoop
.a652					_CLIEnd:
.a652	80 fe		bra $a652			bra 	_CLIEnd
.a654	4c 09 a0	jmp $a009			jmp 	WarmStart
.a657					ListCurrent:
.a657	a9 06		lda #$06			lda 	#CTH_LINENO
.a659	20 bb a2	jsr $a2bb			jsr 	ExternColour 				; set colour
.a65c	a0 01		ldy #$01			ldy 	#1							; print line#
.a65e	b1 00		lda ($00),y			lda 	(codePtr),y
.a660	aa		tax				tax
.a661	c8		iny				iny
.a662	b1 00		lda ($00),y			lda 	(codePtr),y
.a664	a8		tay				tay
.a665	20 bc a1	jsr $a1bc			jsr 	PrintIntegerUnsigned
.a668	a8		tay				tay
.a669					_LCPadOut:
.a669	a9 20		lda #$20			lda 	#' '
.a66b	20 b1 a2	jsr $a2b1			jsr 	ExternPrint
.a66e	c8		iny				iny
.a66f	c0 06		cpy #$06			cpy 	#6
.a671	d0 f6		bne $a669			bne 	_LCPadOut
.a673	a0 03		ldy #$03			ldy 	#3 							; start here
.a675	64 13		stz $13				stz 	PrefixCharacter				; no prefix
.a677	a9 06		lda #$06	_LCLoop:lda 	#CTH_LINENO 				; reset colour.
.a679	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a67c	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.a67e	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a680	f0 0b		beq $a68d			beq 	_LCNoPrefix
.a682	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.a684	f0 07		beq $a68d			beq 	_LCNoPrefix
.a686	a5 13		lda $13				lda 	PrefixCharacter 			; output prefix, reset to space
.a688	f0 03		beq $a68d			beq		_LCNoPrefix
.a68a	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a68d					_LCNoPrefix:
.a68d	a9 20		lda #$20			lda 	#32
.a68f	85 13		sta $13				sta 	PrefixCharacter
.a691	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.a693	f0 18		beq $a6ad			beq 	_LCExit
.a695	10 5c		bpl $a6f3			bpl 	_LCIsToken 					; +ve goto token.
.a697	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.a699	b0 18		bcs $a6b3			bcs 	_LCIsIdentifier
.a69b	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.a69d	aa		tax				tax
.a69e	c8		iny				iny
.a69f	5a		phy				phy 								; push pos
.a6a0	a0 00		ldy #$00			ldy 	#0
.a6a2	a9 06		lda #$06			lda 	#CTH_NUMBER
.a6a4	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a6a7	20 bc a1	jsr $a1bc			jsr 	PrintIntegerUnsigned
.a6aa	7a		ply				ply
.a6ab	80 ca		bra $a677			bra 	_LCLoop
.a6ad					_LCExit:
.a6ad	a9 0d		lda #$0d			lda 	#13
.a6af	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a6b2	60		rts				rts
.a6b3					_LCIsIdentifier:
.a6b3	a9 03		lda #$03			lda 	#CTH_IDENT
.a6b5	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a6b8					_LCIdentLoop:
.a6b8	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.a6ba	20 c7 a7	jsr $a7c7			jsr 	ListPrintIDChar
.a6bd	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.a6bf	c8		iny				iny
.a6c0	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.a6c2	b0 b3		bcs $a677			bcs 	_LCLoop 					; if so, do next
.a6c4	80 f2		bra $a6b8			bra 	_LCIdentLoop				; if not loop round
.a6c6					_LCConstant:
.a6c6	c8		iny				iny
.a6c7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.a6c9	aa		tax				tax
.a6ca	c8		iny				iny 								; get MSB into Y
.a6cb	b1 00		lda ($00),y			lda 	(codePtr),y
.a6cd	c8		iny				iny
.a6ce	5a		phy				phy
.a6cf	a8		tay				tay
.a6d0	5a		phy				phy 								; save sign
.a6d1	10 0c		bpl $a6df			bpl 	_LCNotNegative
.a6d3	98		tya				tya 								; YX = |YX|
.a6d4	49 ff		eor #$ff			eor 	#$FF
.a6d6	a8		tay				tay
.a6d7	8a		txa				txa
.a6d8	49 ff		eor #$ff			eor 	#$FF
.a6da	aa		tax				tax
.a6db	e8		inx				inx
.a6dc	d0 01		bne $a6df			bne 	_LCNotNegative
.a6de	c8		iny				iny
.a6df					_LCNotNegative:
.a6df					_LCPrintYX:
.a6df	a9 06		lda #$06			lda 	#CTH_NUMBER
.a6e1	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a6e4	20 bc a1	jsr $a1bc			jsr 	PrintIntegerUnsigned
.a6e7	68		pla				pla 								; restore sign
.a6e8	10 05		bpl $a6ef			bpl 	_LCNoTrail
.a6ea	a9 2d		lda #$2d			lda 	#"-"
.a6ec	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a6ef					_LCNoTrail:
.a6ef	7a		ply				ply 								; restore Y
.a6f0	4c 77 a6	jmp $a677			jmp 	_LCLoop
.a6f3					_LCIsToken:
.a6f3	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.a6f5	f0 cf		beq $a6c6			beq 	_LCConstant
.a6f7	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.a6f9	90 43		bcc $a73e			bcc 	_LCControl
.a6fb					_LCIsKeywordToken:
.a6fb	85 02		sta $02				sta 	zTemp0 						; save token #
.a6fd	a9 0c		lda #$0c			lda 	#(KeywordText) & $FF
.a6ff	85 04		sta $04				sta 	zTemp1
.a701	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a703	85 05		sta $05				sta 	zTemp1+1
.a705	a9 07		lda #$07			lda 	#CTH_TOKEN 					; set to token colour
.a707	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a70a	5a		phy				phy 								; save code offset
.a70b					_LCForward:
.a70b	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.a70d	f0 0f		beq $a71e			beq 	_LCFoundToken
.a70f	c6 02		dec $02				dec 	zTemp0						; dec count.
.a711	38		sec				sec 								; go to next keyword.
.a712	b2 04		lda ($04)			lda 	(zTemp1)
.a714	65 04		adc $04				adc 	zTemp1
.a716	85 04		sta $04				sta 	zTemp1
.a718	90 f1		bcc $a70b			bcc 	_LCForward
.a71a	e6 05		inc $05				inc 	zTemp1+1
.a71c	80 ed		bra $a70b			bra 	_LCForward
.a71e					_LCFoundToken:
.a71e	a0 01		ldy #$01			ldy 	#1 							; output the token.
.a720					_LCOutToken:
.a720	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.a722	29 7f		and #$7f			and 	#$7F
.a724	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a727	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.a729	c8		iny				iny
.a72a	0a		asl a				asl 	a
.a72b	90 f3		bcc $a720			bcc 	_LCOutToken
.a72d	7a		ply				ply 								; restore code offset
.a72e	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.a730	c8		iny				iny
.a731	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.a733	f0 04		beq $a739			beq 	_LCCancelPrefix
.a735	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a737	d0 02		bne $a73b			bne 	_LCGoLoop
.a739					_LCCancelPrefix:
.a739	64 13		stz $13				stz 	PrefixCharacter
.a73b					_LCGoLoop:
.a73b	4c 77 a6	jmp $a677			jmp 	_LCLoop
.a73e					_LCControl:
.a73e	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.a740	f0 52		beq $a794			beq 	_LCDecodeCall
.a742	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a744	f0 33		beq $a779			beq 	_LCDecodeDefine
.a746	5a		phy				phy 								; save Y
.a747	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.a749	a2 05		ldx #$05			ldx 	#CTH_STRING
.a74b	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.a74d	f0 04		beq $a753			beq 	_LCDecodeString
.a74f	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.a751	a2 0f		ldx #$0f			ldx 	#CTH_COMMENT
.a753					_LCDecodeString
.a753	8a		txa				txa 								; set colour
.a754	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a757	98		tya				tya
.a758	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a75b	7a		ply				ply 								; restore Y pos
.a75c	48		pha				pha 								; save end character on stack.
.a75d	c8		iny				iny 								; get count into X
.a75e	b1 00		lda ($00),y			lda 	(codePtr),y
.a760	aa		tax				tax
.a761					_LCOutString:
.a761	c8		iny				iny
.a762	e0 00		cpx #$00			cpx		#0 							; reached the end
.a764	f0 08		beq $a76e			beq 	_LCEndDecode
.a766	b1 00		lda ($00),y			lda 	(codePtr),y
.a768	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a76b	ca		dex				dex
.a76c	80 f3		bra $a761			bra 	_LCOutString
.a76e					_LCEndDecode:
.a76e	68		pla				pla
.a76f	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.a771	f0 03		beq $a776			beq 	_LCEDNoQuote
.a773	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a776					_LCEDNoQuote:
.a776	4c 77 a6	jmp $a677			jmp 	_LCLoop
.a779					_LCDecodeDefine:
.a779	a9 0e		lda #$0e			lda 	#CTH_DEFINITION
.a77b	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a77e	a9 3a		lda #$3a			lda 	#":"
.a780	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a783					_LCCPrintDef:
.a783	c8		iny				iny
.a784	b1 00		lda ($00),y			lda 	(codePtr),y
.a786	aa		tax				tax
.a787					_LCCOutDefine:
.a787	c8		iny				iny
.a788	e0 00		cpx #$00			cpx 	#0
.a78a	f0 ea		beq $a776			beq 	_LCEDNoQuote
.a78c	b1 00		lda ($00),y			lda 	(codePtr),y
.a78e	20 c7 a7	jsr $a7c7			jsr 	ListPrintIDChar
.a791	ca		dex				dex
.a792	80 f3		bra $a787			bra 	_LCCOutDefine
.a794					_LCDecodeCall:
.a794	c8		iny				iny 								; get line number into XA
.a795	b1 00		lda ($00),y			lda 	(codePtr),y
.a797	48		pha				pha
.a798	c8		iny				iny
.a799	b1 00		lda ($00),y			lda 	(codePtr),y
.a79b	c8		iny				iny
.a79c	aa		tax				tax
.a79d	68		pla				pla
.a79e	20 d5 a7	jsr $a7d5			jsr 	ListFindLine 				; find that line.
.a7a1	90 23		bcc $a7c6			bcc 	_LCNoDefinition
.a7a3	5a		phy				phy
.a7a4	a0 03		ldy #$03			ldy 	#3 							; look at first character
.a7a6	b1 02		lda ($02),y			lda 	(zTemp0),y
.a7a8	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a7aa	d0 1a		bne $a7c6			bne 	_LCNoDefinition 			; not define
.a7ac	a9 02		lda #$02			lda 	#CTH_CALLWORD
.a7ae	20 bb a2	jsr $a2bb			jsr 	ExternColour
.a7b1	c8		iny				iny
.a7b2	b1 02		lda ($02),y			lda 	(zTemp0),y
.a7b4	aa		tax				tax
.a7b5					_LCCOutCall:
.a7b5	c8		iny				iny
.a7b6	e0 00		cpx #$00			cpx 	#0
.a7b8	f0 08		beq $a7c2			beq 	_LCEDEndCall
.a7ba	b1 02		lda ($02),y			lda 	(zTemp0),y
.a7bc	20 c7 a7	jsr $a7c7			jsr 	ListPrintIDChar
.a7bf	ca		dex				dex
.a7c0	80 f3		bra $a7b5			bra 	_LCCOutCall
.a7c2					_LCEDEndCall:
.a7c2	7a		ply				ply
.a7c3	4c 77 a6	jmp $a677			jmp 	_LCLoop
.a7c6					_LCNoDefinition:
>a7c6	ff						.byte 	$FF 						; definition is missing.
.a7c7					ListPrintIDChar:
.a7c7	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.a7c9	09 40		ora #$40			ora 	#$40 						; ASCII except .
.a7cb	c9 5b		cmp #$5b			cmp 	#$40+27
.a7cd	d0 02		bne $a7d1			bne 	_LCNotDot
.a7cf	a9 2e		lda #$2e			lda 	#"."
.a7d1					_LCNotDot:
.a7d1	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a7d4	60		rts				rts
.a7d5					ListFindLine:
.a7d5	5a		phy				phy
.a7d6	86 05		stx $05				stx 	zTemp1+1
.a7d8	85 04		sta $04				sta 	zTemp1
.a7da	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a7dc	85 02		sta $02				sta 	zTemp0
.a7de	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a7e0	85 03		sta $03				sta 	zTemp0+1
.a7e2					_LFLSearch:
.a7e2	18		clc				clc									; reached the end.
.a7e3	b2 02		lda ($02)			lda 	(zTemp0)
.a7e5	f0 1d		beq $a804			beq 	_LFLExit 					; exit with CC
.a7e7	a0 01		ldy #$01			ldy 	#1
.a7e9	a5 04		lda $04				lda 	zTemp1
.a7eb	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a7ed	d0 07		bne $a7f6			bne 	_LFLNext
.a7ef	c8		iny				iny
.a7f0	a5 05		lda $05				lda 	zTemp1+1
.a7f2	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a7f4	f0 0d		beq $a803			beq 	_LFLFound
.a7f6					_LFLNext:
.a7f6	18		clc				clc
.a7f7	b2 02		lda ($02)			lda 	(zTemp0)
.a7f9	65 02		adc $02				adc 	zTemp0
.a7fb	85 02		sta $02				sta 	zTemp0
.a7fd	90 e3		bcc $a7e2			bcc 	_LFLSearch
.a7ff	e6 03		inc $03				inc 	zTemp0+1
.a801	80 df		bra $a7e2			bra 	_LFLSearch
.a803					_LFLFound:
.a803	38		sec				sec
.a804					_LFLExit:
.a804	7a		ply				ply
.a805	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.a806					Mem_Peek:
.a806	fa		plx				plx
.a807	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a80a	85 02		sta $02				sta 	zTemp0
.a80c	bd 80 06	lda $0680,x			lda 	highStack,x
.a80f	85 03		sta $03				sta 	zTemp0+1
.a811	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a813	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a816	9e 80 06	stz $0680,x			stz 	highStack,x
.a819	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a81c					Mem_WPeek:
.a81c	fa		plx				plx
.a81d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a820	85 02		sta $02				sta 	zTemp0
.a822	bd 80 06	lda $0680,x			lda 	highStack,x
.a825	85 03		sta $03				sta 	zTemp0+1
.a827	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a829	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a82c	5a		phy				phy 								; read msb
.a82d	a0 01		ldy #$01			ldy 	#1
.a82f	b1 02		lda ($02),y			lda 	(zTemp0),y
.a831	7a		ply				ply
.a832	9d 80 06	sta $0680,x			sta 	highStack,x 				; write to stack
.a835	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a838					Mem_Poke:
.a838	fa		plx				plx
.a839	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a83c	85 02		sta $02				sta 	zTemp0
.a83e	bd 80 06	lda $0680,x			lda 	highStack,x
.a841	85 03		sta $03				sta 	zTemp0+1
.a843	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a846	92 02		sta ($02)			sta 	(zTemp0)
.a848	ca		dex				dex
.a849	ca		dex				dex
.a84a	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a84d					Mem_WPoke:
.a84d	fa		plx				plx
.a84e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a851	85 02		sta $02				sta 	zTemp0
.a853	bd 80 06	lda $0680,x			lda 	highStack,x
.a856	85 03		sta $03				sta 	zTemp0+1
.a858	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a85b	92 02		sta ($02)			sta 	(zTemp0)
.a85d	5a		phy				phy
.a85e	a0 01		ldy #$01			ldy 	#1
.a860	bd 7f 06	lda $067f,x			lda 	highStack-1,x 				; byte to write
.a863	91 02		sta ($02),y			sta 	(zTemp0),y
.a865	7a		ply				ply
.a866	ca		dex				dex
.a867	ca		dex				dex
.a868	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a86b					Mem_DWPoke:
.a86b	fa		plx				plx
.a86c	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a86f	85 02		sta $02				sta 	zTemp0
.a871	bd 80 06	lda $0680,x			lda 	highStack,x
.a874	85 03		sta $03				sta 	zTemp0+1
.a876	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a879	92 02		sta ($02)			sta 	(zTemp0)
.a87b	bd 7f 06	lda $067f,x			lda 	highStack-1,x 				; byte to write
.a87e	92 02		sta ($02)			sta 	(zTemp0)
.a880	ca		dex				dex
.a881	ca		dex				dex
.a882	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a885					Mem_Alloc:
.a885	fa		plx				plx
.a886	38		sec				sec 								; subtract count from alloc ptr
.a887	a5 0d		lda $0d				lda 	allocPtr
.a889	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.a88c	85 0d		sta $0d				sta 	allocPtr
.a88e	48		pha				pha 								; save low.
.a88f	a5 0e		lda $0e				lda 	allocPtr+1
.a891	fd 80 06	sbc $0680,x			sbc 	highStack,x
.a894	85 0e		sta $0e				sta 	allocPtr+1
.a896	90 10		bcc $a8a8			bcc 	_MAError 					; borrow ?
.a898	c5 10		cmp $10				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.a89a	90 0c		bcc $a8a8			bcc 	_MAError
.a89c	f0 0a		beq $a8a8			beq 	_MAError
.a89e	9d 80 06	sta $0680,x			sta 	highStack,x 				; update address
.a8a1	68		pla				pla
.a8a2	9d 00 06	sta $0600,x			sta 	lowStack,x
.a8a5	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8a8					_MAError:
.a8a8	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a8ab	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.a8b3					Stack_Empty:
.a8b3	fa		plx				plx
.a8b4	a2 00		ldx #$00			ldx 	#0
.a8b6	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8b9					Stack_Drop:
.a8b9	fa		plx				plx
.a8ba	ca		dex				dex
.a8bb	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8be					Stack_Dup:
.a8be	fa		plx				plx
.a8bf	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.a8c2	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.a8c5	bd 80 06	lda $0680,x			lda 	highStack,x
.a8c8	9d 81 06	sta $0681,x			sta 	highStack+1,x
.a8cb	e8		inx				inx 								; bump stack pointer
.a8cc	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8cf					Stack_Nip:
.a8cf	fa		plx				plx
.a8d0	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.a8d3	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.a8d6	bd 80 06	lda $0680,x			lda 	highStack,x
.a8d9	9d 7f 06	sta $067f,x			sta 	highStack-1,x
.a8dc	ca		dex				dex 								; drop tos
.a8dd	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8e0					Stack_Over:
.a8e0	fa		plx				plx
.a8e1	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.a8e4	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.a8e7	bd 7f 06	lda $067f,x			lda 	highStack-1,x
.a8ea	9d 81 06	sta $0681,x			sta 	highStack+1,x
.a8ed	e8		inx				inx 							; bump stack pointer
.a8ee	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a8f1					Stack_Swap:
.a8f1	fa		plx				plx
.a8f2	5a		phy				phy
.a8f3	bd 00 06	lda $0600,x			lda 	lowStack,x
.a8f6	a8		tay				tay
.a8f7	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.a8fa	9d 00 06	sta $0600,x			sta 	lowStack,x
.a8fd	98		tya				tya
.a8fe	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.a901	bd 80 06	lda $0680,x			lda 	highStack,x
.a904	a8		tay				tay
.a905	bd 7f 06	lda $067f,x			lda 	highStack-1,x
.a908	9d 80 06	sta $0680,x			sta 	highStack,x
.a90b	98		tya				tya
.a90c	9d 7f 06	sta $067f,x			sta 	highStack-1,x
.a90f	7a		ply				ply
.a910	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.a913					Command_Store:
.a913	fa		plx				plx
.a914	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.a916	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.a918	90 1f		bcc $a939			bcc 	_CSLongVariable
.a91a	c8		iny				iny 								; get the next
.a91b	b1 00		lda ($00),y			lda 	(codePtr),y
.a91d	88		dey				dey
.a91e	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.a920	f0 17		beq $a939			beq 	_CSLongVariable
.a922	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.a924	c8		iny				iny 								; skip over it and push on stack
.a925	5a		phy				phy
.a926	0a		asl a				asl 	a 							; double it, now C0-FE
.a927	a8		tay				tay 								; put in Y
.a928	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.a92b	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.a92e	bd 80 06	lda $0680,x			lda 	highStack,x
.a931	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.a934	ca		dex				dex 								; pop off stack
.a935	7a		ply				ply 								; restore position and do next
.a936	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a939					_CSLongVariable:
.a939	38		sec				sec 								; create variable if not found.
.a93a	20 33 a5	jsr $a533			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.a93d	20 7e a3	jsr $a37e			jsr 	IndexCheck 					; check indexing.
.a940	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.a943	92 02		sta ($02)			sta 	(zTemp0)
.a945	5a		phy				phy
.a946	a0 01		ldy #$01			ldy 	#1
.a948	bd 80 06	lda $0680,x			lda 	highStack,x
.a94b	91 02		sta ($02),y			sta 	(zTemp0),y
.a94d	7a		ply				ply
.a94e	ca		dex				dex 								; pop off stack
.a94f	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.a952					Command_New:
.a952	fa		plx				plx
.a953	9c 00 10	stz $1000			stz 	ProgramStart
.a956	4c 09 a0	jmp $a009			jmp 	WarmStart
.a959					Command_End:
.a959	fa		plx				plx
.a95a	4c 09 a0	jmp $a009			jmp 	WarmStart
.a95d					Command_Stop:
>a95d	ff						.byte 	$FF
.a95e	fa		plx				plx
.a95f	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a962	53 54 4f 50 00					.text 	"STOP",0
.a967					Command_Assert:
.a967	fa		plx				plx
.a968	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.a96b	1d 80 06	ora $0680,x			ora 	highStack,x
.a96e	f0 04		beq $a974			beq 	_CAFail
.a970	ca		dex				dex 								; throw if not.
.a971	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a974					_CAFail:
.a974	20 92 a1	jsr $a192			jsr 	ErrorHandler
>a977	41 53 53 45 52 54 00				.text 	"ASSERT",0
.a97e					Command_Sys:
.a97e	fa		plx				plx
.a97f	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.a982	85 02		sta $02				sta 	zTemp0
.a984	bd 80 06	lda $0680,x			lda 	highStack,x
.a987	85 03		sta $03				sta 	zTemp0+1
.a989	ca		dex				dex 								; pop tos
.a98a	da		phx				phx 								; save XY
.a98b	5a		phy				phy
.a98c	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.a98f	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.a992	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.a995	20 9d a9	jsr $a99d			jsr 	_CSCallInd
.a998	7a		ply				ply 								; restore XY
.a999	fa		plx				plx
.a99a	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a99d					_CSCallInd:
.a99d	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.a9a0					Command_DumpStack:
.a9a0	fa		plx				plx
.a9a1	da		phx				phx 								; save pos and sp
.a9a2	5a		phy				phy
.a9a3	86 0c		stx $0c				stx 	SignCount
.a9a5	a2 ff		ldx #$ff			ldx 	#$FF
.a9a7					_CDSLoop:
.a9a7	e4 0c		cpx $0c				cpx 	SignCount 					; done all ?
.a9a9	f0 2a		beq $a9d5			beq 	_CDSExit
.a9ab	e8		inx				inx
.a9ac	da		phx				phx 								; save SP
.a9ad	bd 80 06	lda $0680,x			lda 	highStack,x 				; get tos
.a9b0	a8		tay				tay
.a9b1	bd 00 06	lda $0600,x			lda 	lowStack,x
.a9b4	aa		tax				tax
.a9b5	c0 00		cpy #$00			cpy 	#0
.a9b7	10 11		bpl $a9ca			bpl 	_CDSPositive
.a9b9	a9 2d		lda #$2d			lda 	#"-" 						; minus
.a9bb	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a9be	98		tya				tya 								; negate YX
.a9bf	49 ff		eor #$ff			eor 	#$FF
.a9c1	a8		tay				tay
.a9c2	8a		txa				txa
.a9c3	49 ff		eor #$ff			eor 	#$FF
.a9c5	aa		tax				tax
.a9c6	e8		inx				inx
.a9c7	d0 01		bne $a9ca			bne 	_CDSPositive
.a9c9	c8		iny				iny
.a9ca					_CDSPositive:
.a9ca	20 bc a1	jsr $a1bc			jsr 	PrintIntegerUnsigned
.a9cd	a9 20		lda #$20			lda 	#" " 						; space
.a9cf	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a9d2	fa		plx				plx
.a9d3	80 d2		bra $a9a7			bra 	_CDSLoop
.a9d5					_CDSExit:
.a9d5	a9 3c		lda #$3c			lda 	#"<"
.a9d7	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a9da	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a9dd	a9 0d		lda #$0d			lda 	#13 						; CR
.a9df	20 d9 a1	jsr $a1d9			jsr 	PrintCharacter
.a9e2	7a		ply				ply
.a9e3	fa		plx				plx
.a9e4	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.a9e7					Stack_Add:
.a9e7	fa		plx				plx
.a9e8	ca		dex				dex
.a9e9	18		clc				clc
.a9ea	bd 00 06	lda $0600,x			lda		lowStack,x
.a9ed	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.a9f0	9d 00 06	sta $0600,x			sta 	lowStack,x
.a9f3	bd 80 06	lda $0680,x			lda		highStack,x
.a9f6	7d 81 06	adc $0681,x			adc 	highStack+1,x
.a9f9	9d 80 06	sta $0680,x			sta 	highStack,x
.a9fc	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.a9ff					Stack_Sub:
.a9ff	fa		plx				plx
.aa00	ca		dex				dex
.aa01	38		sec				sec
.aa02	bd 00 06	lda $0600,x			lda		lowStack,x
.aa05	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.aa08	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa0b	bd 80 06	lda $0680,x			lda		highStack,x
.aa0e	fd 81 06	sbc $0681,x			sbc 	highStack+1,x
.aa11	9d 80 06	sta $0680,x			sta 	highStack,x
.aa14	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.aa17					Stack_And:
.aa17	fa		plx				plx
.aa18	ca		dex				dex
.aa19	bd 00 06	lda $0600,x			lda		lowStack,x
.aa1c	3d 01 06	and $0601,x			and		lowStack+1,x
.aa1f	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa22	bd 80 06	lda $0680,x			lda		highStack,x
.aa25	3d 81 06	and $0681,x			and 	highStack+1,x
.aa28	9d 80 06	sta $0680,x			sta 	highStack,x
.aa2b	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.aa2e					Stack_Xor:
.aa2e	fa		plx				plx
.aa2f	ca		dex				dex
.aa30	bd 00 06	lda $0600,x			lda		lowStack,x
.aa33	5d 01 06	eor $0601,x			eor		lowStack+1,x
.aa36	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa39	bd 80 06	lda $0680,x			lda		highStack,x
.aa3c	5d 81 06	eor $0681,x			eor 	highStack+1,x
.aa3f	9d 80 06	sta $0680,x			sta 	highStack,x
.aa42	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.aa45					Stack_Or:
.aa45	fa		plx				plx
.aa46	ca		dex				dex
.aa47	bd 00 06	lda $0600,x			lda		lowStack,x
.aa4a	1d 01 06	ora $0601,x			ora		lowStack+1,x
.aa4d	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa50	bd 80 06	lda $0680,x			lda		highStack,x
.aa53	1d 81 06	ora $0681,x			ora 	highStack+1,x
.aa56	9d 80 06	sta $0680,x			sta 	highStack,x
.aa59	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.aa5c					Stack_Shl:
.aa5c	fa		plx				plx
.aa5d	38		sec				sec
.aa5e	80 02		bra $aa62			bra 	StackShift
.aa60					Stack_Shr:
.aa60	fa		plx				plx
.aa61	18		clc				clc
.aa62					StackShift:
.aa62	08		php				php
.aa63	ca		dex				dex
.aa64	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.aa67	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.aa69	1d 81 06	ora $0681,x			ora 	highStack+1,x
.aa6c	d0 19		bne $aa87			bne 	_SSZero
.aa6e					_SSLoop:
.aa6e	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.aa71	30 1a		bmi $aa8d			bmi 	_SSDone 					; completed ?
.aa73	28		plp				plp 								; restore flag
.aa74	08		php				php
.aa75	b0 08		bcs $aa7f			bcs 	_SSLeft 					; do either shift.
.aa77	5e 80 06	lsr $0680,x			lsr 	highStack,x
.aa7a	7e 00 06	ror $0600,x			ror 	lowStack,x
.aa7d	80 ef		bra $aa6e			bra 	_SSLoop
.aa7f					_SSLeft:
.aa7f	1e 00 06	asl $0600,x			asl 	lowStack,x
.aa82	3e 80 06	rol $0680,x			rol 	highStack,x
.aa85	80 e7		bra $aa6e			bra 	_SSLoop
.aa87					_SSZero:
.aa87	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.aa8a	9e 80 06	stz $0680,x			stz 	highStack,x
.aa8d					_SSDone:
.aa8d	28		plp				plp 								; throw flag.
.aa8e	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.aa91					Comp_Equal:
.aa91	fa		plx				plx
.aa92	38		sec				sec
.aa93	80 02		bra $aa97			bra 	Comp_CheckEqual
.aa95					Comp_NotEqual:
.aa95	fa		plx				plx
.aa96	18		clc				clc
.aa97					Comp_CheckEqual:
.aa97	08		php				php
.aa98	ca		dex				dex
.aa99	bd 00 06	lda $0600,x			lda		lowStack,x
.aa9c	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.aa9f	d0 06		bne $aaa7			bne 	_CCENonZero
.aaa1	bd 80 06	lda $0680,x			lda		highStack,x
.aaa4	5d 81 06	eor $0681,x			eor 	highStack+1,x
.aaa7					_CCENonZero:
.aaa7	f0 02		beq $aaab			beq 	_CCENotSet
.aaa9	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.aaab					_CCENotSet:
.aaab					CompCheckFlip:
.aaab	28		plp				plp 								; if carry set, we want $FF if equal
.aaac	90 02		bcc $aab0			bcc 	CompReturn
.aaae	49 ff		eor #$ff			eor 	#$FF
.aab0					CompReturn:
.aab0	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.aab3	9d 80 06	sta $0680,x			sta 	highStack,x
.aab6	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.aab9					Comp_Less:
.aab9	fa		plx				plx
.aaba	18		clc				clc
.aabb	80 02		bra $aabf			bra 	Comp_LessCont
.aabd					Comp_GreaterEqual:
.aabd	fa		plx				plx
.aabe	38		sec				sec
.aabf					Comp_LessCont:
.aabf	08		php				php
.aac0	ca		dex				dex
.aac1	38		sec				sec
.aac2	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.aac5	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.aac8	bd 80 06	lda $0680,x			lda 	highStack,x
.aacb	fd 81 06	sbc $0681,x			sbc 	highStack+1,x
.aace	50 02		bvc $aad2			bvc 	_CLNoFlip 					; unsigned -> signed
.aad0	49 80		eor #$80			eor 	#$80
.aad2					_CLNoFlip:
.aad2	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.aad4	f0 d5		beq $aaab			beq 	CompCheckFlip
.aad6	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.aad8	80 d1		bra $aaab			bra 	CompCheckFlip
.aada					Comp_LessEqual:
.aada	fa		plx				plx
.aadb	38		sec				sec
.aadc	80 02		bra $aae0			bra 	Comp_LessEqualCont
.aade					Comp_Greater:
.aade	fa		plx				plx
.aadf	18		clc				clc
.aae0					Comp_LessEqualCont:
.aae0	08		php				php
.aae1	ca		dex				dex
.aae2	38		sec				sec
.aae3	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.aae6	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.aae9	bd 81 06	lda $0681,x			lda 	highStack+1,x
.aaec	fd 80 06	sbc $0680,x			sbc 	highStack,x
.aaef	50 02		bvc $aaf3			bvc 	_CLENoFlip 					; unsigned -> signed
.aaf1	49 80		eor #$80			eor 	#$80
.aaf3					_CLENoFlip:
.aaf3	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.aaf5	f0 b4		beq $aaab			beq 	CompCheckFlip
.aaf7	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.aaf9	80 b0		bra $aaab			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.aafb					DivInteger16:
.aafb	fa		plx				plx
.aafc	20 02 ab	jsr $ab02			jsr 	IntegerDivide
.aaff	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ab02					IntegerDivide:
.ab02	ca		dex				dex
.ab03	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.ab06	1d 81 06	ora $0681,x			ora 	highStack+1,x
.ab09	d0 14		bne $ab1f			bne 	_BFDOkay
.ab0b	20 92 a1	jsr $a192			jsr 	ErrorHandler
>ab0e	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ab16	20 42 59 20 5a 45 52 4f 00
.ab1f					_BFDOkay:
.ab1f	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.ab21	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.ab23	64 0c		stz $0c				stz 	SignCount 					; Count of signs.
.ab25	20 61 ab	jsr $ab61			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ab28	e8		inx				inx
.ab29	20 61 ab	jsr $ab61			jsr 	CheckIntegerNegate
.ab2c	ca		dex				dex
.ab2d	5a		phy				phy 								; Y is the counter
.ab2e	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.ab30					_BFDLoop:
.ab30	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.ab33	3e 80 06	rol $0680,x			rol 	highStack,x
.ab36	26 04		rol $04				rol 	zTemp1
.ab38	26 05		rol $05				rol 	zTemp1+1
.ab3a	38		sec				sec
.ab3b	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.ab3d	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ab40	48		pha				pha
.ab41	a5 05		lda $05				lda 	zTemp1+1
.ab43	fd 81 06	sbc $0681,x			sbc 	highStack+1,x
.ab46	90 0f		bcc $ab57			bcc 	_BFDNoAdd
.ab48	85 05		sta $05				sta 	zTemp1+1
.ab4a	68		pla				pla
.ab4b	85 04		sta $04				sta 	zTemp1+0
.ab4d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.ab50	09 01		ora #$01			ora 	#1
.ab52	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab55	80 01		bra $ab58			bra 	_BFDNext
.ab57					_BFDNoAdd:
.ab57	68		pla				pla 								; Throw away the intermediate calculations
.ab58					_BFDNext:
.ab58	88		dey				dey
.ab59	d0 d5		bne $ab30			bne 	_BFDLoop
.ab5b	7a		ply				ply 								; restore Y
.ab5c	46 0c		lsr $0c				lsr 	SignCount 					; if sign count odd,
.ab5e	b0 07		bcs $ab67			bcs		IntegerNegateAlways 		; negate the result
.ab60	60		rts				rts
.ab61					CheckIntegerNegate:
.ab61	bd 80 06	lda $0680,x			lda 	highStack,x 				; is it -ve = MSB set ?
.ab64	30 01		bmi $ab67			bmi 	IntegerNegateAlways 		; if so negate it
.ab66	60		rts				rts
.ab67					IntegerNegateAlways:
.ab67	e6 0c		inc $0c				inc 	SignCount 					; bump the count of signs
.ab69	4c c4 ab	jmp $abc4			jmp 	Unary_Negate
.ab6c					ModInteger16:
.ab6c	fa		plx				plx
.ab6d	20 02 ab	jsr $ab02			jsr 	IntegerDivide
.ab70	a5 04		lda $04				lda 	zTemp1
.ab72	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab75	a5 05		lda $05				lda 	zTemp1+1
.ab77	9d 80 06	sta $0680,x			sta 	highStack,x
.ab7a	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.ab7d					MulInteger16:
.ab7d	fa		plx				plx
.ab7e	ca		dex				dex
.ab7f	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.ab82	85 04		sta $04				sta 	zTemp1
.ab84	bd 80 06	lda $0680,x			lda 	highStack,x
.ab87	85 05		sta $05				sta 	zTemp1+1
.ab89	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.ab8c	9e 80 06	stz $0680,x			stz 	highStack,x
.ab8f					_BFMMultiply:
.ab8f	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.ab91	29 01		and #$01			and 	#1
.ab93	f0 13		beq $aba8			beq 	_BFMNoAdd
.ab95	18		clc				clc 								; add old tos to current tos.
.ab96	bd 00 06	lda $0600,x			lda		lowStack,x
.ab99	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ab9c	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab9f	bd 80 06	lda $0680,x			lda		highStack,x
.aba2	7d 81 06	adc $0681,x			adc 	highStack+1,x
.aba5	9d 80 06	sta $0680,x			sta 	highStack,x
.aba8					_BFMNoAdd:
.aba8	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.abab	3e 81 06	rol $0681,x			rol 	highStack+1,x
.abae	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.abb0	66 04		ror $04				ror 	zTemp1+0
.abb2	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.abb4	05 05		ora $05				ora 	zTemp1+1
.abb6	d0 d7		bne $ab8f			bne 	_BFMMultiply
.abb8	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.abbb					Unary_Absolute:
.abbb	fa		plx				plx
.abbc	bd 80 06	lda $0680,x			lda 	highStack,x
.abbf	30 04		bmi $abc5			bmi 	Unary_Negate_Code
.abc1	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.abc4					Unary_Negate:
.abc4	fa		plx				plx
.abc5					Unary_Negate_Code:
.abc5	38		sec				sec
.abc6	a9 00		lda #$00			lda		#0
.abc8	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.abcb	9d 00 06	sta $0600,x			sta 	lowStack,x
.abce	a9 00		lda #$00			lda		#0
.abd0	fd 80 06	sbc $0680,x			sbc 	highStack,x
.abd3	9d 80 06	sta $0680,x			sta 	highStack,x
.abd6	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.abd9					Unary_Not:
.abd9	fa		plx				plx
.abda	bd 00 06	lda $0600,x			lda 	lowStack,x
.abdd	49 ff		eor #$ff			eor 	#$FF
.abdf	9d 00 06	sta $0600,x			sta 	lowStack,x
.abe2	bd 80 06	lda $0680,x			lda 	highStack,x
.abe5	49 ff		eor #$ff			eor 	#$FF
.abe7	9d 80 06	sta $0680,x			sta 	highStack,x
.abea	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.abed					Unary_Increment:
.abed	fa		plx				plx
.abee	fe 00 06	inc $0600,x			inc 	lowStack,x
.abf1	d0 03		bne $abf6			bne 	_UIExit
.abf3	fe 80 06	inc $0680,x			inc 	highStack,x
.abf6					_UIExit:
.abf6	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.abf9					Unary_Decrement:
.abf9	fa		plx				plx
.abfa	bd 00 06	lda $0600,x			lda 	lowStack,x
.abfd	d0 03		bne $ac02			bne 	_UDNoBorrow
.abff	de 80 06	dec $0680,x			dec 	highStack,x
.ac02					_UDNoBorrow:
.ac02	de 00 06	dec $0600,x			dec 	lowStack,x
.ac05	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ac08					Unary_BSwap:
.ac08	fa		plx				plx
.ac09	bd 00 06	lda $0600,x			lda 	lowStack,x
.ac0c	48		pha				pha
.ac0d	bd 80 06	lda $0680,x			lda 	highStack,x
.ac10	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac13	68		pla				pla
.ac14	9d 80 06	sta $0680,x			sta 	highStack,x
.ac17	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ac1a					Unary_Shl:
.ac1a	fa		plx				plx
.ac1b	1e 00 06	asl $0600,x			asl 	lowStack,x
.ac1e	3e 80 06	rol $0680,x			rol 	highStack,x
.ac21	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ac24					Unary_Shr:
.ac24	fa		plx				plx
.ac25	5e 80 06	lsr $0680,x			lsr 	highStack,x
.ac28	7e 00 06	ror $0600,x			ror 	lowStack,x
.ac2b	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ac2e					Unary_Sgn:
.ac2e	fa		plx				plx
.ac2f	bd 80 06	lda $0680,x			lda 	highStack,x 				; check bit 7.
.ac32	10 0a		bpl $ac3e			bpl 	_USNotNeg
.ac34	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.ac36	9d 00 06	sta $0600,x			sta 	lowStack,x
.ac39	9d 80 06	sta $0680,x			sta 	highStack,x
.ac3c	80 10		bra $ac4e			bra 	_USExit
.ac3e					_USNotNeg:
.ac3e	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.ac41	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.ac44	9e 80 06	stz $0680,x			stz 	highStack,x
.ac47	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.ac49	f0 03		beq $ac4e			beq 	_USExit
.ac4b	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.ac4e					_USExit:
.ac4e	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ac51					Random_Handler:
.ac51	fa		plx				plx
.ac52	a5 11		lda $11				lda 	randomSeed
.ac54	05 12		ora $12				ora 	randomSeed+1
.ac56	d0 08		bne $ac60			bne 	_RH_NoInit
.ac58	a9 7c		lda #$7c			lda 	#$7C
.ac5a	85 11		sta $11				sta 	randomSeed
.ac5c	a9 a1		lda #$a1			lda 	#$A1
.ac5e	85 12		sta $12				sta 	randomSeed+1
.ac60					_RH_NoInit:
.ac60	a5 11		lda $11				lda 	randomSeed
.ac62	4a		lsr a		        lsr		a
.ac63	26 12		rol $12		        rol 	randomSeed+1
.ac65	90 02		bcc $ac69	        bcc 	_RH_NoEor
.ac67	49 b4		eor #$b4	        eor 	#$B4
.ac69					_RH_NoEor:
.ac69	85 11		sta $11		        sta 	randomSeed
.ac6b	45 12		eor $12		        eor 	randomSeed+1
.ac6d	e8		inx		        inx
.ac6e	9d 80 06	sta $0680,x	        sta 	highStack,x
.ac71	a5 11		lda $11		        lda 	randomSeed
.ac73	9d 00 06	sta $0600,x	        sta 	lowStack,x
.ac76	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.ac79					Command_Call:
.ac79	fa		plx				plx
.ac7a	20 2d a4	jsr $a42d			jsr 	StackPushPosition 				; save stack position
.ac7d	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.ac7f	20 1d a4	jsr $a41d			jsr 	StackPushByte
.ac82	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.ac84	85 02		sta $02				sta 	zTemp0
.ac86	c8		iny				iny
.ac87	b1 00		lda ($00),y			lda 	(codePtr),y
.ac89	85 03		sta $03				sta 	zTemp0+1
.ac8b	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ac8d	85 00		sta $00				sta 	codePtr
.ac8f	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.ac91	85 01		sta $01				sta 	codePtr+1
.ac93	a0 01		ldy #$01			ldy 	#1
.ac95					_CCSearch:
.ac95	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.ac97	f0 2d		beq $acc6			beq		_CCFail
.ac99	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.ac9b	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.ac9d	f0 0d		beq $acac			beq 	_CCCheckMSB
.ac9f	18		clc				clc 									; forward to next line.
.aca0	b2 00		lda ($00)			lda 	(codePtr)
.aca2	65 00		adc $00				adc 	codePtr
.aca4	85 00		sta $00				sta 	codePtr
.aca6	90 ed		bcc $ac95			bcc 	_CCSearch
.aca8	e6 01		inc $01				inc 	codePtr+1
.acaa	80 e9		bra $ac95			bra 	_CCSearch
.acac					_CCCheckMSB:
.acac	c8		iny				iny 									; get MSB, keeping Y as 1
.acad	b1 00		lda ($00),y			lda 	(codePtr),y
.acaf	88		dey				dey
.acb0	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.acb2	d0 e1		bne $ac95			bne 	_CCSearch
.acb4	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.acb6	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.acb8	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.acba	d0 0a		bne $acc6			bne 	_CCFail
.acbc	c8		iny				iny 									; get the length of this.
.acbd	b1 00		lda ($00),y			lda 	(codePtr),y
.acbf	18		clc				clc
.acc0	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.acc2	a8		tay				tay
.acc3	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.acc6					_CCFail:
.acc6	20 92 a1	jsr $a192			jsr 	ErrorHandler
>acc9	43 41 4c 4c 3f 00				.text 	"CALL?",0
.accf					Command_Return:
.accf	fa		plx				plx
.acd0	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.acd2	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.acd5	90 0f		bcc $ace6			bcc 	_CRFail
.acd7	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.acd9	20 4a a4	jsr $a44a			jsr 	StackRestorePosition
.acdc	c8		iny				iny
.acdd	c8		iny				iny
.acde	a9 04		lda #$04			lda 	#4 								; pop off stack
.ace0	20 44 a4	jsr $a444			jsr 	StackPop
.ace3	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ace6					_CRFail:
.ace6	20 92 a1	jsr $a192			jsr 	ErrorHandler
>ace9	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.acef					Structure_If:
.acef	fa		plx				plx
.acf0	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.acf2	20 1d a4	jsr $a41d			jsr 	StackPushByte
.acf5	18		clc				clc
.acf6	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.acf9	1d 80 06	ora $0680,x			ora 	highStack,x
.acfc	ca		dex				dex 									; drop TOS
.acfd	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.acff	d0 0e		bne $ad0f			bne 	_SIFNoSkip 						; at this level.
.ad01	da		phx				phx
.ad02	a9 37		lda #$37			lda 	#KWD_ELSE
.ad04	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.ad06	20 3c ad	jsr $ad3c			jsr 	StructSkipForward
.ad09	fa		plx				plx 									; restore X
.ad0a	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.ad0c	d0 01		bne $ad0f			bne 	_SIFNoSkip 						; clause.
.ad0e	c8		iny				iny
.ad0f					_SIFNoSkip:
.ad0f	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ad12					Structure_Else:
.ad12	fa		plx				plx
.ad13	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ad15	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.ad18	90 0b		bcc $ad25			bcc 	SIFail
.ad1a	da		phx				phx 									; got here by executing IF clause so skip
.ad1b	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.ad1d	aa		tax				tax
.ad1e	20 3c ad	jsr $ad3c			jsr 	StructSkipForward
.ad21	fa		plx				plx
.ad22	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ad25					SIFail:
.ad25	20 92 a1	jsr $a192			jsr 	ErrorHandler
>ad28	49 46 3f 00					.text 	"IF?",0
.ad2c					Structure_Endif:
.ad2c	fa		plx				plx
.ad2d	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ad2f	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.ad32	90 f1		bcc $ad25			bcc 	SIFail
.ad34	a9 01		lda #$01			lda 	#1 								; throw it.
.ad36	20 44 a4	jsr $a444			jsr 	StackPop
.ad39	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ad3c					StructSkipForward:
.ad3c	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.ad3e	86 03		stx $03				stx 	zTemp0+1
.ad40	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.ad42					_SSFLoop:
.ad42	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.ad44	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.ad46	d0 08		bne $ad50			bne		_SSFFail
.ad48	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.ad4a	f0 17		beq $ad63			beq 	_SSFEnd
.ad4c	c5 03		cmp $03				cmp 	zTemp0+1
.ad4e	f0 13		beq $ad63			beq 	_SSFEnd
.ad50					_SSFFail:
.ad50	20 64 ad	jsr $ad64			jsr 	AdvanceInCode 					; skip over in code.
.ad53	b0 ed		bcs $ad42			bcs 	_SSFLoop 						; if not end of program, keep going.
.ad55	20 92 a1	jsr $a192			jsr 	ErrorHandler
>ad58	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>ad60	45 3f 00
.ad63					_SSFEnd:
.ad63	60		rts				rts
.ad64					AdvanceInCode:
.ad64	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.ad66	f0 28		beq $ad90			beq 	_AICEndOfLine 					; end of line.
.ad68	c8		iny				iny 									; advance one.
.ad69	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.ad6b	90 10		bcc $ad7d			bcc 	_AICControl
.ad6d	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.ad6f	b0 0a		bcs $ad7b			bcs 	_AICExit
.ad71	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.ad73	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.ad75	90 04		bcc $ad7b			bcc 	_AICExit
.ad77	c6 04		dec $04				dec 	zTemp1
.ad79	c6 04		dec $04				dec 	zTemp1
.ad7b					_AICExit:
.ad7b	38		sec				sec
.ad7c	60		rts				rts
.ad7d					_AICControl:
.ad7d	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.ad7f	f0 0b		beq $ad8c			beq 	_AICThree
.ad81	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.ad83	f0 07		beq $ad8c			beq 	_AICThree
.ad85	98		tya				tya										; skip over a string/comment/define.
.ad86	38		sec				sec
.ad87	71 00		adc ($00),y			adc 	(codePtr),y
.ad89	a8		tay				tay
.ad8a	38		sec				sec
.ad8b	60		rts				rts
.ad8c					_AICThree:
.ad8c	c8		iny				iny
.ad8d	c8		iny				iny
.ad8e	38		sec				sec
.ad8f	60		rts				rts
.ad90					_AICEndOfLine:
.ad90	18		clc				clc 									; forward to next line.
.ad91	b2 00		lda ($00)			lda 	(codePtr)
.ad93	65 00		adc $00				adc 	codePtr
.ad95	85 00		sta $00				sta 	codePtr
.ad97	90 02		bcc $ad9b			bcc 	_AICNoCarry
.ad99	e6 01		inc $01				inc 	codePtr+1
.ad9b					_AICNoCarry:
.ad9b	a0 03		ldy #$03			ldy 	#3 								; start of new line
.ad9d	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.ad9f	d0 da		bne $ad7b			bne 	_AICExit
.ada1	18		clc				clc 									; program end.
.ada2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.ada3					Struct_Repeat:
.ada3	fa		plx				plx
.ada4	20 2d a4	jsr $a42d			jsr 	StackPushPosition 				; save stack position
.ada7	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.ada9	20 1d a4	jsr $a41d			jsr 	StackPushByte
.adac	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.adaf					Struct_Until:
.adaf	fa		plx				plx
.adb0	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.adb2	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.adb5	90 1b		bcc $add2			bcc 	_SUFail
.adb7	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.adba	1d 80 06	ora $0680,x			ora 	highStack,x
.adbd	ca		dex				dex
.adbe	09 00		ora #$00			ora 	#0
.adc0	f0 08		beq $adca			beq 	_SULoopBack 					; if so keep going.
.adc2	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.adc4	20 44 a4	jsr $a444			jsr 	StackPop
.adc7	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.adca					_SULoopBack:
.adca	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.adcc	20 4a a4	jsr $a44a			jsr 	StackRestorePosition
.adcf	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.add2					_SUFail:
.add2	20 92 a1	jsr $a192			jsr 	ErrorHandler
>add5	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>addd	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.addf					Struct_For:
.addf	fa		plx				plx
.ade0	18		clc				clc
.ade1	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.ade4	49 ff		eor #$ff			eor 	#$FF
.ade6	69 01		adc #$01			adc 	#1
.ade8	08		php				php
.ade9	20 1d a4	jsr $a41d			jsr 	StackPushByte
.adec	bd 80 06	lda $0680,x			lda 	highStack,x
.adef	49 ff		eor #$ff			eor 	#$FF
.adf1	28		plp				plp
.adf2	69 00		adc #$00			adc 	#0
.adf4	20 1d a4	jsr $a41d			jsr 	StackPushByte
.adf7	ca		dex				dex 									; throw TOS
.adf8	20 2d a4	jsr $a42d			jsr 	StackPushPosition 				; save stack position
.adfb	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.adfd	20 1d a4	jsr $a41d			jsr 	StackPushByte
.ae00	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ae03					Struct_Index:
.ae03	fa		plx				plx
.ae04	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.ae06	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.ae09	90 43		bcc $ae4e			bcc 	SNFail
.ae0b	e8		inx				inx 									; new stack entry
.ae0c	5a		phy				phy
.ae0d	a0 04		ldy #$04			ldy 	#4 								; access index value
.ae0f	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae11	49 ff		eor #$ff			eor 	#$FF
.ae13	9d 80 06	sta $0680,x			sta 	highStack,x
.ae16	c8		iny				iny
.ae17	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae19	49 ff		eor #$ff			eor 	#$FF
.ae1b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ae1e	7a		ply				ply 									; restore code pointer
.ae1f	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ae22					Struct_Next:
.ae22	fa		plx				plx
.ae23	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.ae25	20 3c a4	jsr $a43c			jsr 	StackCheckTop
.ae28	90 24		bcc $ae4e			bcc 	SNFail
.ae2a	5a		phy				phy 									; save code position
.ae2b	a0 05		ldy #$05			ldy 	#5 								; bump the count
.ae2d	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae2f	1a		inc a				inc 	a
.ae30	91 0a		sta ($0a),y			sta 	(iStack),y
.ae32	d0 11		bne $ae45			bne 	_SNLoopBack
.ae34	88		dey				dey
.ae35	b1 0a		lda ($0a),y			lda 	(iStack),y
.ae37	1a		inc a				inc 	a
.ae38	91 0a		sta ($0a),y			sta 	(iStack),y
.ae3a	d0 09		bne $ae45			bne 	_SNLoopBack  					; non-zero loop back.
.ae3c	7a		ply				ply 									; restore code position.
.ae3d	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.ae3f	20 44 a4	jsr $a444			jsr 	StackPop
.ae42	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ae45					_SNLoopBack:
.ae45	7a		ply				ply 									; restore code position, being junked anyway.
.ae46	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.ae48	20 4a a4	jsr $a44a			jsr 	StackRestorePosition
.ae4b	4c f7 a1	jmp $a1f7			jmp 	ExecuteLoop
.ae4e					SNFail:
.ae4e	20 92 a1	jsr $a192			jsr 	ErrorHandler
>ae51	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
