
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Thu Nov 14 20:44:49 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$9f00					HighMemory = $9F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					iStack:			.word ?						; stack pointer
>000c					signCount:		.byte ? 					; divide sign count.
>000d					allocPtr:		.word ? 					; memory allocation pointer (down)
>000f					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0011					randomSeed:		.word ? 					; random number seed
>0013					prefixCharacter:.byte ?						; char to print before listed element.
>0014					breakCount:		.byte ? 					; counter avoids repeated break checks
>0015					tokenOffset:	.byte ? 					; position in output token buffer.
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 a0	jmp $a000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	1a e8 03 3d 01 00 60 22			.byte	$1a,$e8,$03,$3d,$01,$00,$60,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$04,$05,$48,$45,$4c,$4c,$4f,$03,$01,$27,$00,$0b,$f2,$03,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$fc,$03,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$06,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$42,$04,$0b,$00,$08,$10,$04,$01,$50,$00,$08,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$38,$02,$38,$04,$02,$88,$04,$0b,$00,$05,$24,$04,$0b,$00,$05,$2e,$04,$40,$00,$1e,$38,$04,$05,$06,$d3,$c5,$cc,$c5,$c3,$f4,$2d,$2d,$2d,$2d,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$39,$00,$29,$42,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$30,$27,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$30,$27,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$4c,$04,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$56,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$30,$87,$11,$2a,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$60,$04,$39,$00,$15,$56,$04,$05,$04,$d2,$d3,$c7,$ee,$30,$81,$11,$06,$81,$37,$01,$ff,$ff,$09,$39,$00,$0f,$60,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$6a,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2d,$01,$20,$9f,$1d,$00,$0f,$74,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$7e,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$39,$00,$0f,$88,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$92,$04,$a0,$02,$60,$04,$00,$1c,$9c,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$a6,$04,$33,$01,$50,$00,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$33,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ba,$04,$33,$bc,$1a,$36,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$28,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$c4,$04,$01,$51,$00,$02,$60,$04,$00,$05,$ce,$04,$39,$00
>1008	c2 c1 cc cc cd c5 ed 04 05 48 45 4c 4c 4f 03 01
>1018	27 00 0b f2 03 a0 22 c3 cf d5 ce f4 00 0d fc 03
>1028	01 8e 00 22 e1 01 d2 ff 25 00 12 06 04 c3 cf d5
>1038	ce f4 08 38 02 38 04 02 42 04 0b 00 08 10 04 01
>1048	50 00 08 00 12 1a 04 c3 cf d5 ce f4 08 38 02 38
>1058	04 02 88 04 0b 00 05 24 04 0b 00 05 2e 04 40 00
>1068	1e 38 04 05 06 d3 c5 cc c5 c3 f4 2d 2d 2d 2d c2
>1078	c1 cc cc cd c5 ed 0f 22 c2 c1 cc ec 39 00 29 42
>1088	04 05 09 c2 c1 cc cc db c9 ce c9 f4 30 27 01 50
>1098	00 0e 22 c2 c1 cc ec 23 80 24 30 27 bc 0e 22 c2
>10a8	c1 cc ec 23 81 24 00 2d 4c 04 02 56 04 22 c2 c1
>10b8	cc ec 23 82 24 02 56 04 22 c2 c1 cc ec 23 83 24
>10c8	30 87 11 2a 22 c2 c1 cc ec 23 84 24 01 51 00 02
>10d8	60 04 39 00 15 56 04 05 04 d2 d3 c7 ee 30 81 11
>10e8	06 81 37 01 ff ff 09 39 00 0f 60 04 05 09 c2 c1
>10f8	cc cc db c4 d2 c1 f7 00 10 6a 04 c2 c1 cc ec 23
>1108	80 24 2d 01 20 9f 1d 00 0f 74 04 c2 c1 cc ec 23
>1118	81 24 01 21 9f 1d 00 19 7e 04 90 01 22 9f 1d 01
>1128	23 9f 1d c2 c1 cc ec 23 84 24 01 23 9f 1d 39 00
>1138	0f 88 04 05 09 c2 c1 cc cc db cd cf d6 e5 00 08
>1148	92 04 a0 02 60 04 00 1c 9c 04 c2 c1 cc ec 23 80
>1158	24 c2 c1 cc ec 23 82 24 0f 33 22 c2 c1 cc ec 23
>1168	80 24 00 1f a6 04 33 01 50 00 1a 36 80 19 12 06
>1178	c2 c1 cc ec 23 82 24 28 22 c2 c1 cc ec 23 82 24
>1188	09 00 1c b0 04 c2 c1 cc ec 23 81 24 c2 c1 cc ec
>1198	23 83 24 0f 33 22 c2 c1 cc ec 23 81 24 00 1d ba
>11a8	04 33 bc 1a 36 80 19 12 06 c2 c1 cc ec 23 83 24
>11b8	28 22 c2 c1 cc ec 23 83 24 09 00 0a c4 04 01 51
>11c8	00 02 60 04 00 05 ce 04 39 00

;******  Return to file: main.asm

.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs

;******  Processing file: tokenise/test.asm

.a003	4c 3e a0	jmp $a03e				jmp 	TokTest1
.a006					TokenCode:
>a006	20 20 34 32 20 24 35 41				.text 	"  42 $5A7 4- 32767 :HEL.LO :TEST.DEFINE"
>a00e	37 20 34 2d 20 33 32 37 36 37 20 3a 48 45 4c 2e
>a01e	4c 4f 20 3a 54 45 53 54 2e 44 45 46 49 4e 45
>a02d	22 53 54 52 49 4e 47 22				.text 	'"STRING"'
>a035	27 43 4f 4d 4d 45 4e 54				.text 	"'COMMENT"
>a03d	00						.byte 	0
.a03e					TokTest1:
.a03e	a2 ff		ldx #$ff			ldx 	#255 						; copy to input buffer.
.a040					_TT1Copy:
.a040	e8		inx				inx
.a041	bd 06 a0	lda $a006,x			lda 	TokenCode,x
.a044	9d 00 08	sta $0800,x			sta	 	InputBuffer,x
.a047	d0 f7		bne $a040			bne 	_TT1Copy
.a049	20 72 a6	jsr $a672			jsr 	TokeniseInputBuffer
.a04c					_TT1Halt:
.a04c	80 fe		bra $a04c			bra 	_TT1Halt

;******  Return to file: main.asm

.a04e	20 ed a2	jsr $a2ed			jsr 	ExternInitialise
.a051	4c 2d a2	jmp $a22d			jmp 	ExecuteProgram
.a054					WarmStart:
>a054	ff						.byte 	$FF
.a055	a2 55		ldx #$55			ldx 	#$55

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_ABS                        = $0027 ; abs
=$0028					KWD_NEGATE                     = $0028 ; negate
=$0029					KWD_NOT                        = $0029 ; not
=$002a					KWD_PLUSPLUS                   = $002a ; ++
=$002b					KWD_MINUSMINUS                 = $002b ; --
=$002c					KWD_BSWAP                      = $002c ; bswap
=$002d					KWD_LESSLESS                   = $002d ; <<
=$002e					KWD_GREATERGREATER             = $002e ; >>
=$002f					KWD_SGN                        = $002f ; sgn
=$0030					KWD_RND                        = $0030 ; rnd
=$0031					KWD_CLR                        = $0031 ; clr
=$0032					KWD_DROP                       = $0032 ; drop
=$0033					KWD_DUP                        = $0033 ; dup
=$0034					KWD_NIP                        = $0034 ; nip
=$0035					KWD_OVER                       = $0035 ; over
=$0036					KWD_SWAP                       = $0036 ; swap
=$0037					KWD_ELSE                       = $0037 ; else
=$0038					KWD_INDEX                      = $0038 ; index
=$0039					KWD_SEMICOLON                  = $0039 ; ;
=$003a					KWD_ASSERT                     = $003a ; assert
=$003b					KWD_LIST                       = $003b ; list
=$003c					KWD_NEW                        = $003c ; new
=$003d					KWD_OLD                        = $003d ; old
=$003e					KWD_STOP                       = $003e ; stop
=$003f					KWD_RUN                        = $003f ; run
=$0040					KWD_END                        = $0040 ; end
=$0041					KWD_SAVE                       = $0041 ; save
=$0042					KWD_LOAD                       = $0042 ; load
.a057					KeywordText:
>a057	01 ff					.text $01,$ff                          ; $0000 %eol
>a059	01 ff					.text $01,$ff                          ; $0001 %const
>a05b	01 ff					.text $01,$ff                          ; $0002 %call
>a05d	01 ff					.text $01,$ff                          ; $0003 %comment
>a05f	01 ff					.text $01,$ff                          ; $0004 %qstring
>a061	01 ff					.text $01,$ff                          ; $0005 %define
>a063	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>a066	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>a06d	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>a071	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>a077	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>a07d	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>a082	01 aa					.text $01,$aa                          ; $000c *
>a084	01 af					.text $01,$af                          ; $000d /
>a086	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>a08a	01 ab					.text $01,$ab                          ; $000f +
>a08c	01 ad					.text $01,$ad                          ; $0010 -
>a08e	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>a092	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>a095	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>a099	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>a09d	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>a0a1	01 bd					.text $01,$bd                          ; $0016 =
>a0a3	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>a0a6	01 be					.text $01,$be                          ; $0018 >
>a0a8	01 bc					.text $01,$bc                          ; $0019 <
>a0aa	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>a0ad	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>a0b0	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>a0b3	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>a0b6	01 c0					.text $01,$c0                          ; $001e @
>a0b8	01 a1					.text $01,$a1                          ; $001f !
>a0ba	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>a0bd	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>a0c3	01 de					.text $01,$de                          ; $0022 ^
>a0c5	01 db					.text $01,$db                          ; $0023 [
>a0c7	01 dd					.text $01,$dd                          ; $0024 ]
>a0c9	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>a0cd	01 bf					.text $01,$bf                          ; $0026 ?
>a0cf	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0027 abs
>a0d3	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0028 negate
>a0da	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $0029 not
>a0de	02 2b ab				.text $02,$2b,$ab                      ; $002a ++
>a0e1	02 2d ad				.text $02,$2d,$ad                      ; $002b --
>a0e4	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002c bswap
>a0ea	02 3c bc				.text $02,$3c,$bc                      ; $002d <<
>a0ed	02 3e be				.text $02,$3e,$be                      ; $002e >>
>a0f0	03 53 47 ce				.text $03,$53,$47,$ce                  ; $002f sgn
>a0f4	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0030 rnd
>a0f8	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0031 clr
>a0fc	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0032 drop
>a101	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0033 dup
>a105	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0034 nip
>a109	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0035 over
>a10e	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0036 swap
>a113	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0037 else
>a118	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0038 index
>a11e	01 bb					.text $01,$bb                          ; $0039 ;
>a120	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003a assert
>a127	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003b list
>a12c	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003c new
>a130	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003d old
>a134	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003e stop
>a139	03 52 55 ce				.text $03,$52,$55,$ce                  ; $003f run
>a13d	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0040 end
>a141	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0041 save
>a146	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0042 load
>a14b	00					.byte 0
>a14c						.align 2
.a14c					DispatchHandler:
>a14c	ae a2					.word ExecuteNextLine          ; $0000 %eol
>a14e	c4 a2					.word LongConstant             ; $0001 %const
>a150	d5 ad					.word Command_Call             ; $0002 %call
>a152	ae a2					.word ExecuteComment           ; $0003 %comment
>a154	d5 a2					.word StringConstant           ; $0004 %qstring
>a156	d2 a1					.word SyntaxError              ; $0005 %define
>a158	4b ae					.word Structure_If             ; $0006 if
>a15a	ff ae					.word Struct_Repeat            ; $0007 repeat
>a15c	3b af					.word Struct_For               ; $0008 for
>a15e	88 ae					.word Structure_Endif          ; $0009 endif
>a160	0b af					.word Struct_Until             ; $000a until
>a162	7e af					.word Struct_Next              ; $000b next
>a164	d9 ac					.word MulInteger16             ; $000c *
>a166	57 ac					.word DivInteger16             ; $000d /
>a168	c8 ac					.word ModInteger16             ; $000e mod
>a16a	43 ab					.word Stack_Add                ; $000f +
>a16c	5b ab					.word Stack_Sub                ; $0010 -
>a16e	73 ab					.word Stack_And                ; $0011 and
>a170	a1 ab					.word Stack_Or                 ; $0012 or
>a172	8a ab					.word Stack_Xor                ; $0013 xor
>a174	b8 ab					.word Stack_Shl                ; $0014 shl
>a176	bc ab					.word Stack_Shr                ; $0015 shr
>a178	ed ab					.word Comp_Equal               ; $0016 =
>a17a	f1 ab					.word Comp_NotEqual            ; $0017 <>
>a17c	3a ac					.word Comp_Greater             ; $0018 >
>a17e	15 ac					.word Comp_Less                ; $0019 <
>a180	19 ac					.word Comp_GreaterEqual        ; $001a >=
>a182	36 ac					.word Comp_LessEqual           ; $001b <=
>a184	3c a9					.word Mem_Peek                 ; $001c c@
>a186	6e a9					.word Mem_Poke                 ; $001d c!
>a188	52 a9					.word Mem_WPeek                ; $001e @
>a18a	83 a9					.word Mem_WPoke                ; $001f !
>a18c	a1 a9					.word Mem_DWPoke               ; $0020 d!
>a18e	bb a9					.word Mem_Alloc                ; $0021 alloc
>a190	49 aa					.word Command_Store            ; $0022 ^
>a192	d2 a1					.word SyntaxError              ; $0023 [
>a194	d2 a1					.word SyntaxError              ; $0024 ]
>a196	da aa					.word Command_Sys              ; $0025 sys
>a198	fc aa					.word Command_DumpStack        ; $0026 ?
>a19a	17 ad					.word Unary_Absolute           ; $0027 abs
>a19c	20 ad					.word Unary_Negate             ; $0028 negate
>a19e	35 ad					.word Unary_Not                ; $0029 not
>a1a0	49 ad					.word Unary_Increment          ; $002a ++
>a1a2	55 ad					.word Unary_Decrement          ; $002b --
>a1a4	64 ad					.word Unary_BSwap              ; $002c bswap
>a1a6	76 ad					.word Unary_Shl                ; $002d <<
>a1a8	80 ad					.word Unary_Shr                ; $002e >>
>a1aa	8a ad					.word Unary_Sgn                ; $002f sgn
>a1ac	ad ad					.word Random_Handler           ; $0030 rnd
>a1ae	e9 a9					.word Stack_Empty              ; $0031 clr
>a1b0	ef a9					.word Stack_Drop               ; $0032 drop
>a1b2	f4 a9					.word Stack_Dup                ; $0033 dup
>a1b4	05 aa					.word Stack_Nip                ; $0034 nip
>a1b6	16 aa					.word Stack_Over               ; $0035 over
>a1b8	27 aa					.word Stack_Swap               ; $0036 swap
>a1ba	6e ae					.word Structure_Else           ; $0037 else
>a1bc	5f af					.word Struct_Index             ; $0038 index
>a1be	2b ae					.word Command_Return           ; $0039 ;
>a1c0	c3 aa					.word Command_Assert           ; $003a assert
>a1c2	74 a7					.word Cmd_List                 ; $003b list
>a1c4	88 aa					.word Command_New              ; $003c new
>a1c6	8f aa					.word Command_Old              ; $003d old
>a1c8	b9 aa					.word Command_Stop             ; $003e stop
>a1ca	2d a2					.word ExecuteProgram           ; $003f run
>a1cc	b5 aa					.word Command_End              ; $0040 end
>a1ce	d2 a1					.word SyntaxError              ; $0041 save
>a1d0	d2 a1					.word SyntaxError              ; $0042 load

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.a1d2					SyntaxError:
.a1d2	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a1d5	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.a1dc					ErrorHandler:
.a1dc	fa		plx				plx 								; pull address off.
.a1dd	7a		ply				ply
.a1de	e8		inx				inx 								; point to message
.a1df	d0 01		bne $a1e2			bne 	_EHNoCarry
.a1e1	c8		iny				iny
.a1e2					_EHNoCarry:
.a1e2	20 12 a2	jsr $a212			jsr 	PrintStringXY 				; print string at XY
.a1e5	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.a1e7	f0 13		beq $a1fc			beq 	_EHNoLine
.a1e9	a2 01		ldx #$01			ldx 	#_EHMessage & $FF 			; print " AT "
.a1eb	a0 a2		ldy #$a2			ldy 	#_EHMessage >> 8
.a1ed	20 12 a2	jsr $a212			jsr 	PrintStringXY
.a1f0	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.a1f2	b1 00		lda ($00),y			lda 	(codePtr),y
.a1f4	aa		tax				tax
.a1f5	c8		iny				iny
.a1f6	b1 00		lda ($00),y			lda 	(codePtr),y
.a1f8	a8		tay				tay
.a1f9	20 06 a2	jsr $a206			jsr 	PrintIntegerUnsigned
.a1fc					_EHNoLine:
.a1fc	80 fe		bra $a1fc			bra 	_EHNoLine
.a1fe	4c 54 a0	jmp $a054			jmp 	WarmStart
.a201					_EHMessage:
>a201	20 41 54 20 00					.text	" AT ",0
.a206					PrintIntegerUnsigned:
.a206	20 3c a5	jsr $a53c			jsr 	IntToString
.a209	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.a20b	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.a20d	20 12 a2	jsr $a212			jsr 	PrintStringXY
.a210	98		tya				tya
.a211	60		rts				rts
.a212					PrintStringXY:
.a212	86 02		stx $02				stx 	zTemp0
.a214	84 03		sty $03				sty 	zTemp0+1
.a216	a0 00		ldy #$00			ldy 	#0
.a218	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.a21a	f0 06		beq $a222			beq 	_PSExit
.a21c	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a21f	c8		iny				iny
.a220	80 f6		bra $a218			bra 	_PSLoop
.a222	60		rts		_PSExit:rts
.a223					PrintCharacter:
.a223	48		pha				pha
.a224	da		phx				phx
.a225	5a		phy				phy
.a226	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a229	7a		ply				ply
.a22a	fa		plx				plx
.a22b	68		pla				pla
.a22c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.a22d					ExecuteProgram:
.a22d	20 6f a4	jsr $a46f			jsr 	StackReset 					; reset the CPU stack.
.a230	20 37 a4	jsr $a437			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.a233	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.a235	80 0a		bra $a241			bra 	ExecuteLoop
.a237					ShortConstant:
.a237	c8		iny				iny 								; skip short const
.a238	e8		inx				inx 								; space on stack
.a239	29 3f		and #$3f			and 	#$3F 						; the value
.a23b	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.a23e	9e 00 07	stz $0700,x			stz 	highStack,x
.a241					ExecuteLoop:
.a241	e6 14		inc $14				inc 	breakCount 					; check break sometimes.
.a243	d0 03		bne $a248			bne 	_EXNoBreak
.a245	20 fc a2	jsr $a2fc			jsr 	ExternCheckBreak
.a248					_EXNoBreak:
.a248	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.a24a	f0 58		beq $a2a4			beq 	_ELUnderflow
.a24c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.a24e	30 07		bmi $a257			bmi 	_ELNotToken
.a250	c8		iny				iny 								; skip the token
.a251	da		phx				phx 								; save X on the stack
.a252	0a		asl a				asl 	a 							; double the token, put into X
.a253	aa		tax				tax
.a254	7c 4c a1	jmp ($a14c,x)			jmp 	(DispatchHandler,x)
.a257					_ELNotToken:
.a257	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.a259	90 dc		bcc $a237			bcc 	ShortConstant 				; yes, it's a short constant
.a25b	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.a25d	90 1e		bcc $a27d			bcc 	_ELNotFastVariable
.a25f	c8		iny				iny 								; get the next token.
.a260	b1 00		lda ($00),y			lda 	(codePtr),y
.a262	88		dey				dey
.a263	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.a265	f0 16		beq $a27d			beq 	_ELNotFastVariable 			; which we can optimise.
.a267	5a		phy				phy 								; save Y
.a268	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.a26a	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.a26b	a8		tay				tay 								; access via Y
.a26c	e8		inx				inx 								; make space on the stack.
.a26d	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.a270	9d 00 06	sta $0600,x			sta 	lowStack,x
.a273	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.a276	9d 00 07	sta $0700,x			sta 	highStack,x
.a279	7a		ply				ply 								; restore code pointer
.a27a	c8		iny				iny 								; skip variable.
.a27b	80 c4		bra $a241			bra 	ExecuteLoop
.a27d					_ELNotFastVariable:
.a27d	18		clc				clc									; do not autocreate if not found.
.a27e	20 87 a5	jsr $a587			jsr 	VariableFind				; find the variable.
.a281	90 14		bcc $a297			bcc 	_ELUnknown
.a283	20 dd a3	jsr $a3dd			jsr 	IndexCheck
.a286	5a		phy				phy 								; copy to stack
.a287	e8		inx				inx
.a288	b2 02		lda ($02)			lda 	(zTemp0)
.a28a	9d 00 06	sta $0600,x			sta 	lowStack,x
.a28d	a0 01		ldy #$01			ldy 	#1
.a28f	b1 02		lda ($02),y			lda 	(zTemp0),y
.a291	9d 00 07	sta $0700,x			sta 	highStack,x
.a294	7a		ply				ply
.a295	80 aa		bra $a241			bra 	ExecuteLoop
.a297					_ELUnknown:
>a297	ff						.byte 	$FF
.a298	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a29b	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>a2a3	00
.a2a4					_ELUnderflow:
.a2a4	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a2a7	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.a2ae					ExecuteNextLine:
.a2ae					ExecuteComment:
.a2ae	fa		plx				plx
.a2af	18		clc				clc 								; skip forward
.a2b0	b2 00		lda ($00)			lda 	(codePtr)
.a2b2	18		clc				clc
.a2b3	65 00		adc $00				adc 	codePtr
.a2b5	85 00		sta $00				sta 	codePtr
.a2b7	90 02		bcc $a2bb			bcc 	_ENLNoCarry
.a2b9	e6 01		inc $01				inc 	codePtr+1
.a2bb					_ENLNoCarry:
.a2bb	a0 03		ldy #$03			ldy 	#3 							; start of next line
.a2bd	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.a2bf	d0 80		bne $a241			bne 	ExecuteLoop
.a2c1	4c b5 aa	jmp $aab5			jmp	 	Command_End 				; if zero end program.
.a2c4					LongConstant:
.a2c4	fa		plx				plx
.a2c5	e8		inx				inx 								; space for constant
.a2c6	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.a2c8	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2cb	c8		iny				iny
.a2cc	b1 00		lda ($00),y			lda 	(codePtr),y
.a2ce	9d 00 07	sta $0700,x			sta 	highStack,x
.a2d1	c8		iny				iny
.a2d2	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a2d5					StringConstant:
.a2d5	fa		plx				plx
.a2d6	e8		inx				inx
.a2d7	18		clc				clc 								; copy Y + codePtr in.
.a2d8	98		tya				tya
.a2d9	65 00		adc $00				adc 	codePtr
.a2db	9d 00 06	sta $0600,x			sta 	lowStack,x
.a2de	a5 01		lda $01				lda 	codePtr+1
.a2e0	69 00		adc #$00			adc 	#0
.a2e2	9d 00 07	sta $0700,x			sta 	highStack,x
.a2e5	98		tya				tya 								; add 1 + length to Y
.a2e6	38		sec				sec
.a2e7	71 00		adc ($00),y			adc 	(codePtr),y
.a2e9	a8		tay				tay
.a2ea	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.a2ed					ExternInitialise:
.a2ed	a9 07		lda #$07			lda 	#$07 						; set colour
.a2ef	8d 86 02	sta $0286			sta 	646
.a2f2	a9 93		lda #$93			lda 	#147 						; clear screen
.a2f4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2f7	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a2f9	4c 1a a3	jmp $a31a			jmp 	ExternColour
.a2fc					ExternCheckBreak:
.a2fc	da		phx				phx 								; make sure we keep XY
.a2fd	5a		phy				phy
.a2fe	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a301	f0 03		beq $a306			beq		_ECBExit 					; stopped
.a303	7a		ply				ply 								; restore and exit.
.a304	fa		plx				plx
.a305	60		rts				rts
.a306					_ECBExit:
.a306	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a309	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a310					ExternPrint:
.a310	48		pha				pha
.a311	da		phx				phx
.a312	5a		phy				phy
.a313	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a316	7a		ply				ply
.a317	fa		plx				plx
.a318	68		pla				pla
.a319	60		rts				rts
.a31a					ExternColour:
.a31a	48		pha				pha
.a31b	da		phx				phx
.a31c	48		pha				pha
.a31d	29 08		and #$08			and 	#8
.a31f	0a		asl a				asl 	a
.a320	0a		asl a				asl 	a
.a321	0a		asl a				asl 	a
.a322	0a		asl a				asl 	a
.a323	49 92		eor #$92			eor 	#$92
.a325	20 10 a3	jsr $a310			jsr 	ExternPrint
.a328	a9 0e		lda #$0e			lda 	#14							; lower case
.a32a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a32d	68		pla				pla
.a32e	29 07		and #$07			and 	#7
.a330	aa		tax				tax
.a331	bd 3a a3	lda $a33a,x			lda 	_ECTable,x
.a334	20 10 a3	jsr $a310			jsr 	ExternPrint
.a337	fa		plx				plx
.a338	68		pla				pla
.a339	60		rts				rts
.a33a					_ECTable:
>a33a	90						.byte 	144
>a33b	1c						.byte 	28
>a33c	1e						.byte 	30
>a33d	9e						.byte 	158
>a33e	1f						.byte 	31
>a33f	9c						.byte 	156
>a340	9f						.byte 	159
>a341	05						.byte 	5
.a342					ExternInput:
.a342	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a344	85 02		sta $02				sta 	zTemp0
.a346	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.a348	85 03		sta $03				sta 	zTemp0+1
.a34a	a9 07		lda #$07			lda 	#COL_WHITE
.a34c	20 1a a3	jsr $a31a			jsr 	ExternColour
.a34f	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a352	29 7f		and #$7f			and 	#$7F
.a354	c9 0d		cmp #$0d			cmp 	#13
.a356	f0 0a		beq $a362			beq 	_EIExit
.a358	92 02		sta ($02)			sta 	(zTemp0)
.a35a	e6 02		inc $02				inc 	zTemp0
.a35c	d0 f1		bne $a34f			bne 	_EIRead
.a35e	e6 03		inc $03				inc 	zTemp0+1
.a360	80 ed		bra $a34f			bra 	_EIRead
.a362	a9 00		lda #$00	_EIExit:lda 	#0
.a364	92 02		sta ($02)			sta 	(zTemp0)
.a366	a9 0d		lda #$0d			lda 	#13
.a368	20 10 a3	jsr $a310			jsr 	ExternPrint
.a36b	60		rts				rts
.a36c					ExternSave:
.a36c	da		phx				phx
.a36d	5a		phy				phy
.a36e	85 06		sta $06				sta 	zTemp2 						; save start
.a370	84 07		sty $07				sty 	zTemp2+1
.a372	20 d4 a3	jsr $a3d4			jsr 	EXGetLength 				; get length of file into A
.a375	a6 02		ldx $02				ldx 	zTemp0
.a377	a4 03		ldy $03				ldy 	zTemp0+1
.a379	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a37c	a9 01		lda #$01			lda 	#1
.a37e	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a380	a0 00		ldy #$00			ldy 	#0
.a382	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a385	a6 04		ldx $04				ldx 	zTemp1 						; end address
.a387	a4 05		ldy $05				ldy 	zTemp1+1
.a389	a9 06		lda #$06			lda 	#zTemp2
.a38b	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a38e	b0 03		bcs $a393			bcs 	_ESSave
.a390	7a		ply				ply
.a391	fa		plx				plx
.a392	60		rts				rts
.a393					_ESSave:
.a393	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a396	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a39e	4c 45 44 00
.a3a2					ExternLoad:
.a3a2	da		phx				phx 								; save XY
.a3a3	5a		phy				phy
.a3a4	48		pha				pha 								; save target
.a3a5	5a		phy				phy
.a3a6	20 d4 a3	jsr $a3d4			jsr 	EXGetLength 				; get length of file into A
.a3a9	a6 02		ldx $02				ldx 	zTemp0
.a3ab	a4 03		ldy $03				ldy 	zTemp0+1
.a3ad	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a3b0	a9 01		lda #$01			lda 	#1
.a3b2	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a3b4	a0 00		ldy #$00			ldy 	#0
.a3b6	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a3b9	7a		ply				ply 								; restore target to YX and call load
.a3ba	fa		plx				plx
.a3bb	a9 00		lda #$00			lda 	#0 							; load command
.a3bd	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a3c0	b0 03		bcs $a3c5			bcs 	_ESLoad
.a3c2	7a		ply				ply
.a3c3	fa		plx				plx
.a3c4	60		rts				rts
.a3c5					_ESLoad:
.a3c5	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a3c8	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a3d0	4c 45 44 00
.a3d4					EXGetLength:
.a3d4	a0 ff		ldy #$ff			ldy 	#255
.a3d6	c8		iny		_EXGL:	iny
.a3d7	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3d9	d0 fb		bne $a3d6			bne 	_EXGL
.a3db	98		tya				tya
.a3dc	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.a3dd					IndexCheck:
.a3dd	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.a3df	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a3e1	f0 01		beq $a3e4			beq 	_ICFound
.a3e3	60		rts				rts
.a3e4					_ICFound:
.a3e4	c8		iny				iny 							; get next
.a3e5	b1 00		lda ($00),y			lda 	(codePtr),y
.a3e7	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.a3e9	f0 2b		beq $a416			beq 	_ICStackIndex
.a3eb	38		sec				sec
.a3ec	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.a3ee	c9 40		cmp #$40			cmp 	#$40
.a3f0	b0 1a		bcs $a40c			bcs 	_ICError
.a3f2	0a		asl a				asl 	a 						; double index clear carry
.a3f3	5a		phy				phy 							; put into Y
.a3f4	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.a3f6	48		pha				pha
.a3f7	a0 01		ldy #$01			ldy 	#1
.a3f9	b1 02		lda ($02),y			lda 	(zTemp0),y
.a3fb	69 00		adc #$00			adc 	#0
.a3fd	85 03		sta $03				sta 	zTemp0+1
.a3ff	68		pla				pla
.a400	85 02		sta $02				sta 	zTemp0
.a402	7a		ply				ply 							; restore position.
.a403	c8		iny				iny								; skip index
.a404	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.a406	c8		iny				iny
.a407	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.a409	d0 01		bne $a40c			bne 	_ICError
.a40b	60		rts				rts
.a40c					_ICError:
.a40c	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a40f	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.a416					_ICStackIndex:
.a416	c8		iny				iny 							; skip the ]
.a417	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.a41a	0a		asl a				asl 	a
.a41b	85 04		sta $04				sta 	zTemp1
.a41d	bd 00 07	lda $0700,x			lda 	highStack,x
.a420	2a		rol a				rol 	a
.a421	85 05		sta $05				sta 	zTemp1+1
.a423	ca		dex				dex 							; throw TOS.
.a424	5a		phy				phy
.a425	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.a427	b2 02		lda ($02)			lda 	(zTemp0)
.a429	65 04		adc $04				adc 	zTemp1
.a42b	48		pha				pha
.a42c	b1 02		lda ($02),y			lda 	(zTemp0),y
.a42e	65 05		adc $05				adc 	zTemp1+1
.a430	85 03		sta $03				sta 	zTemp0+1
.a432	68		pla				pla
.a433	85 02		sta $02				sta 	zTemp0
.a435	7a		ply				ply 							; restore pos and exit.
.a436	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.a437					ResetMemory:
.a437	a9 00		lda #$00			lda 	#(highMemory) & $FF
.a439	85 0d		sta $0d				sta 	allocPtr
.a43b	a9 9f		lda #$9f			lda 	#(highMemory) >> 8
.a43d	85 0e		sta $0e				sta 	allocPtr+1
.a43f	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a441	85 0f		sta $0f				sta 	memVarPtr
.a443	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a445	85 10		sta $10				sta 	memVarPtr+1
.a447					_RMFindEnd:
.a447	b2 0f		lda ($0f)			lda 	(memVarPtr)					; offset 0, found end.
.a449	f0 0b		beq $a456			beq 	_RMFoundEnd 				; advance to next.
.a44b	18		clc				clc
.a44c	65 0f		adc $0f				adc 	memVarPtr
.a44e	85 0f		sta $0f				sta 	memVarPtr
.a450	90 f5		bcc $a447			bcc 	_RMFindEnd
.a452	e6 10		inc $10				inc 	memVarPtr+1
.a454	80 f1		bra $a447			bra 	_RMFindEnd
.a456					_RMFoundEnd:
.a456	e6 0f		inc $0f				inc 	memVarPtr 					; advance past last offset $00
.a458	d0 02		bne $a45c			bne 	_RMNoCarry
.a45a	e6 10		inc $10				inc 	memVarPtr+1
.a45c					_RMNoCarry:
.a45c	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.a45e					_RMEraseHash:
.a45e	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.a461	ca		dex				dex
.a462	10 fa		bpl $a45e			bpl 	_RMEraseHash
.a464	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a466	85 00		sta $00				sta 	codePtr
.a468	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a46a	85 01		sta $01				sta 	codePtr+1
.a46c	a0 03		ldy #$03			ldy 	#3
.a46e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.a46f					StackReset:
.a46f	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.a471	85 0a		sta $0a				sta 	iStack
.a473	a9 09		lda #$09			lda 	#IntStack >> 8
.a475	85 0b		sta $0b				sta 	iStack+1
.a477	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.a479	92 0a		sta ($0a)			sta 	(iStack)
.a47b	60		rts				rts
.a47c					StackPushByte:
.a47c	c6 0a		dec $0a				dec 	iStack
.a47e	92 0a		sta ($0a)			sta 	(iStack)
.a480	f0 01		beq $a483			beq 	_SPBUnderflow
.a482	60		rts				rts
.a483					_SPBUnderflow:
.a483	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a486	53 54 41 43 4b 00				.text 	"STACK",0
.a48c					StackPushPosition:
.a48c	98		tya				tya
.a48d	20 7c a4	jsr $a47c			jsr 	StackPushByte
.a490	a5 01		lda $01				lda 	codePtr+1
.a492	20 7c a4	jsr $a47c			jsr 	StackPushByte
.a495	a5 00		lda $00				lda 	codePtr
.a497	20 7c a4	jsr $a47c			jsr 	StackPushByte
.a49a	60		rts				rts
.a49b					StackCheckTop:
.a49b	d2 0a		cmp ($0a)			cmp 	(iStack)
.a49d	f0 02		beq $a4a1			beq 	_SCTOk
.a49f	18		clc				clc
.a4a0	60		rts				rts
.a4a1	38		sec		_SCTOk:	sec
.a4a2	60		rts				rts
.a4a3					StackPop:
.a4a3	18		clc				clc
.a4a4	65 0a		adc $0a				adc 	iStack
.a4a6	85 0a		sta $0a				sta 	iStack
.a4a8	60		rts				rts
.a4a9					StackRestorePosition:
.a4a9	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4ab	85 00		sta $00				sta 	codePtr
.a4ad	c8		iny				iny
.a4ae	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4b0	85 01		sta $01				sta 	codePtr+1
.a4b2	c8		iny				iny
.a4b3	b1 0a		lda ($0a),y			lda 	(iStack),y
.a4b5	a8		tay				tay
.a4b6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.a4b7					StringToInt:
.a4b7	86 08		stx $08				stx 	zTemp3 						; save string
.a4b9	84 09		sty $09				sty 	zTemp3+1
.a4bb	64 0c		stz $0c				stz 	signCount 					; signcount is the number of chars copied.
.a4bd	a2 10		ldx #$10			ldx 	#16 						; base to use.
.a4bf	a0 01		ldy #$01			ldy 	#1 							; character offset.
.a4c1	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.a4c3	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.a4c5	f0 03		beq $a4ca			beq 	_STIConvert 				; convert from character 1, base 16.
.a4c7	88		dey				dey 								; from character 0
.a4c8	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.a4ca					_STIConvert:
.a4ca	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.a4cc	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.a4ce	f0 5f		beq $a52f			beq 	_STIFail 					; if zero, then it has failed anyway.
.a4d0	64 02		stz $02				stz 	zTemp0 						; clear the result.
.a4d2	64 03		stz $03				stz 	zTemp0+1
.a4d4					_STILoop:
.a4d4	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.a4d6	c9 30		cmp #$30			cmp 	#"0"
.a4d8	90 55		bcc $a52f			bcc 	_STIFail
.a4da	c9 3a		cmp #$3a			cmp 	#"9"+1
.a4dc	90 08		bcc $a4e6			bcc 	_STIOkay
.a4de	c9 41		cmp #$41			cmp 	#"A"
.a4e0	90 4d		bcc $a52f			bcc 	_STIFail
.a4e2	c9 47		cmp #$47			cmp 	#"F"+1
.a4e4	b0 49		bcs $a52f			bcs 	_STIFail
.a4e6					_STIOkay:
.a4e6	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.a4e8	85 06		sta $06				sta 	zTemp2
.a4ea	a5 03		lda $03				lda 	zTemp0+1
.a4ec	85 07		sta $07				sta 	zTemp2+1
.a4ee	64 02		stz $02				stz 	zTemp0 						; clear result
.a4f0	64 03		stz $03				stz 	zTemp0+1
.a4f2	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.a4f4					_STIMultiply:
.a4f4	8a		txa				txa 								; shift Y right into carry.
.a4f5	4a		lsr a				lsr 	a
.a4f6	aa		tax				tax
.a4f7	90 0d		bcc $a506			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.a4f9	18		clc				clc
.a4fa	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.a4fc	65 02		adc $02				adc 	zTemp0
.a4fe	85 02		sta $02				sta 	zTemp0
.a500	a5 07		lda $07				lda 	zTemp2+1
.a502	65 03		adc $03				adc 	zTemp0+1
.a504	85 03		sta $03				sta 	zTemp0+1
.a506					_STINoAdd:
.a506	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.a508	26 07		rol $07				rol 	zTemp2+1
.a50a	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.a50c	d0 e6		bne $a4f4			bne 	_STIMultiply
.a50e	38		sec				sec 								; hex adjust
.a50f	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.a511	c9 3a		cmp #$3a			cmp 	#58
.a513	90 03		bcc $a518			bcc 	_STIDecimal
.a515	38		sec				sec
.a516	e9 07		sbc #$07			sbc 	#7
.a518					_STIDecimal:
.a518	38		sec				sec
.a519	e9 30		sbc #$30			sbc 	#48
.a51b	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.a51d	b0 10		bcs $a52f			bcs 	_STIFail
.a51f	d8		cld				cld
.a520	65 02		adc $02				adc 	zTemp0 						; add into the current value
.a522	85 02		sta $02				sta 	zTemp0
.a524	90 02		bcc $a528			bcc 	_STINoCarry
.a526	e6 03		inc $03				inc 	zTemp0+1
.a528					_STINoCarry:
.a528	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.a52a	c8		iny				iny 								; point to next
.a52b	e6 0c		inc $0c				inc 	SignCount
.a52d	80 a5		bra $a4d4			bra 	_STILoop 					; and go round again.
.a52f					_STIFail:
.a52f	a5 0c		lda $0c				lda 	SignCount 					; if converted 0 charactes, fail.
.a531	f0 07		beq $a53a			beq 	_STINoConvert
.a533	98		tya				tya 								; convert count in A.
.a534	a6 02		ldx $02				ldx 	zTemp0 						; return result
.a536	a4 03		ldy $03				ldy 	zTemp0+1
.a538	38		sec				sec
.a539	60		rts				rts
.a53a					_STINoConvert:
.a53a	18		clc				clc
.a53b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.a53c					IntToString:
.a53c	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.a53e	84 03		sty $03				sty 	zTemp0+1
.a540	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.a542	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.a544					_ITSLoop:
.a544	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.a546					_ITSSubtractLoop:
.a546	38		sec				sec
.a547	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.a549	fd 7f a5	sbc $a57f,x			sbc 	_ITSWords,x
.a54c	48		pha				pha
.a54d	a5 03		lda $03				lda 	zTemp0+1
.a54f	fd 80 a5	sbc $a580,x			sbc 	_ITSWords+1,x
.a552	90 09		bcc $a55d			bcc 	_ITSEndSub 					; can't subtract any more.
.a554	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.a556	68		pla				pla
.a557	85 02		sta $02				sta 	zTemp0
.a559	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.a55b	80 e9		bra $a546			bra 	_ITSSubtractLoop
.a55d					_ITSEndSub:
.a55d	68		pla				pla 								; throw away the interim result
.a55e	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.a560	d0 04		bne $a566			bne 	_ITSWriteOut 				; always write it out
.a562	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.a564	f0 06		beq $a56c			beq 	_ITSNext 					; suppressing leading zeros.
.a566					_ITSWriteOut:
.a566	09 30		ora #$30			ora 	#48 						; output digit.
.a568	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.a56b	c8		iny				iny
.a56c					_ITSNext:
.a56c	e8		inx				inx
.a56d	e8		inx				inx
.a56e	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.a570	d0 d2		bne $a544			bne 	_ITSLoop 					; do the new digits
.a572	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.a574	09 30		ora #$30			ora 	#48
.a576	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.a579	a9 00		lda #$00			lda 	#0
.a57b	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.a57e	60		rts				rts
.a57f					_ITSWords:
>a57f	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.a587					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.a587					VariableFind:
.a587	da		phx				phx 								; save the stack position
.a588	08		php				php 								; save the create flag
.a589	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.a58b	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.a58d	90 10		bcc $a59f			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.a58f	29 1f		and #$1f			and 	#$1F 						; make it an offset
.a591	0a		asl a				asl 	a 							; double clear carry
.a592	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.a594	85 02		sta $02				sta 	zTemp0
.a596	a9 0f		lda #$0f			lda		#FastVariables >>8
.a598	85 03		sta $03				sta 	zTemp0+1
.a59a	28		plp				plp 								; create flag is irrelevant.
.a59b	fa		plx				plx									; restore the old stack position
.a59c	c8		iny				iny 								; skip over the single identifier character
.a59d	38		sec				sec 								; return with CS
.a59e	60		rts				rts
.a59f					_VFIsNotFastVariable:
.a59f	20 62 a6	jsr $a662			jsr 	VFSetupHashPointer 			; set up the hash pointer
.a5a2	20 cc a5	jsr $a5cc			jsr 	VFSearch 					; try to find the variable.
.a5a5	b0 0d		bcs $a5b4			bcs 	_VFEndSearch 				; found it, so exit
.a5a7	28		plp				plp 								; do we want autocreate
.a5a8	b0 03		bcs $a5ad			bcs 	_VFCreate
.a5aa	fa		plx				plx 								; restore stack position and return CC
.a5ab	18		clc				clc
.a5ac	60		rts				rts
.a5ad					_VFCreate:
.a5ad	20 62 a6	jsr $a662			jsr 	VFSetupHashPointer 			; reset the hash pointer
.a5b0	20 08 a6	jsr $a608			jsr 	VFCreate 					; create a new record and link it in.
.a5b3	08		php				php 								; save a dummy P to be popped.
.a5b4					_VFEndSearch:
.a5b4	18		clc				clc 								; the data is at offset + 4
.a5b5	a5 04		lda $04				lda 	zTemp1
.a5b7	69 04		adc #$04			adc 	#4
.a5b9	85 02		sta $02				sta 	zTemp0
.a5bb	a5 05		lda $05				lda 	zTemp1+1
.a5bd	69 00		adc #$00			adc 	#0
.a5bf	85 03		sta $03				sta 	zTemp0+1
.a5c1	28		plp				plp 								; dump the create flag
.a5c2					_VFSkipExit:
.a5c2	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.a5c4	c8		iny				iny
.a5c5	c9 e0		cmp #$e0			cmp 	#$E0
.a5c7	90 f9		bcc $a5c2			bcc 	_VFSkipExit
.a5c9	fa		plx				plx 								; restore X
.a5ca	38		sec				sec
.a5cb	60		rts				rts
.a5cc					VFSearch:
.a5cc	48		pha				pha 								; save AXY.
.a5cd	da		phx				phx
.a5ce	5a		phy				phy
.a5cf	98		tya				tya									; add Y to codePtr, put in zTemp2
.a5d0	18		clc				clc 								; so it points to the identifier.
.a5d1	65 00		adc $00				adc 	codePtr
.a5d3	85 06		sta $06				sta 	zTemp2
.a5d5	a5 01		lda $01				lda 	codePtr+1
.a5d7	69 00		adc #$00			adc 	#0
.a5d9	85 07		sta $07				sta 	zTemp2+1
.a5db					_VFSLoop:
.a5db	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.a5dd	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.a5df	f0 22		beq $a603			beq 	_VFSFailed 					; failed.
.a5e1	aa		tax				tax 								; MSB in X
.a5e2	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.a5e4	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.a5e6	86 05		stx $05				stx 	zTemp1+1
.a5e8	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.a5ea	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5ec	85 08		sta $08				sta 	zTemp3
.a5ee	c8		iny				iny
.a5ef	b1 04		lda ($04),y			lda 	(zTemp1),y
.a5f1	85 09		sta $09				sta 	zTemp3+1
.a5f3	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.a5f5					_VFSCheckName:
.a5f5	c8		iny				iny
.a5f6	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.a5f8	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.a5fa	d0 df		bne $a5db			bne 	_VFSLoop
.a5fc	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.a5fe	90 f5		bcc $a5f5			bcc 	_VFSCheckName
.a600	38		sec				sec 								; return with Carry set, and zTemp1 set up
.a601	80 01		bra $a604			bra		_VFSExit
.a603					_VFSFailed:
.a603	18		clc				clc
.a604					_VFSExit:
.a604	7a		ply				ply 								; restore registers and exit.
.a605	fa		plx				plx
.a606	68		pla				pla
.a607	60		rts				rts
.a608					VFCreate:
.a608	48		pha				pha 								; save registers
.a609	da		phx				phx
.a60a	5a		phy				phy
.a60b	18		clc				clc 								; add 6 to memVarPtr, saving its
.a60c	a5 0f		lda $0f				lda 	memVarPtr 					; address in zTemp0 as we go.
.a60e	85 02		sta $02				sta 	zTemp0
.a610	69 06		adc #$06			adc 	#6
.a612	85 0f		sta $0f				sta 	memVarPtr
.a614	a5 10		lda $10				lda 	memVarPtr+1
.a616	85 03		sta $03				sta 	zTemp0+1
.a618	69 00		adc #$00			adc 	#0
.a61a	85 10		sta $10				sta 	memVarPtr+1
.a61c	c5 0e		cmp $0e				cmp 	allocPtr+1 					; out of memory ?
.a61e	f0 37		beq $a657			beq 	_VFCMemory
.a620	98		tya				tya 								; work out identifier address
.a621	18		clc				clc
.a622	65 00		adc $00				adc 	codePtr
.a624	48		pha				pha
.a625	c8		iny				iny
.a626	a5 01		lda $01				lda 	codePtr+1
.a628	69 00		adc #$00			adc 	#0
.a62a	a0 03		ldy #$03			ldy 	#3 							; store in new record
.a62c	91 02		sta ($02),y			sta 	(zTemp0),y
.a62e	88		dey				dey
.a62f	68		pla				pla
.a630	91 02		sta ($02),y			sta 	(zTemp0),y
.a632	a0 04		ldy #$04			ldy 	#4 							; clear new data
.a634	a9 00		lda #$00			lda 	#0
.a636	91 02		sta ($02),y			sta 	(zTemp0),y
.a638	c8		iny				iny
.a639	91 02		sta ($02),y			sta 	(zTemp0),y
.a63b	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.a63d	b2 04		lda ($04)			lda 	(zTemp1)
.a63f	92 02		sta ($02)			sta 	(zTemp0)
.a641	b1 04		lda ($04),y			lda 	(zTemp1),y
.a643	91 02		sta ($02),y			sta 	(zTemp0),y
.a645	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.a647	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.a649	a5 03		lda $03				lda 	zTemp0+1
.a64b	91 04		sta ($04),y			sta 	(zTemp1),y
.a64d	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.a64f	a5 02		lda $02				lda 	zTemp0
.a651	85 04		sta $04				sta 	zTemp1
.a653	7a		ply				ply
.a654	fa		plx				plx
.a655	68		pla				pla
.a656	60		rts				rts
.a657					_VFCMemory:
.a657	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a65a	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.a662					VFSetupHashPointer:
.a662	48		pha				pha
.a663	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a665	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.a667	0a		asl a				asl 	a 							; double it, also clears carry
.a668	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.a66a	85 04		sta $04				sta 	zTemp1
.a66c	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.a66e	85 05		sta $05				sta 	zTemp1+1
.a670	68		pla				pla
.a671	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.a672					TokeniseInputBuffer:
.a672	48		pha				pha
.a673	da		phx				phx
.a674	5a		phy				phy
.a675	64 15		stz $15				stz 	TokenOffset					; reset index into TokenBuffer
.a677	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.a67a	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.a67c					_TIBForward:
.a67c	e8		inx				inx
.a67d	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a680	d0 fa		bne $a67c			bne 	_TIBForward
.a682					_TIBBackward:
.a682	ca		dex				dex 								; back one.
.a683	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.a685	f0 40		beq $a6c7			beq 	_TIBExit					; return empty buffer
.a687	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a68a	c9 20		cmp #$20			cmp 	#" "
.a68c	f0 f4		beq $a682			beq 	_TIBBackward
.a68e	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.a691	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.a693					_TIBMainLoop:
.a693	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.a696	f0 2f		beq $a6c7			beq 	_TIBExit 					; done the buffer if zero.
.a698	e8		inx				inx
.a699	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.a69b	f0 f6		beq $a693			beq 	_TIBMainLoop
.a69d	ca		dex				dex 								; undo the last inx.
.a69e	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.a6a0	f0 08		beq $a6aa			beq 	_TIBConstant
.a6a2	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.a6a4	90 09		bcc $a6af			bcc 	_TIBNotConstant
.a6a6	c9 3a		cmp #$3a			cmp 	#"9"+1
.a6a8	b0 05		bcs $a6af			bcs 	_TIBNotConstant
.a6aa					_TIBConstant:
.a6aa	20 fc a6	jsr $a6fc			jsr 	TOKConvertConstant
.a6ad	80 e4		bra $a693			bra 	_TIBMainLoop
.a6af					_TIBNotConstant:
.a6af	c9 3a		cmp #$3a			cmp 	#":"						; definition
.a6b1	d0 05		bne $a6b8			bne 	_TIBNotDefinition
.a6b3	20 4e a7	jsr $a74e			jsr 	TOKConvertDefinition
.a6b6	80 db		bra $a693			bra 	_TIBMainLoop
.a6b8					_TIBNotDefinition:
.a6b8	c9 27		cmp #$27			cmp 	#"'"
.a6ba	f0 04		beq $a6c0			beq 	_TIBIsCommentString
.a6bc	c9 22		cmp #$22			cmp 	#'"'
.a6be	d0 06		bne $a6c6			bne 	_TIBNotCommentString
.a6c0					_TIBIsCommentString:
>a6c0	ff						.byte 	$FF
.a6c1	20 74 a7	jsr $a774			jsr 	TOKConvertCommentString
.a6c4	80 cd		bra $a693			bra 	_TIBMainLoop
.a6c6					_TIBNotCommentString:
>a6c6	ff						.byte 	$FF
.a6c7					_TIBExit:
.a6c7	7a		ply				ply
.a6c8	fa		plx				plx
.a6c9	68		pla				pla
.a6ca	60		rts				rts
.a6cb					TOKWriteToken:
.a6cb	da		phx				phx
.a6cc	a6 15		ldx $15				ldx 	TokenOffset
.a6ce	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.a6d1	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.a6d4	e6 15		inc $15				inc 	TokenOffset
.a6d6	fa		plx				plx
.a6d7	60		rts				rts
.a6d8					TOKFixUpLast:
.a6d8	da		phx				phx
.a6d9	a6 15		ldx $15				ldx 	TokenOffset
.a6db	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.a6de	09 e0		ora #$e0			ora 	#$E0
.a6e0	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.a6e3	fa		plx				plx
.a6e4	60		rts				rts
.a6e5					TOKConvertIdentifier:
.a6e5	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.a6e7	f0 0f		beq $a6f8			beq 	_TKCIDot
.a6e9	38		sec				sec 								; A-Z -> 1-27
.a6ea	e9 40		sbc #$40			sbc 	#64
.a6ec	f0 08		beq $a6f6			beq 	_TKCIFail
.a6ee	c9 1b		cmp #$1b			cmp 	#27
.a6f0	b0 04		bcs $a6f6			bcs 	_TKCIFail
.a6f2	09 c0		ora #$c0			ora 	#$C0 						; fix up
.a6f4	38		sec				sec
.a6f5	60		rts				rts
.a6f6					_TKCIFail:
.a6f6	18		clc				clc
.a6f7	60		rts				rts
.a6f8					_TKCIDot:
.a6f8	a9 db		lda #$db			lda 	#$C0+27
.a6fa	38		sec				sec
.a6fb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.a6fc					TOKConvertConstant:
.a6fc	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.a6fe	da		phx				phx 								; save X position
.a6ff	20 b7 a4	jsr $a4b7			jsr 	StringToInt 				; try to convert
.a702	90 40		bcc $a744			bcc 	_TKCCError
.a704	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.a706	86 02		stx $02				stx 	zTemp0
.a708	85 04		sta $04				sta 	zTemp1 						; save count
.a70a	68		pla				pla 								; restore X position, add the count
.a70b	18		clc				clc
.a70c	65 04		adc $04				adc 	zTemp1
.a70e	aa		tax				tax
.a70f	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.a712	c9 2d		cmp #$2d			cmp 	#"-"
.a714	d0 0e		bne $a724			bne 	_TKCCNotNegative
.a716	e8		inx				inx 								; consume the -
.a717	38		sec				sec
.a718	a9 00		lda #$00			lda 	#0 							; negate the constant.
.a71a	e5 02		sbc $02				sbc 	zTemp0
.a71c	85 02		sta $02				sta 	zTemp0
.a71e	a9 00		lda #$00			lda 	#0
.a720	e5 03		sbc $03				sbc 	zTemp0+1
.a722	85 03		sta $03				sta 	zTemp0+1
.a724					_TKCCNotNegative:
.a724	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.a726	d0 0c		bne $a734			bne 	_TKCCLongConstant
.a728	a5 02		lda $02				lda 	zTemp0
.a72a	c9 40		cmp #$40			cmp 	#$40
.a72c	b0 06		bcs $a734			bcs 	_TKCCLongConstant
.a72e	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.a730	20 cb a6	jsr $a6cb			jsr 	TOKWriteToken
.a733	60		rts				rts
.a734					_TKCCLongConstant:
.a734	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.a736	20 cb a6	jsr $a6cb			jsr 	TOKWriteToken
.a739	a5 02		lda $02				lda 	zTemp0
.a73b	20 cb a6	jsr $a6cb			jsr 	TOKWriteToken
.a73e	a5 03		lda $03				lda 	zTemp0+1
.a740	20 cb a6	jsr $a6cb			jsr 	TOKWriteToken
.a743	60		rts				rts
.a744					_TKCCError:
.a744	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a747	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.a74e					TOKConvertDefinition:
.a74e	e8		inx				inx 								; skip over :
.a74f	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get first and check there's at least one.
.a752	20 e5 a6	jsr $a6e5			jsr 	TOKConvertIdentifier
.a755	90 10		bcc $a767			bcc 	_TKCDFail
.a757					_TKCDLoop:
.a757	20 cb a6	jsr $a6cb			jsr 	TOKWriteToken 				; write last one out
.a75a	e8		inx				inx									; skip over it, get next and check
.a75b	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.a75e	20 e5 a6	jsr $a6e5			jsr 	TOKConvertIdentifier
.a761	b0 f4		bcs $a757			bcs 	_TKCDLoop 					; keep going while identifier present.
.a763	20 d8 a6	jsr $a6d8			jsr 	TOKFixUpLast 				; set bit for last character.
.a766	60		rts				rts
.a767					_TKCDFail:
.a767	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a76a	4e 4f 44 45 46 49 4e 45				.text 	"NODEFINE?",0
>a772	3f 00

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.a774					TOKConvertCommentString:

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.a774					Cmd_List:
.a774	fa		plx				plx
.a775	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.a777	64 07		stz $07				stz 	zTemp2+1
.a779	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.a77b	f0 0b		beq $a788			beq 	_CLNoStart
.a77d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.a780	85 06		sta $06				sta 	zTemp2
.a782	bd 00 07	lda $0700,x			lda 	highStack,x
.a785	85 07		sta $07				sta 	zTemp2+1
.a787	ca		dex				dex
.a788					_CLNoStart:
.a788	a9 02		lda #$02			lda 	#COL_GREEN
.a78a	20 1a a3	jsr $a31a			jsr 	ExternColour
.a78d					_CLNoStartLine:
.a78d	a9 00		lda #$00			lda 	#(programStart) & $FF
.a78f	85 00		sta $00				sta 	codePtr
.a791	a9 10		lda #$10			lda 	#(programStart) >> 8
.a793	85 01		sta $01				sta 	codePtr+1
.a795					_CLILoop:
.a795	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a797	f0 24		beq $a7bd			beq 	_CLIEnd
.a799	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a79b	38		sec				sec
.a79c	b1 00		lda ($00),y			lda 	(codePtr),y
.a79e	e5 06		sbc $06				sbc 	zTemp2
.a7a0	c8		iny				iny
.a7a1	b1 00		lda ($00),y			lda 	(codePtr),y
.a7a3	e5 07		sbc $07				sbc 	zTemp2+1
.a7a5	90 09		bcc $a7b0			bcc 	_CLISkip
.a7a7	da		phx				phx
.a7a8	20 c0 a7	jsr $a7c0			jsr 	ListCurrent 				; list the line.
.a7ab	fa		plx				plx
.a7ac	c6 08		dec $08				dec 	zTemp3 						; done all lines
.a7ae	f0 0d		beq $a7bd			beq 	_CLIEnd
.a7b0					_CLISkip:
.a7b0	18		clc				clc
.a7b1	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a7b3	65 00		adc $00				adc 	codePtr
.a7b5	85 00		sta $00				sta 	codePtr
.a7b7	90 dc		bcc $a795			bcc 	_CLILoop
.a7b9	e6 01		inc $01				inc 	codePtr+1
.a7bb	80 d8		bra $a795			bra 	_CLILoop
.a7bd					_CLIEnd:
.a7bd	4c 54 a0	jmp $a054			jmp 	WarmStart
.a7c0					ListCurrent:
.a7c0	a0 01		ldy #$01			ldy 	#1							; print line#
.a7c2	b1 00		lda ($00),y			lda 	(codePtr),y
.a7c4	aa		tax				tax
.a7c5	c8		iny				iny
.a7c6	b1 00		lda ($00),y			lda 	(codePtr),y
.a7c8	a8		tay				tay
.a7c9	20 06 a2	jsr $a206			jsr 	PrintIntegerUnsigned
.a7cc	a8		tay				tay
.a7cd					_LCPadOut:
.a7cd	a9 20		lda #$20			lda 	#' '
.a7cf	20 10 a3	jsr $a310			jsr 	ExternPrint
.a7d2	c8		iny				iny
.a7d3	c0 06		cpy #$06			cpy 	#6
.a7d5	d0 f6		bne $a7cd			bne 	_LCPadOut
.a7d7	a0 03		ldy #$03			ldy 	#3 							; start here
.a7d9	64 13		stz $13				stz 	PrefixCharacter				; no prefix
.a7db					_LCLoop:
.a7db	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.a7dd	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a7df	f0 0b		beq $a7ec			beq 	_LCNoPrefix
.a7e1	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.a7e3	f0 07		beq $a7ec			beq 	_LCNoPrefix
.a7e5	a5 13		lda $13				lda 	PrefixCharacter 			; output prefix, reset to space
.a7e7	f0 03		beq $a7ec			beq		_LCNoPrefix
.a7e9	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a7ec					_LCNoPrefix:
.a7ec	a9 20		lda #$20			lda 	#32
.a7ee	85 13		sta $13				sta 	PrefixCharacter
.a7f0	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.a7f2	f0 13		beq $a807			beq 	_LCExit
.a7f4	10 4d		bpl $a843			bpl 	_LCIsToken 					; +ve goto token.
.a7f6	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.a7f8	b0 13		bcs $a80d			bcs 	_LCIsIdentifier
.a7fa	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.a7fc	aa		tax				tax
.a7fd	c8		iny				iny
.a7fe	5a		phy				phy 								; push pos
.a7ff	a0 00		ldy #$00			ldy 	#0
.a801	20 06 a2	jsr $a206			jsr 	PrintIntegerUnsigned
.a804	7a		ply				ply
.a805	80 d4		bra $a7db			bra 	_LCLoop
.a807					_LCExit:
.a807	a9 0d		lda #$0d			lda 	#13
.a809	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a80c	60		rts				rts
.a80d					_LCIsIdentifier:
.a80d					_LCIdentLoop:
.a80d	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.a80f	20 f9 a8	jsr $a8f9			jsr 	ListPrintIDChar
.a812	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.a814	c8		iny				iny
.a815	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.a817	b0 c2		bcs $a7db			bcs 	_LCLoop 					; if so, do next
.a819	80 f2		bra $a80d			bra 	_LCIdentLoop				; if not loop round
.a81b					_LCConstant:
.a81b	c8		iny				iny
.a81c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.a81e	aa		tax				tax
.a81f	c8		iny				iny 								; get MSB into Y
.a820	b1 00		lda ($00),y			lda 	(codePtr),y
.a822	c8		iny				iny
.a823	5a		phy				phy
.a824	a8		tay				tay
.a825	5a		phy				phy 								; save sign
.a826	10 0c		bpl $a834			bpl 	_LCNotNegative
.a828	98		tya				tya 								; YX = |YX|
.a829	49 ff		eor #$ff			eor 	#$FF
.a82b	a8		tay				tay
.a82c	8a		txa				txa
.a82d	49 ff		eor #$ff			eor 	#$FF
.a82f	aa		tax				tax
.a830	e8		inx				inx
.a831	d0 01		bne $a834			bne 	_LCNotNegative
.a833	c8		iny				iny
.a834					_LCNotNegative:
.a834					_LCPrintYX:
.a834	20 06 a2	jsr $a206			jsr 	PrintIntegerUnsigned
.a837	68		pla				pla 								; restore sign
.a838	10 05		bpl $a83f			bpl 	_LCNoTrail
.a83a	a9 2d		lda #$2d			lda 	#"-"
.a83c	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a83f					_LCNoTrail:
.a83f	7a		ply				ply 								; restore Y
.a840	4c db a7	jmp $a7db			jmp 	_LCLoop
.a843					_LCIsToken:
.a843	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.a845	f0 d4		beq $a81b			beq 	_LCConstant
.a847	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.a849	90 3e		bcc $a889			bcc 	_LCControl
.a84b					_LCIsKeywordToken:
.a84b	85 02		sta $02				sta 	zTemp0 						; save token #
.a84d	a9 57		lda #$57			lda 	#(KeywordText) & $FF
.a84f	85 04		sta $04				sta 	zTemp1
.a851	a9 a0		lda #$a0			lda 	#(KeywordText) >> 8
.a853	85 05		sta $05				sta 	zTemp1+1
.a855	5a		phy				phy 								; save code offset
.a856					_LCForward:
.a856	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.a858	f0 0f		beq $a869			beq 	_LCFoundToken
.a85a	c6 02		dec $02				dec 	zTemp0						; dec count.
.a85c	38		sec				sec 								; go to next keyword.
.a85d	b2 04		lda ($04)			lda 	(zTemp1)
.a85f	65 04		adc $04				adc 	zTemp1
.a861	85 04		sta $04				sta 	zTemp1
.a863	90 f1		bcc $a856			bcc 	_LCForward
.a865	e6 05		inc $05				inc 	zTemp1+1
.a867	80 ed		bra $a856			bra 	_LCForward
.a869					_LCFoundToken:
.a869	a0 01		ldy #$01			ldy 	#1 							; output the token.
.a86b					_LCOutToken:
.a86b	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.a86d	29 7f		and #$7f			and 	#$7F
.a86f	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a872	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.a874	c8		iny				iny
.a875	0a		asl a				asl 	a
.a876	90 f3		bcc $a86b			bcc 	_LCOutToken
.a878	7a		ply				ply 								; restore code offset
.a879	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.a87b	c8		iny				iny
.a87c	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.a87e	f0 04		beq $a884			beq 	_LCCancelPrefix
.a880	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.a882	d0 02		bne $a886			bne 	_LCGoLoop
.a884					_LCCancelPrefix:
.a884	64 13		stz $13				stz 	PrefixCharacter
.a886					_LCGoLoop:
.a886	4c db a7	jmp $a7db			jmp 	_LCLoop
.a889					_LCControl:
.a889	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.a88b	f0 2c		beq $a8b9			beq 	_LCDecodeCall
.a88d	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a88f	f0 1d		beq $a8ae			beq 	_LCDecodeDefine
.a891	5a		phy				phy 								; save Y
.a892	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.a894	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.a896	f0 02		beq $a89a			beq 	_LCDecodeString
.a898	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.a89a					_LCDecodeString
.a89a	98		tya				tya
.a89b	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a89e	7a		ply				ply 								; restore Y pos
.a89f	48		pha				pha 								; save end character on stack.
.a8a0	20 d9 a8	jsr $a8d9			jsr 	ListPrintCodeIdentifier
.a8a3	68		pla				pla 								; last character
.a8a4	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.a8a6	f0 03		beq $a8ab			beq 	_LCEDNoQuote
.a8a8	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a8ab					_LCEDNoQuote:
.a8ab	4c db a7	jmp $a7db			jmp 	_LCLoop
.a8ae					_LCDecodeDefine:
.a8ae	a9 3a		lda #$3a			lda 	#":"
.a8b0	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a8b3	20 d9 a8	jsr $a8d9			jsr 	ListPrintCodeIdentifier
.a8b6	4c db a7	jmp $a7db			jmp 	_LCLoop
.a8b9					_LCDecodeCall:
.a8b9	c8		iny				iny 								; get line number into XA
.a8ba	b1 00		lda ($00),y			lda 	(codePtr),y
.a8bc	48		pha				pha
.a8bd	c8		iny				iny
.a8be	b1 00		lda ($00),y			lda 	(codePtr),y
.a8c0	c8		iny				iny
.a8c1	aa		tax				tax
.a8c2	68		pla				pla
.a8c3	20 0b a9	jsr $a90b			jsr 	ListFindLine 				; find that line.
.a8c6	90 10		bcc $a8d8			bcc 	_LCNoDefinition
.a8c8	5a		phy				phy
.a8c9	a0 03		ldy #$03			ldy 	#3 							; look at first character
.a8cb	b1 02		lda ($02),y			lda 	(zTemp0),y
.a8cd	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.a8cf	d0 07		bne $a8d8			bne 	_LCNoDefinition 			; not define
.a8d1	20 e3 a8	jsr $a8e3			jsr 	ListPrintIdentifier
.a8d4	7a		ply				ply
.a8d5	4c db a7	jmp $a7db			jmp 	_LCLoop
.a8d8					_LCNoDefinition:
>a8d8	ff						.byte 	$FF 						; definition is missing.
.a8d9					ListPrintCodeIdentifier:
.a8d9	48		pha				pha 								; copy codePtr -> zTemp0
.a8da	a5 00		lda $00				lda 	codePtr
.a8dc	85 02		sta $02				sta 	zTemp0
.a8de	a5 01		lda $01				lda 	codePtr+1
.a8e0	85 03		sta $03				sta 	zTemp0+1
.a8e2	68		pla				pla
.a8e3					ListPrintIdentifier:
.a8e3	48		pha				pha
.a8e4	da		phx				phx
.a8e5	c8		iny				iny 								; skip over the type
.a8e6	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.a8e8	aa		tax				tax
.a8e9					_LPILoop:
.a8e9	c8		iny				iny
.a8ea	e0 00		cpx #$00			cpx 	#0
.a8ec	f0 08		beq $a8f6			beq 	_LPIExit
.a8ee	b1 02		lda ($02),y			lda 	(zTemp0),y
.a8f0	20 f9 a8	jsr $a8f9			jsr 	ListPrintIDChar
.a8f3	ca		dex				dex
.a8f4	80 f3		bra $a8e9			bra 	_LPILoop
.a8f6					_LPIExit:
.a8f6	fa		plx				plx
.a8f7	68		pla				pla
.a8f8	60		rts				rts
.a8f9					ListPrintIDChar:
.a8f9	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.a8fb	10 0a		bpl $a907			bpl	 	_LCNotDot
.a8fd	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.a8ff	09 40		ora #$40			ora 	#$40 						; ASCII except .
.a901	c9 5b		cmp #$5b			cmp 	#$40+27
.a903	d0 02		bne $a907			bne 	_LCNotDot
.a905	a9 2e		lda #$2e			lda 	#"."
.a907					_LCNotDot:
.a907	20 23 a2	jsr $a223			jsr 	PrintCharacter
.a90a	60		rts				rts
.a90b					ListFindLine:
.a90b	5a		phy				phy
.a90c	86 05		stx $05				stx 	zTemp1+1
.a90e	85 04		sta $04				sta 	zTemp1
.a910	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.a912	85 02		sta $02				sta 	zTemp0
.a914	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.a916	85 03		sta $03				sta 	zTemp0+1
.a918					_LFLSearch:
.a918	18		clc				clc									; reached the end.
.a919	b2 02		lda ($02)			lda 	(zTemp0)
.a91b	f0 1d		beq $a93a			beq 	_LFLExit 					; exit with CC
.a91d	a0 01		ldy #$01			ldy 	#1
.a91f	a5 04		lda $04				lda 	zTemp1
.a921	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a923	d0 07		bne $a92c			bne 	_LFLNext
.a925	c8		iny				iny
.a926	a5 05		lda $05				lda 	zTemp1+1
.a928	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.a92a	f0 0d		beq $a939			beq 	_LFLFound
.a92c					_LFLNext:
.a92c	18		clc				clc
.a92d	b2 02		lda ($02)			lda 	(zTemp0)
.a92f	65 02		adc $02				adc 	zTemp0
.a931	85 02		sta $02				sta 	zTemp0
.a933	90 e3		bcc $a918			bcc 	_LFLSearch
.a935	e6 03		inc $03				inc 	zTemp0+1
.a937	80 df		bra $a918			bra 	_LFLSearch
.a939					_LFLFound:
.a939	38		sec				sec
.a93a					_LFLExit:
.a93a	7a		ply				ply
.a93b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.a93c					Mem_Peek:
.a93c	fa		plx				plx
.a93d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a940	85 02		sta $02				sta 	zTemp0
.a942	bd 00 07	lda $0700,x			lda 	highStack,x
.a945	85 03		sta $03				sta 	zTemp0+1
.a947	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a949	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a94c	9e 00 07	stz $0700,x			stz 	highStack,x
.a94f	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a952					Mem_WPeek:
.a952	fa		plx				plx
.a953	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a956	85 02		sta $02				sta 	zTemp0
.a958	bd 00 07	lda $0700,x			lda 	highStack,x
.a95b	85 03		sta $03				sta 	zTemp0+1
.a95d	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.a95f	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.a962	5a		phy				phy 								; read msb
.a963	a0 01		ldy #$01			ldy 	#1
.a965	b1 02		lda ($02),y			lda 	(zTemp0),y
.a967	7a		ply				ply
.a968	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.a96b	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a96e					Mem_Poke:
.a96e	fa		plx				plx
.a96f	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a972	85 02		sta $02				sta 	zTemp0
.a974	bd 00 07	lda $0700,x			lda 	highStack,x
.a977	85 03		sta $03				sta 	zTemp0+1
.a979	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a97c	92 02		sta ($02)			sta 	(zTemp0)
.a97e	ca		dex				dex
.a97f	ca		dex				dex
.a980	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a983					Mem_WPoke:
.a983	fa		plx				plx
.a984	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a987	85 02		sta $02				sta 	zTemp0
.a989	bd 00 07	lda $0700,x			lda 	highStack,x
.a98c	85 03		sta $03				sta 	zTemp0+1
.a98e	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a991	92 02		sta ($02)			sta 	(zTemp0)
.a993	5a		phy				phy
.a994	a0 01		ldy #$01			ldy 	#1
.a996	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.a999	91 02		sta ($02),y			sta 	(zTemp0),y
.a99b	7a		ply				ply
.a99c	ca		dex				dex
.a99d	ca		dex				dex
.a99e	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a9a1					Mem_DWPoke:
.a9a1	fa		plx				plx
.a9a2	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.a9a5	85 02		sta $02				sta 	zTemp0
.a9a7	bd 00 07	lda $0700,x			lda 	highStack,x
.a9aa	85 03		sta $03				sta 	zTemp0+1
.a9ac	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.a9af	92 02		sta ($02)			sta 	(zTemp0)
.a9b1	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.a9b4	92 02		sta ($02)			sta 	(zTemp0)
.a9b6	ca		dex				dex
.a9b7	ca		dex				dex
.a9b8	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a9bb					Mem_Alloc:
.a9bb	fa		plx				plx
.a9bc	38		sec				sec 								; subtract count from alloc ptr
.a9bd	a5 0d		lda $0d				lda 	allocPtr
.a9bf	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.a9c2	85 0d		sta $0d				sta 	allocPtr
.a9c4	48		pha				pha 								; save low.
.a9c5	a5 0e		lda $0e				lda 	allocPtr+1
.a9c7	fd 00 07	sbc $0700,x			sbc 	highStack,x
.a9ca	85 0e		sta $0e				sta 	allocPtr+1
.a9cc	90 10		bcc $a9de			bcc 	_MAError 					; borrow ?
.a9ce	c5 10		cmp $10				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.a9d0	90 0c		bcc $a9de			bcc 	_MAError
.a9d2	f0 0a		beq $a9de			beq 	_MAError
.a9d4	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.a9d7	68		pla				pla
.a9d8	9d 00 06	sta $0600,x			sta 	lowStack,x
.a9db	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a9de					_MAError:
.a9de	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>a9e1	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.a9e9					Stack_Empty:
.a9e9	fa		plx				plx
.a9ea	a2 00		ldx #$00			ldx 	#0
.a9ec	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a9ef					Stack_Drop:
.a9ef	fa		plx				plx
.a9f0	ca		dex				dex
.a9f1	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.a9f4					Stack_Dup:
.a9f4	fa		plx				plx
.a9f5	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.a9f8	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.a9fb	bd 00 07	lda $0700,x			lda 	highStack,x
.a9fe	9d 01 07	sta $0701,x			sta 	highStack+1,x
.aa01	e8		inx				inx 								; bump stack pointer
.aa02	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aa05					Stack_Nip:
.aa05	fa		plx				plx
.aa06	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.aa09	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.aa0c	bd 00 07	lda $0700,x			lda 	highStack,x
.aa0f	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.aa12	ca		dex				dex 								; drop tos
.aa13	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aa16					Stack_Over:
.aa16	fa		plx				plx
.aa17	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.aa1a	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.aa1d	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.aa20	9d 01 07	sta $0701,x			sta 	highStack+1,x
.aa23	e8		inx				inx 							; bump stack pointer
.aa24	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aa27					Stack_Swap:
.aa27	fa		plx				plx
.aa28	5a		phy				phy
.aa29	bd 00 06	lda $0600,x			lda 	lowStack,x
.aa2c	a8		tay				tay
.aa2d	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.aa30	9d 00 06	sta $0600,x			sta 	lowStack,x
.aa33	98		tya				tya
.aa34	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.aa37	bd 00 07	lda $0700,x			lda 	highStack,x
.aa3a	a8		tay				tay
.aa3b	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.aa3e	9d 00 07	sta $0700,x			sta 	highStack,x
.aa41	98		tya				tya
.aa42	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.aa45	7a		ply				ply
.aa46	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.aa49					Command_Store:
.aa49	fa		plx				plx
.aa4a	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.aa4c	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.aa4e	90 1f		bcc $aa6f			bcc 	_CSLongVariable
.aa50	c8		iny				iny 								; get the next
.aa51	b1 00		lda ($00),y			lda 	(codePtr),y
.aa53	88		dey				dey
.aa54	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.aa56	f0 17		beq $aa6f			beq 	_CSLongVariable
.aa58	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.aa5a	c8		iny				iny 								; skip over it and push on stack
.aa5b	5a		phy				phy
.aa5c	0a		asl a				asl 	a 							; double it, now C0-FE
.aa5d	a8		tay				tay 								; put in Y
.aa5e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.aa61	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.aa64	bd 00 07	lda $0700,x			lda 	highStack,x
.aa67	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.aa6a	ca		dex				dex 								; pop off stack
.aa6b	7a		ply				ply 								; restore position and do next
.aa6c	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aa6f					_CSLongVariable:
.aa6f	38		sec				sec 								; create variable if not found.
.aa70	20 87 a5	jsr $a587			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.aa73	20 dd a3	jsr $a3dd			jsr 	IndexCheck 					; check indexing.
.aa76	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.aa79	92 02		sta ($02)			sta 	(zTemp0)
.aa7b	5a		phy				phy
.aa7c	a0 01		ldy #$01			ldy 	#1
.aa7e	bd 00 07	lda $0700,x			lda 	highStack,x
.aa81	91 02		sta ($02),y			sta 	(zTemp0),y
.aa83	7a		ply				ply
.aa84	ca		dex				dex 								; pop off stack
.aa85	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.aa88					Command_New:
.aa88	fa		plx				plx
.aa89	9c 00 10	stz $1000			stz 	ProgramStart
.aa8c	4c 54 a0	jmp $a054			jmp 	WarmStart
.aa8f					Command_Old:
.aa8f	fa		plx				plx
.aa90	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.aa92	85 00		sta $00				sta 	codePtr
.aa94	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aa96	85 01		sta $01				sta 	codePtr+1
.aa98	a0 03		ldy #$03			ldy 	#3
.aa9a					_COAdvance:
.aa9a	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.aa9c	b0 0e		bcs $aaac			bcs		_COFail
.aa9e	20 c0 ae	jsr $aec0			jsr 	AdvanceInCode
.aaa1	b1 00		lda ($00),y			lda 	(codePtr),y
.aaa3	d0 f5		bne $aa9a			bne 	_COAdvance
.aaa5	c8		iny				iny 								; byte after end of line
.aaa6	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.aaa9					_CONotDeleted:
.aaa9	4c 54 a0	jmp $a054			jmp 	WarmStart
.aaac					_COFail:
.aaac	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>aaaf	43 41 4e 54 3f 00				.text 	"CANT?",0
.aab5					Command_End:
.aab5	fa		plx				plx
.aab6	4c 54 a0	jmp $a054			jmp 	WarmStart
.aab9					Command_Stop:
>aab9	ff						.byte 	$FF
.aaba	fa		plx				plx
.aabb	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>aabe	53 54 4f 50 00					.text 	"STOP",0
.aac3					Command_Assert:
.aac3	fa		plx				plx
.aac4	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.aac7	1d 00 07	ora $0700,x			ora 	highStack,x
.aaca	f0 04		beq $aad0			beq 	_CAFail
.aacc	ca		dex				dex 								; throw if not.
.aacd	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aad0					_CAFail:
.aad0	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>aad3	41 53 53 45 52 54 00				.text 	"ASSERT",0
.aada					Command_Sys:
.aada	fa		plx				plx
.aadb	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.aade	85 02		sta $02				sta 	zTemp0
.aae0	bd 00 07	lda $0700,x			lda 	highStack,x
.aae3	85 03		sta $03				sta 	zTemp0+1
.aae5	ca		dex				dex 								; pop tos
.aae6	da		phx				phx 								; save XY
.aae7	5a		phy				phy
.aae8	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.aaeb	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.aaee	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.aaf1	20 f9 aa	jsr $aaf9			jsr 	_CSCallInd
.aaf4	7a		ply				ply 								; restore XY
.aaf5	fa		plx				plx
.aaf6	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aaf9					_CSCallInd:
.aaf9	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.aafc					Command_DumpStack:
.aafc	fa		plx				plx
.aafd	da		phx				phx 								; save pos and sp
.aafe	5a		phy				phy
.aaff	86 0c		stx $0c				stx 	SignCount
.ab01	a2 ff		ldx #$ff			ldx 	#$FF
.ab03					_CDSLoop:
.ab03	e4 0c		cpx $0c				cpx 	SignCount 					; done all ?
.ab05	f0 2a		beq $ab31			beq 	_CDSExit
.ab07	e8		inx				inx
.ab08	da		phx				phx 								; save SP
.ab09	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.ab0c	a8		tay				tay
.ab0d	bd 00 06	lda $0600,x			lda 	lowStack,x
.ab10	aa		tax				tax
.ab11	c0 00		cpy #$00			cpy 	#0
.ab13	10 11		bpl $ab26			bpl 	_CDSPositive
.ab15	a9 2d		lda #$2d			lda 	#"-" 						; minus
.ab17	20 23 a2	jsr $a223			jsr 	PrintCharacter
.ab1a	98		tya				tya 								; negate YX
.ab1b	49 ff		eor #$ff			eor 	#$FF
.ab1d	a8		tay				tay
.ab1e	8a		txa				txa
.ab1f	49 ff		eor #$ff			eor 	#$FF
.ab21	aa		tax				tax
.ab22	e8		inx				inx
.ab23	d0 01		bne $ab26			bne 	_CDSPositive
.ab25	c8		iny				iny
.ab26					_CDSPositive:
.ab26	20 06 a2	jsr $a206			jsr 	PrintIntegerUnsigned
.ab29	a9 20		lda #$20			lda 	#" " 						; space
.ab2b	20 23 a2	jsr $a223			jsr 	PrintCharacter
.ab2e	fa		plx				plx
.ab2f	80 d2		bra $ab03			bra 	_CDSLoop
.ab31					_CDSExit:
.ab31	a9 3c		lda #$3c			lda 	#"<"
.ab33	20 23 a2	jsr $a223			jsr 	PrintCharacter
.ab36	20 23 a2	jsr $a223			jsr 	PrintCharacter
.ab39	a9 0d		lda #$0d			lda 	#13 						; CR
.ab3b	20 23 a2	jsr $a223			jsr 	PrintCharacter
.ab3e	7a		ply				ply
.ab3f	fa		plx				plx
.ab40	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.ab43					Stack_Add:
.ab43	fa		plx				plx
.ab44	ca		dex				dex
.ab45	18		clc				clc
.ab46	bd 00 06	lda $0600,x			lda		lowStack,x
.ab49	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.ab4c	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab4f	bd 00 07	lda $0700,x			lda		highStack,x
.ab52	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ab55	9d 00 07	sta $0700,x			sta 	highStack,x
.ab58	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ab5b					Stack_Sub:
.ab5b	fa		plx				plx
.ab5c	ca		dex				dex
.ab5d	38		sec				sec
.ab5e	bd 00 06	lda $0600,x			lda		lowStack,x
.ab61	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ab64	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab67	bd 00 07	lda $0700,x			lda		highStack,x
.ab6a	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ab6d	9d 00 07	sta $0700,x			sta 	highStack,x
.ab70	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ab73					Stack_And:
.ab73	fa		plx				plx
.ab74	ca		dex				dex
.ab75	bd 00 06	lda $0600,x			lda		lowStack,x
.ab78	3d 01 06	and $0601,x			and		lowStack+1,x
.ab7b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab7e	bd 00 07	lda $0700,x			lda		highStack,x
.ab81	3d 01 07	and $0701,x			and 	highStack+1,x
.ab84	9d 00 07	sta $0700,x			sta 	highStack,x
.ab87	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ab8a					Stack_Xor:
.ab8a	fa		plx				plx
.ab8b	ca		dex				dex
.ab8c	bd 00 06	lda $0600,x			lda		lowStack,x
.ab8f	5d 01 06	eor $0601,x			eor		lowStack+1,x
.ab92	9d 00 06	sta $0600,x			sta 	lowStack,x
.ab95	bd 00 07	lda $0700,x			lda		highStack,x
.ab98	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ab9b	9d 00 07	sta $0700,x			sta 	highStack,x
.ab9e	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.aba1					Stack_Or:
.aba1	fa		plx				plx
.aba2	ca		dex				dex
.aba3	bd 00 06	lda $0600,x			lda		lowStack,x
.aba6	1d 01 06	ora $0601,x			ora		lowStack+1,x
.aba9	9d 00 06	sta $0600,x			sta 	lowStack,x
.abac	bd 00 07	lda $0700,x			lda		highStack,x
.abaf	1d 01 07	ora $0701,x			ora 	highStack+1,x
.abb2	9d 00 07	sta $0700,x			sta 	highStack,x
.abb5	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.abb8					Stack_Shl:
.abb8	fa		plx				plx
.abb9	38		sec				sec
.abba	80 02		bra $abbe			bra 	StackShift
.abbc					Stack_Shr:
.abbc	fa		plx				plx
.abbd	18		clc				clc
.abbe					StackShift:
.abbe	08		php				php
.abbf	ca		dex				dex
.abc0	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.abc3	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.abc5	1d 01 07	ora $0701,x			ora 	highStack+1,x
.abc8	d0 19		bne $abe3			bne 	_SSZero
.abca					_SSLoop:
.abca	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.abcd	30 1a		bmi $abe9			bmi 	_SSDone 					; completed ?
.abcf	28		plp				plp 								; restore flag
.abd0	08		php				php
.abd1	b0 08		bcs $abdb			bcs 	_SSLeft 					; do either shift.
.abd3	5e 00 07	lsr $0700,x			lsr 	highStack,x
.abd6	7e 00 06	ror $0600,x			ror 	lowStack,x
.abd9	80 ef		bra $abca			bra 	_SSLoop
.abdb					_SSLeft:
.abdb	1e 00 06	asl $0600,x			asl 	lowStack,x
.abde	3e 00 07	rol $0700,x			rol 	highStack,x
.abe1	80 e7		bra $abca			bra 	_SSLoop
.abe3					_SSZero:
.abe3	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.abe6	9e 00 07	stz $0700,x			stz 	highStack,x
.abe9					_SSDone:
.abe9	28		plp				plp 								; throw flag.
.abea	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.abed					Comp_Equal:
.abed	fa		plx				plx
.abee	38		sec				sec
.abef	80 02		bra $abf3			bra 	Comp_CheckEqual
.abf1					Comp_NotEqual:
.abf1	fa		plx				plx
.abf2	18		clc				clc
.abf3					Comp_CheckEqual:
.abf3	08		php				php
.abf4	ca		dex				dex
.abf5	bd 00 06	lda $0600,x			lda		lowStack,x
.abf8	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.abfb	d0 06		bne $ac03			bne 	_CCENonZero
.abfd	bd 00 07	lda $0700,x			lda		highStack,x
.ac00	5d 01 07	eor $0701,x			eor 	highStack+1,x
.ac03					_CCENonZero:
.ac03	f0 02		beq $ac07			beq 	_CCENotSet
.ac05	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.ac07					_CCENotSet:
.ac07					CompCheckFlip:
.ac07	28		plp				plp 								; if carry set, we want $FF if equal
.ac08	90 02		bcc $ac0c			bcc 	CompReturn
.ac0a	49 ff		eor #$ff			eor 	#$FF
.ac0c					CompReturn:
.ac0c	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.ac0f	9d 00 07	sta $0700,x			sta 	highStack,x
.ac12	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ac15					Comp_Less:
.ac15	fa		plx				plx
.ac16	18		clc				clc
.ac17	80 02		bra $ac1b			bra 	Comp_LessCont
.ac19					Comp_GreaterEqual:
.ac19	fa		plx				plx
.ac1a	38		sec				sec
.ac1b					Comp_LessCont:
.ac1b	08		php				php
.ac1c	ca		dex				dex
.ac1d	38		sec				sec
.ac1e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.ac21	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ac24	bd 00 07	lda $0700,x			lda 	highStack,x
.ac27	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.ac2a	50 02		bvc $ac2e			bvc 	_CLNoFlip 					; unsigned -> signed
.ac2c	49 80		eor #$80			eor 	#$80
.ac2e					_CLNoFlip:
.ac2e	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ac30	f0 d5		beq $ac07			beq 	CompCheckFlip
.ac32	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ac34	80 d1		bra $ac07			bra 	CompCheckFlip
.ac36					Comp_LessEqual:
.ac36	fa		plx				plx
.ac37	38		sec				sec
.ac38	80 02		bra $ac3c			bra 	Comp_LessEqualCont
.ac3a					Comp_Greater:
.ac3a	fa		plx				plx
.ac3b	18		clc				clc
.ac3c					Comp_LessEqualCont:
.ac3c	08		php				php
.ac3d	ca		dex				dex
.ac3e	38		sec				sec
.ac3f	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.ac42	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ac45	bd 01 07	lda $0701,x			lda 	highStack+1,x
.ac48	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ac4b	50 02		bvc $ac4f			bvc 	_CLENoFlip 					; unsigned -> signed
.ac4d	49 80		eor #$80			eor 	#$80
.ac4f					_CLENoFlip:
.ac4f	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ac51	f0 b4		beq $ac07			beq 	CompCheckFlip
.ac53	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ac55	80 b0		bra $ac07			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.ac57					DivInteger16:
.ac57	fa		plx				plx
.ac58	20 5e ac	jsr $ac5e			jsr 	IntegerDivide
.ac5b	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ac5e					IntegerDivide:
.ac5e	ca		dex				dex
.ac5f	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.ac62	1d 01 07	ora $0701,x			ora 	highStack+1,x
.ac65	d0 14		bne $ac7b			bne 	_BFDOkay
.ac67	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>ac6a	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ac72	20 42 59 20 5a 45 52 4f 00
.ac7b					_BFDOkay:
.ac7b	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.ac7d	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.ac7f	64 0c		stz $0c				stz 	SignCount 					; Count of signs.
.ac81	20 bd ac	jsr $acbd			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ac84	e8		inx				inx
.ac85	20 bd ac	jsr $acbd			jsr 	CheckIntegerNegate
.ac88	ca		dex				dex
.ac89	5a		phy				phy 								; Y is the counter
.ac8a	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.ac8c					_BFDLoop:
.ac8c	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.ac8f	3e 00 07	rol $0700,x			rol 	highStack,x
.ac92	26 04		rol $04				rol 	zTemp1
.ac94	26 05		rol $05				rol 	zTemp1+1
.ac96	38		sec				sec
.ac97	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.ac99	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.ac9c	48		pha				pha
.ac9d	a5 05		lda $05				lda 	zTemp1+1
.ac9f	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.aca2	90 0f		bcc $acb3			bcc 	_BFDNoAdd
.aca4	85 05		sta $05				sta 	zTemp1+1
.aca6	68		pla				pla
.aca7	85 04		sta $04				sta 	zTemp1+0
.aca9	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.acac	09 01		ora #$01			ora 	#1
.acae	9d 00 06	sta $0600,x			sta 	lowStack,x
.acb1	80 01		bra $acb4			bra 	_BFDNext
.acb3					_BFDNoAdd:
.acb3	68		pla				pla 								; Throw away the intermediate calculations
.acb4					_BFDNext:
.acb4	88		dey				dey
.acb5	d0 d5		bne $ac8c			bne 	_BFDLoop
.acb7	7a		ply				ply 								; restore Y
.acb8	46 0c		lsr $0c				lsr 	SignCount 					; if sign count odd,
.acba	b0 07		bcs $acc3			bcs		IntegerNegateAlways 		; negate the result
.acbc	60		rts				rts
.acbd					CheckIntegerNegate:
.acbd	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.acc0	30 01		bmi $acc3			bmi 	IntegerNegateAlways 		; if so negate it
.acc2	60		rts				rts
.acc3					IntegerNegateAlways:
.acc3	e6 0c		inc $0c				inc 	SignCount 					; bump the count of signs
.acc5	4c 20 ad	jmp $ad20			jmp 	Unary_Negate
.acc8					ModInteger16:
.acc8	fa		plx				plx
.acc9	20 5e ac	jsr $ac5e			jsr 	IntegerDivide
.accc	a5 04		lda $04				lda 	zTemp1
.acce	9d 00 06	sta $0600,x			sta 	lowStack,x
.acd1	a5 05		lda $05				lda 	zTemp1+1
.acd3	9d 00 07	sta $0700,x			sta 	highStack,x
.acd6	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.acd9					MulInteger16:
.acd9	fa		plx				plx
.acda	ca		dex				dex
.acdb	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.acde	85 04		sta $04				sta 	zTemp1
.ace0	bd 00 07	lda $0700,x			lda 	highStack,x
.ace3	85 05		sta $05				sta 	zTemp1+1
.ace5	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.ace8	9e 00 07	stz $0700,x			stz 	highStack,x
.aceb					_BFMMultiply:
.aceb	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.aced	29 01		and #$01			and 	#1
.acef	f0 13		beq $ad04			beq 	_BFMNoAdd
.acf1	18		clc				clc 								; add old tos to current tos.
.acf2	bd 00 06	lda $0600,x			lda		lowStack,x
.acf5	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.acf8	9d 00 06	sta $0600,x			sta 	lowStack,x
.acfb	bd 00 07	lda $0700,x			lda		highStack,x
.acfe	7d 01 07	adc $0701,x			adc 	highStack+1,x
.ad01	9d 00 07	sta $0700,x			sta 	highStack,x
.ad04					_BFMNoAdd:
.ad04	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.ad07	3e 01 07	rol $0701,x			rol 	highStack+1,x
.ad0a	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.ad0c	66 04		ror $04				ror 	zTemp1+0
.ad0e	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.ad10	05 05		ora $05				ora 	zTemp1+1
.ad12	d0 d7		bne $aceb			bne 	_BFMMultiply
.ad14	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.ad17					Unary_Absolute:
.ad17	fa		plx				plx
.ad18	bd 00 07	lda $0700,x			lda 	highStack,x
.ad1b	30 04		bmi $ad21			bmi 	Unary_Negate_Code
.ad1d	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad20					Unary_Negate:
.ad20	fa		plx				plx
.ad21					Unary_Negate_Code:
.ad21	38		sec				sec
.ad22	a9 00		lda #$00			lda		#0
.ad24	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.ad27	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad2a	a9 00		lda #$00			lda		#0
.ad2c	fd 00 07	sbc $0700,x			sbc 	highStack,x
.ad2f	9d 00 07	sta $0700,x			sta 	highStack,x
.ad32	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad35					Unary_Not:
.ad35	fa		plx				plx
.ad36	bd 00 06	lda $0600,x			lda 	lowStack,x
.ad39	49 ff		eor #$ff			eor 	#$FF
.ad3b	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad3e	bd 00 07	lda $0700,x			lda 	highStack,x
.ad41	49 ff		eor #$ff			eor 	#$FF
.ad43	9d 00 07	sta $0700,x			sta 	highStack,x
.ad46	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad49					Unary_Increment:
.ad49	fa		plx				plx
.ad4a	fe 00 06	inc $0600,x			inc 	lowStack,x
.ad4d	d0 03		bne $ad52			bne 	_UIExit
.ad4f	fe 00 07	inc $0700,x			inc 	highStack,x
.ad52					_UIExit:
.ad52	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad55					Unary_Decrement:
.ad55	fa		plx				plx
.ad56	bd 00 06	lda $0600,x			lda 	lowStack,x
.ad59	d0 03		bne $ad5e			bne 	_UDNoBorrow
.ad5b	de 00 07	dec $0700,x			dec 	highStack,x
.ad5e					_UDNoBorrow:
.ad5e	de 00 06	dec $0600,x			dec 	lowStack,x
.ad61	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad64					Unary_BSwap:
.ad64	fa		plx				plx
.ad65	bd 00 06	lda $0600,x			lda 	lowStack,x
.ad68	48		pha				pha
.ad69	bd 00 07	lda $0700,x			lda 	highStack,x
.ad6c	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad6f	68		pla				pla
.ad70	9d 00 07	sta $0700,x			sta 	highStack,x
.ad73	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad76					Unary_Shl:
.ad76	fa		plx				plx
.ad77	1e 00 06	asl $0600,x			asl 	lowStack,x
.ad7a	3e 00 07	rol $0700,x			rol 	highStack,x
.ad7d	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad80					Unary_Shr:
.ad80	fa		plx				plx
.ad81	5e 00 07	lsr $0700,x			lsr 	highStack,x
.ad84	7e 00 06	ror $0600,x			ror 	lowStack,x
.ad87	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ad8a					Unary_Sgn:
.ad8a	fa		plx				plx
.ad8b	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.ad8e	10 0a		bpl $ad9a			bpl 	_USNotNeg
.ad90	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.ad92	9d 00 06	sta $0600,x			sta 	lowStack,x
.ad95	9d 00 07	sta $0700,x			sta 	highStack,x
.ad98	80 10		bra $adaa			bra 	_USExit
.ad9a					_USNotNeg:
.ad9a	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.ad9d	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.ada0	9e 00 07	stz $0700,x			stz 	highStack,x
.ada3	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.ada5	f0 03		beq $adaa			beq 	_USExit
.ada7	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.adaa					_USExit:
.adaa	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.adad					Random_Handler:
.adad	fa		plx				plx
.adae	a5 11		lda $11				lda 	randomSeed
.adb0	05 12		ora $12				ora 	randomSeed+1
.adb2	d0 08		bne $adbc			bne 	_RH_NoInit
.adb4	a9 7c		lda #$7c			lda 	#$7C
.adb6	85 11		sta $11				sta 	randomSeed
.adb8	a9 a1		lda #$a1			lda 	#$A1
.adba	85 12		sta $12				sta 	randomSeed+1
.adbc					_RH_NoInit:
.adbc	a5 11		lda $11				lda 	randomSeed
.adbe	4a		lsr a		        lsr		a
.adbf	26 12		rol $12		        rol 	randomSeed+1
.adc1	90 02		bcc $adc5	        bcc 	_RH_NoEor
.adc3	49 b4		eor #$b4	        eor 	#$B4
.adc5					_RH_NoEor:
.adc5	85 11		sta $11		        sta 	randomSeed
.adc7	45 12		eor $12		        eor 	randomSeed+1
.adc9	e8		inx		        inx
.adca	9d 00 07	sta $0700,x	        sta 	highStack,x
.adcd	a5 11		lda $11		        lda 	randomSeed
.adcf	9d 00 06	sta $0600,x	        sta 	lowStack,x
.add2	4c 41 a2	jmp $a241			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.add5					Command_Call:
.add5	fa		plx				plx
.add6	20 8c a4	jsr $a48c			jsr 	StackPushPosition 				; save stack position
.add9	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.addb	20 7c a4	jsr $a47c			jsr 	StackPushByte
.adde	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.ade0	85 02		sta $02				sta 	zTemp0
.ade2	c8		iny				iny
.ade3	b1 00		lda ($00),y			lda 	(codePtr),y
.ade5	85 03		sta $03				sta 	zTemp0+1
.ade7	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.ade9	85 00		sta $00				sta 	codePtr
.adeb	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.aded	85 01		sta $01				sta 	codePtr+1
.adef	a0 01		ldy #$01			ldy 	#1
.adf1					_CCSearch:
.adf1	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.adf3	f0 2d		beq $ae22			beq		_CCFail
.adf5	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.adf7	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.adf9	f0 0d		beq $ae08			beq 	_CCCheckMSB
.adfb	18		clc				clc 									; forward to next line.
.adfc	b2 00		lda ($00)			lda 	(codePtr)
.adfe	65 00		adc $00				adc 	codePtr
.ae00	85 00		sta $00				sta 	codePtr
.ae02	90 ed		bcc $adf1			bcc 	_CCSearch
.ae04	e6 01		inc $01				inc 	codePtr+1
.ae06	80 e9		bra $adf1			bra 	_CCSearch
.ae08					_CCCheckMSB:
.ae08	c8		iny				iny 									; get MSB, keeping Y as 1
.ae09	b1 00		lda ($00),y			lda 	(codePtr),y
.ae0b	88		dey				dey
.ae0c	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.ae0e	d0 e1		bne $adf1			bne 	_CCSearch
.ae10	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.ae12	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.ae14	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.ae16	d0 0a		bne $ae22			bne 	_CCFail
.ae18	c8		iny				iny 									; get the length of this.
.ae19	b1 00		lda ($00),y			lda 	(codePtr),y
.ae1b	18		clc				clc
.ae1c	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.ae1e	a8		tay				tay
.ae1f	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ae22					_CCFail:
.ae22	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>ae25	43 41 4c 4c 3f 00				.text 	"CALL?",0
.ae2b					Command_Return:
.ae2b	fa		plx				plx
.ae2c	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.ae2e	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.ae31	90 0f		bcc $ae42			bcc 	_CRFail
.ae33	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.ae35	20 a9 a4	jsr $a4a9			jsr 	StackRestorePosition
.ae38	c8		iny				iny
.ae39	c8		iny				iny
.ae3a	a9 04		lda #$04			lda 	#4 								; pop off stack
.ae3c	20 a3 a4	jsr $a4a3			jsr 	StackPop
.ae3f	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ae42					_CRFail:
.ae42	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>ae45	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.ae4b					Structure_If:
.ae4b	fa		plx				plx
.ae4c	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.ae4e	20 7c a4	jsr $a47c			jsr 	StackPushByte
.ae51	18		clc				clc
.ae52	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.ae55	1d 00 07	ora $0700,x			ora 	highStack,x
.ae58	ca		dex				dex 									; drop TOS
.ae59	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.ae5b	d0 0e		bne $ae6b			bne 	_SIFNoSkip 						; at this level.
.ae5d	da		phx				phx
.ae5e	a9 37		lda #$37			lda 	#KWD_ELSE
.ae60	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.ae62	20 98 ae	jsr $ae98			jsr 	StructSkipForward
.ae65	fa		plx				plx 									; restore X
.ae66	c9 37		cmp #$37			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.ae68	d0 01		bne $ae6b			bne 	_SIFNoSkip 						; clause.
.ae6a	c8		iny				iny
.ae6b					_SIFNoSkip:
.ae6b	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ae6e					Structure_Else:
.ae6e	fa		plx				plx
.ae6f	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ae71	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.ae74	90 0b		bcc $ae81			bcc 	SIFail
.ae76	da		phx				phx 									; got here by executing IF clause so skip
.ae77	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.ae79	aa		tax				tax
.ae7a	20 98 ae	jsr $ae98			jsr 	StructSkipForward
.ae7d	fa		plx				plx
.ae7e	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ae81					SIFail:
.ae81	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>ae84	49 46 3f 00					.text 	"IF?",0
.ae88					Structure_Endif:
.ae88	fa		plx				plx
.ae89	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.ae8b	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.ae8e	90 f1		bcc $ae81			bcc 	SIFail
.ae90	a9 01		lda #$01			lda 	#1 								; throw it.
.ae92	20 a3 a4	jsr $a4a3			jsr 	StackPop
.ae95	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.ae98					StructSkipForward:
.ae98	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.ae9a	86 03		stx $03				stx 	zTemp0+1
.ae9c	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.ae9e					_SSFLoop:
.ae9e	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.aea0	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.aea2	d0 08		bne $aeac			bne		_SSFFail
.aea4	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.aea6	f0 17		beq $aebf			beq 	_SSFEnd
.aea8	c5 03		cmp $03				cmp 	zTemp0+1
.aeaa	f0 13		beq $aebf			beq 	_SSFEnd
.aeac					_SSFFail:
.aeac	20 c0 ae	jsr $aec0			jsr 	AdvanceInCode 					; skip over in code.
.aeaf	b0 ed		bcs $ae9e			bcs 	_SSFLoop 						; if not end of program, keep going.
.aeb1	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>aeb4	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>aebc	45 3f 00
.aebf					_SSFEnd:
.aebf	60		rts				rts
.aec0					AdvanceInCode:
.aec0	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.aec2	f0 28		beq $aeec			beq 	_AICEndOfLine 					; end of line.
.aec4	c8		iny				iny 									; advance one.
.aec5	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.aec7	90 10		bcc $aed9			bcc 	_AICControl
.aec9	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.aecb	b0 0a		bcs $aed7			bcs 	_AICExit
.aecd	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.aecf	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.aed1	90 04		bcc $aed7			bcc 	_AICExit
.aed3	c6 04		dec $04				dec 	zTemp1
.aed5	c6 04		dec $04				dec 	zTemp1
.aed7					_AICExit:
.aed7	38		sec				sec
.aed8	60		rts				rts
.aed9					_AICControl:
.aed9	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.aedb	f0 0b		beq $aee8			beq 	_AICThree
.aedd	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.aedf	f0 07		beq $aee8			beq 	_AICThree
.aee1	98		tya				tya										; skip over a string/comment/define.
.aee2	38		sec				sec
.aee3	71 00		adc ($00),y			adc 	(codePtr),y
.aee5	a8		tay				tay
.aee6	38		sec				sec
.aee7	60		rts				rts
.aee8					_AICThree:
.aee8	c8		iny				iny
.aee9	c8		iny				iny
.aeea	38		sec				sec
.aeeb	60		rts				rts
.aeec					_AICEndOfLine:
.aeec	18		clc				clc 									; forward to next line.
.aeed	b2 00		lda ($00)			lda 	(codePtr)
.aeef	65 00		adc $00				adc 	codePtr
.aef1	85 00		sta $00				sta 	codePtr
.aef3	90 02		bcc $aef7			bcc 	_AICNoCarry
.aef5	e6 01		inc $01				inc 	codePtr+1
.aef7					_AICNoCarry:
.aef7	a0 03		ldy #$03			ldy 	#3 								; start of new line
.aef9	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.aefb	d0 da		bne $aed7			bne 	_AICExit
.aefd	18		clc				clc 									; program end.
.aefe	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.aeff					Struct_Repeat:
.aeff	fa		plx				plx
.af00	20 8c a4	jsr $a48c			jsr 	StackPushPosition 				; save stack position
.af03	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.af05	20 7c a4	jsr $a47c			jsr 	StackPushByte
.af08	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.af0b					Struct_Until:
.af0b	fa		plx				plx
.af0c	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.af0e	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.af11	90 1b		bcc $af2e			bcc 	_SUFail
.af13	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.af16	1d 00 07	ora $0700,x			ora 	highStack,x
.af19	ca		dex				dex
.af1a	09 00		ora #$00			ora 	#0
.af1c	f0 08		beq $af26			beq 	_SULoopBack 					; if so keep going.
.af1e	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.af20	20 a3 a4	jsr $a4a3			jsr 	StackPop
.af23	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.af26					_SULoopBack:
.af26	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.af28	20 a9 a4	jsr $a4a9			jsr 	StackRestorePosition
.af2b	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.af2e					_SUFail:
.af2e	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>af31	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>af39	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.af3b					Struct_For:
.af3b	fa		plx				plx
.af3c	18		clc				clc
.af3d	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.af40	49 ff		eor #$ff			eor 	#$FF
.af42	69 01		adc #$01			adc 	#1
.af44	08		php				php
.af45	20 7c a4	jsr $a47c			jsr 	StackPushByte
.af48	bd 00 07	lda $0700,x			lda 	highStack,x
.af4b	49 ff		eor #$ff			eor 	#$FF
.af4d	28		plp				plp
.af4e	69 00		adc #$00			adc 	#0
.af50	20 7c a4	jsr $a47c			jsr 	StackPushByte
.af53	ca		dex				dex 									; throw TOS
.af54	20 8c a4	jsr $a48c			jsr 	StackPushPosition 				; save stack position
.af57	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.af59	20 7c a4	jsr $a47c			jsr 	StackPushByte
.af5c	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.af5f					Struct_Index:
.af5f	fa		plx				plx
.af60	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.af62	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.af65	90 43		bcc $afaa			bcc 	SNFail
.af67	e8		inx				inx 									; new stack entry
.af68	5a		phy				phy
.af69	a0 04		ldy #$04			ldy 	#4 								; access index value
.af6b	b1 0a		lda ($0a),y			lda 	(iStack),y
.af6d	49 ff		eor #$ff			eor 	#$FF
.af6f	9d 00 07	sta $0700,x			sta 	highStack,x
.af72	c8		iny				iny
.af73	b1 0a		lda ($0a),y			lda 	(iStack),y
.af75	49 ff		eor #$ff			eor 	#$FF
.af77	9d 00 06	sta $0600,x			sta 	lowStack,x
.af7a	7a		ply				ply 									; restore code pointer
.af7b	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.af7e					Struct_Next:
.af7e	fa		plx				plx
.af7f	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.af81	20 9b a4	jsr $a49b			jsr 	StackCheckTop
.af84	90 24		bcc $afaa			bcc 	SNFail
.af86	5a		phy				phy 									; save code position
.af87	a0 05		ldy #$05			ldy 	#5 								; bump the count
.af89	b1 0a		lda ($0a),y			lda 	(iStack),y
.af8b	1a		inc a				inc 	a
.af8c	91 0a		sta ($0a),y			sta 	(iStack),y
.af8e	d0 11		bne $afa1			bne 	_SNLoopBack
.af90	88		dey				dey
.af91	b1 0a		lda ($0a),y			lda 	(iStack),y
.af93	1a		inc a				inc 	a
.af94	91 0a		sta ($0a),y			sta 	(iStack),y
.af96	d0 09		bne $afa1			bne 	_SNLoopBack  					; non-zero loop back.
.af98	7a		ply				ply 									; restore code position.
.af99	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.af9b	20 a3 a4	jsr $a4a3			jsr 	StackPop
.af9e	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.afa1					_SNLoopBack:
.afa1	7a		ply				ply 									; restore code position, being junked anyway.
.afa2	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.afa4	20 a9 a4	jsr $a4a9			jsr 	StackRestorePosition
.afa7	4c 41 a2	jmp $a241			jmp 	ExecuteLoop
.afaa					SNFail:
.afaa	20 dc a1	jsr $a1dc			jsr 	ErrorHandler
>afad	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
