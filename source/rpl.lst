
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl.prg -L rpl.lst main.asm
; Sun Dec 29 20:37:35 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$8000					BuildAddress = $8000 						; Build address
=$0f00					MemoryStart = $0F00 						; Main memory space here
=$7f00					HighMemory = $7F00							; Where memory ends
=$0600					StackAddress = $0600						; Stack (1/2k bytes)
=$0800					InputBuffer = $0800							; Input Buffer (must be on a page boundary)
=$09ff					IntStack = $09FF 							; Interpreter Stack
=$08e0					ConvertBuffer = $08E0 						; Conversion buffer (numbers)
=$0a00					TokenBuffer = $0A00 						; Tokenisation Buffer (must be on a page boundary)
=16					HashTableSize = 16 							; size of hash table (# entries)
>0000					CodePtr: 		.word ? 					; code pointer
>0002					zTemp0:			.word ?						; temporary words
>0004					zTemp1: 		.word ?
>0006					zTemp2: 		.word ?
>0008					zTemp3: 		.word ?
>000a					zTemp4:			.word ?
>000c					zTemp5:			.word ?
>000e					iStack:			.word ?						; stack pointer
>0010					signCount:		.byte ? 					; divide sign count.
>0011					allocPtr:		.word ? 					; memory allocation pointer (down)
>0013					memVarPtr:		.word ? 					; pointer for memory variables (up)
>0015					randomSeed:		.word ? 					; random number seed
>0017					prefixCharacter:.byte ?						; char to print before listed element.
>0018					breakCount:		.byte ? 					; counter avoids repeated break checks
>0019					tokenOffset:	.byte ? 					; position in output token buffer.
>001a					assemblerMode:	.byte ? 					; in assembler mode ?
>0f00					FastVariables:	.fill 	64 					; fast variable memory.
>0f40					VariableHashTable:.fill	HashTableSize * 2 	; hash tables (variables)
=4096					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0600					lowStack = StackAddress 					; low stack bytes
=1792					highStack = StackAddress+256				; high stack bytes
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8

;******  Return to file: main.asm


;******  Processing file: macros.inc


;******  Return to file: main.asm

.0e00	4c 00 80	jmp $8000			jmp 	Start

;******  Processing file: generated/program.inc

>1000	13 e8 03 03 0d 54 48 45			.byte	$13,$e8,$03,$03,$0d,$54,$48,$45,$20,$42,$41,$4c,$4c,$20,$44,$45,$4d,$4f,$00,$0c,$f2,$03,$23,$c3,$cc,$e3,$24,$02,$ec,$04,$00,$10,$fc,$03,$01,$00,$04,$21,$22,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$00,$0b,$06,$04,$a0,$22,$c3,$cf,$d5,$ce,$f4,$00,$0d,$10,$04,$01,$8e,$00,$22,$e1,$01,$d2,$ff,$25,$00,$12,$1a,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$56,$04,$0b,$00,$05,$24,$04,$07,$00,$12,$2e,$04,$c3,$cf,$d5,$ce,$f4,$08,$39,$02,$4c,$04,$02,$9c,$04,$0b,$00,$06,$38,$04,$80,$0a,$00,$05,$42,$04,$41,$00,$23,$4c,$04,$05,$0b,$c2,$c1,$cc,$cc,$db,$d3,$c5,$cc,$c5,$c3,$f4,$2e,$2e,$2e,$2e,$c2,$c1,$cc,$cc,$cd,$c5,$ed,$0f,$22,$c2,$c1,$cc,$ec,$3a,$00,$29,$56,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c9,$ce,$c9,$f4,$31,$28,$01,$50,$00,$0e,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$31,$28,$bc,$0e,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$2d,$60,$04,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$02,$6a,$04,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$31,$87,$11,$2b,$22,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$51,$00,$02,$74,$04,$3a,$00,$1c,$6a,$04,$05,$0b,$d2,$c1,$ce,$c4,$cf,$cd,$db,$d3,$c9,$c7,$ee,$31,$81,$11,$06,$81,$38,$01,$ff,$ff,$09,$3a,$00,$0f,$74,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$c4,$d2,$c1,$f7,$00,$10,$7e,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$2e,$01,$20,$9f,$1d,$00,$0f,$88,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$01,$21,$9f,$1d,$00,$19,$92,$04,$90,$01,$22,$9f,$1d,$01,$23,$9f,$1d,$c2,$c1,$cc,$ec,$23,$84,$24,$01,$23,$9f,$1d,$3a,$00,$0f,$9c,$04,$05,$09,$c2,$c1,$cc,$cc,$db,$cd,$cf,$d6,$e5,$00,$08,$a6,$04,$a0,$02,$74,$04,$00,$1c,$b0,$04,$c2,$c1,$cc,$ec,$23,$80,$24,$c2,$c1,$cc,$ec,$23,$82,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$80,$24,$00,$1f,$ba,$04,$34,$01,$50,$00,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$82,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$82,$24,$09,$00,$1c,$c4,$04,$c2,$c1,$cc,$ec,$23,$81,$24,$c2,$c1,$cc,$ec,$23,$83,$24,$0f,$34,$22,$c2,$c1,$cc,$ec,$23,$81,$24,$00,$1d,$ce,$04,$34,$bc,$1a,$37,$80,$19,$12,$06,$c2,$c1,$cc,$ec,$23,$83,$24,$29,$22,$c2,$c1,$cc,$ec,$23,$83,$24,$09,$00,$0a,$d8,$04,$01,$51,$00,$02,$74,$04,$00,$05,$e2,$04,$3a,$00,$15,$ec,$04,$05,$05,$c3,$cc,$c5,$c1,$f2,$80,$01,$20,$9f,$1f,$90,$01,$22,$9f,$1d,$00,$0a,$f6,$04,$01,$80,$00,$bc,$0c,$08,$00,$0e,$00,$05,$a0,$01,$23,$9f,$1d,$81,$01,$23,$9f,$1d,$00,$06,$0a,$05,$0b,$3a,$00
>1008	20 42 41 4c 4c 20 44 45 4d 4f 00 0c f2 03 23 c3
>1018	cc e3 24 02 ec 04 00 10 fc 03 01 00 04 21 22 c2
>1028	c1 cc cc cd c5 ed 00 0b 06 04 a0 22 c3 cf d5 ce
>1038	f4 00 0d 10 04 01 8e 00 22 e1 01 d2 ff 25 00 12
>1048	1a 04 c3 cf d5 ce f4 08 39 02 4c 04 02 56 04 0b
>1058	00 05 24 04 07 00 12 2e 04 c3 cf d5 ce f4 08 39
>1068	02 4c 04 02 9c 04 0b 00 06 38 04 80 0a 00 05 42
>1078	04 41 00 23 4c 04 05 0b c2 c1 cc cc db d3 c5 cc
>1088	c5 c3 f4 2e 2e 2e 2e c2 c1 cc cc cd c5 ed 0f 22
>1098	c2 c1 cc ec 3a 00 29 56 04 05 09 c2 c1 cc cc db
>10a8	c9 ce c9 f4 31 28 01 50 00 0e 22 c2 c1 cc ec 23
>10b8	80 24 31 28 bc 0e 22 c2 c1 cc ec 23 81 24 00 2d
>10c8	60 04 02 6a 04 22 c2 c1 cc ec 23 82 24 02 6a 04
>10d8	22 c2 c1 cc ec 23 83 24 31 87 11 2b 22 c2 c1 cc
>10e8	ec 23 84 24 01 51 00 02 74 04 3a 00 1c 6a 04 05
>10f8	0b d2 c1 ce c4 cf cd db d3 c9 c7 ee 31 81 11 06
>1108	81 38 01 ff ff 09 3a 00 0f 74 04 05 09 c2 c1 cc
>1118	cc db c4 d2 c1 f7 00 10 7e 04 c2 c1 cc ec 23 80
>1128	24 2e 01 20 9f 1d 00 0f 88 04 c2 c1 cc ec 23 81
>1138	24 01 21 9f 1d 00 19 92 04 90 01 22 9f 1d 01 23
>1148	9f 1d c2 c1 cc ec 23 84 24 01 23 9f 1d 3a 00 0f
>1158	9c 04 05 09 c2 c1 cc cc db cd cf d6 e5 00 08 a6
>1168	04 a0 02 74 04 00 1c b0 04 c2 c1 cc ec 23 80 24
>1178	c2 c1 cc ec 23 82 24 0f 34 22 c2 c1 cc ec 23 80
>1188	24 00 1f ba 04 34 01 50 00 1a 37 80 19 12 06 c2
>1198	c1 cc ec 23 82 24 29 22 c2 c1 cc ec 23 82 24 09
>11a8	00 1c c4 04 c2 c1 cc ec 23 81 24 c2 c1 cc ec 23
>11b8	83 24 0f 34 22 c2 c1 cc ec 23 81 24 00 1d ce 04
>11c8	34 bc 1a 37 80 19 12 06 c2 c1 cc ec 23 83 24 29
>11d8	22 c2 c1 cc ec 23 83 24 09 00 0a d8 04 01 51 00
>11e8	02 74 04 00 05 e2 04 3a 00 15 ec 04 05 05 c3 cc
>11f8	c5 c1 f2 80 01 20 9f 1f 90 01 22 9f 1d 00 0a f6
>1208	04 01 80 00 bc 0c 08 00 0e 00 05 a0 01 23 9f 1d
>1218	81 01 23 9f 1d 00 06 0a 05 0b 3a 00

;******  Return to file: main.asm

.8000					Start:
.8000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.8002	9a		txs				txs
.8003	20 ca 85	jsr $85ca			jsr 	ExternInitialise			; set up external stuff.
.8006	a2 61		ldx #$61			ldx 	#BootPrompt & $FF 			; print start up.
.8008	a0 80		ldy #$80			ldy 	#BootPrompt >> 8
.800a	20 d5 84	jsr $84d5			jsr 	PrintStringXY
.800d	a2 00		ldx #$00			ldx 	#(HighMemory-ProgramStart) & $FF
.800f	a0 6f		ldy #$6f			ldy 	#(HighMemory-ProgramStart) >> 8
.8011	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.8014	a2 7e		ldx #$7e			ldx 	#BootPrompt2 & $FF
.8016	a0 80		ldy #$80			ldy 	#BootPrompt2 >> 8
.8018	20 d5 84	jsr $84d5			jsr 	PrintStringXY
.801b					WarmStart:
.801b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.801d	9a		txs				txs
>801e	ff						.byte 	$FF
.801f	20 1f 86	jsr $861f			jsr 	ExternInput					; input a line.
.8022	48		pha				pha
.8023	20 41 8a	jsr $8a41			jsr 	TokeniseInputBuffer 		; tokenise it
.8026	68		pla				pla
.8027	c9 20		cmp #$20			cmp 	#" "						; if the first character is space always execute it
.8029	f0 0d		beq $8038			beq 	ExecuteLine
.802b	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; is the first thing a line number
.802e	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST
.8030	f0 0d		beq $803f			beq 	LineNumber
.8032	29 c0		and #$c0			and 	#$C0
.8034	c9 80		cmp #$80			cmp 	#$80
.8036	f0 07		beq $803f			beq 	LineNumber
.8038					ExecuteLine:
.8038	a2 00		ldx #$00			ldx 	#TokenBuffer & $FF
.803a	a0 0a		ldy #$0a			ldy 	#TokenBuffer >> 8
.803c	4c f4 84	jmp $84f4			jmp 	ExecuteFromXY
.803f					LineNumber:
.803f	ad 03 0a	lda $0a03			lda 	TokenBuffer+3 				; set up for short constant line#
.8042	a2 00		ldx #$00			ldx 	#0
.8044	a0 04		ldy #$04			ldy 	#4
.8046	38		sec				sec
.8047	e9 80		sbc #$80			sbc 	#$80
.8049	c9 40		cmp #$40			cmp 	#$40
.804b	90 08		bcc $8055			bcc 	_HaveLineNumber
.804d	ad 04 0a	lda $0a04			lda 	TokenBuffer+4
.8050	ae 05 0a	ldx $0a05			ldx 	TokenBuffer+5
.8053	a0 06		ldy #$06			ldy 	#6
.8055					_HaveLineNumber:
.8055	48		pha				pha 								; a fudge. Because you use
.8056	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; nnn list so much, this forces
.8059	c9 3c		cmp #$3c			cmp 	#KWD_LIST 					; this to be executed and not
.805b	f0 db		beq $8038			beq 	ExecuteLine 				; to be code.
.805d	68		pla				pla
.805e	4c 14 87	jmp $8714			jmp 	EditProgram
.8061					BootPrompt:
>8061	2a 2a 2a 20 52 50 4c 2f				.text 	"*** RPL/65 (19-NOV-19) ***",13,13
>8069	36 35 20 28 31 39 2d 4e 4f 56 2d 31 39 29 20 2a
>8079	2a 2a 0d 0d
>807d	00						.byte 	0
.807e					BootPrompt2:
>807e	20 42 59 54 45 53 20 41				.text 	" BYTES AVAILABLE.",13,13,0
>8086	56 41 49 4c 41 42 4c 45 2e 0d 0d 00

;******  Processing file: generated/rpl.inc

=$06					TOK_NOT_CONTROL = $06
=$06					TOK_STRUCT_INC = $06
=$09					TOK_STRUCT_DEC = $09
=$0c					TOK_STRUCT_NEUTRAL = $0c
=$0000					KWD_SYS_EOL                    = $0000 ; %eol
=$0001					KWD_SYS_CONST                  = $0001 ; %const
=$0002					KWD_SYS_CALL                   = $0002 ; %call
=$0003					KWD_SYS_COMMENT                = $0003 ; %comment
=$0004					KWD_SYS_QSTRING                = $0004 ; %qstring
=$0005					KWD_SYS_DEFINE                 = $0005 ; %define
=$0006					KWD_IF                         = $0006 ; if
=$0007					KWD_REPEAT                     = $0007 ; repeat
=$0008					KWD_FOR                        = $0008 ; for
=$0009					KWD_ENDIF                      = $0009 ; endif
=$000a					KWD_UNTIL                      = $000a ; until
=$000b					KWD_NEXT                       = $000b ; next
=$000c					KWD_STAR                       = $000c ; *
=$000d					KWD_SLASH                      = $000d ; /
=$000e					KWD_MOD                        = $000e ; mod
=$000f					KWD_PLUS                       = $000f ; +
=$0010					KWD_MINUS                      = $0010 ; -
=$0011					KWD_AND                        = $0011 ; and
=$0012					KWD_OR                         = $0012 ; or
=$0013					KWD_XOR                        = $0013 ; xor
=$0014					KWD_SHL                        = $0014 ; shl
=$0015					KWD_SHR                        = $0015 ; shr
=$0016					KWD_EQUAL                      = $0016 ; =
=$0017					KWD_LESSGREATER                = $0017 ; <>
=$0018					KWD_GREATER                    = $0018 ; >
=$0019					KWD_LESS                       = $0019 ; <
=$001a					KWD_GREATEREQUAL               = $001a ; >=
=$001b					KWD_LESSEQUAL                  = $001b ; <=
=$001c					KWD_CAT                        = $001c ; c@
=$001d					KWD_CPLING                     = $001d ; c!
=$001e					KWD_AT                         = $001e ; @
=$001f					KWD_PLING                      = $001f ; !
=$0020					KWD_DPLING                     = $0020 ; d!
=$0021					KWD_ALLOC                      = $0021 ; alloc
=$0022					KWD_HAT                        = $0022 ; ^
=$0023					KWD_LSQPAREN                   = $0023 ; [
=$0024					KWD_RSQPAREN                   = $0024 ; ]
=$0025					KWD_SYS                        = $0025 ; sys
=$0026					KWD_QMARK                      = $0026 ; ?
=$0027					KWD_HASH                       = $0027 ; #
=$0028					KWD_ABS                        = $0028 ; abs
=$0029					KWD_NEGATE                     = $0029 ; negate
=$002a					KWD_NOT                        = $002a ; not
=$002b					KWD_PLUSPLUS                   = $002b ; ++
=$002c					KWD_MINUSMINUS                 = $002c ; --
=$002d					KWD_BSWAP                      = $002d ; bswap
=$002e					KWD_LESSLESS                   = $002e ; <<
=$002f					KWD_GREATERGREATER             = $002f ; >>
=$0030					KWD_SGN                        = $0030 ; sgn
=$0031					KWD_RND                        = $0031 ; rnd
=$0032					KWD_CLR                        = $0032 ; clr
=$0033					KWD_DROP                       = $0033 ; drop
=$0034					KWD_DUP                        = $0034 ; dup
=$0035					KWD_NIP                        = $0035 ; nip
=$0036					KWD_OVER                       = $0036 ; over
=$0037					KWD_SWAP                       = $0037 ; swap
=$0038					KWD_ELSE                       = $0038 ; else
=$0039					KWD_INDEX                      = $0039 ; index
=$003a					KWD_SEMICOLON                  = $003a ; ;
=$003b					KWD_ASSERT                     = $003b ; assert
=$003c					KWD_LIST                       = $003c ; list
=$003d					KWD_NEW                        = $003d ; new
=$003e					KWD_OLD                        = $003e ; old
=$003f					KWD_STOP                       = $003f ; stop
=$0040					KWD_RUN                        = $0040 ; run
=$0041					KWD_END                        = $0041 ; end
=$0042					KWD_SAVE                       = $0042 ; save
=$0043					KWD_LOAD                       = $0043 ; load
.8092					KeywordText:
>8092	01 ff					.text $01,$ff                          ; $0000 %eol
>8094	01 ff					.text $01,$ff                          ; $0001 %const
>8096	01 ff					.text $01,$ff                          ; $0002 %call
>8098	01 ff					.text $01,$ff                          ; $0003 %comment
>809a	01 ff					.text $01,$ff                          ; $0004 %qstring
>809c	01 ff					.text $01,$ff                          ; $0005 %define
>809e	02 49 c6				.text $02,$49,$c6                      ; $0006 if
>80a1	06 52 45 50 45 41 d4			.text $06,$52,$45,$50,$45,$41,$d4      ; $0007 repeat
>80a8	03 46 4f d2				.text $03,$46,$4f,$d2                  ; $0008 for
>80ac	05 45 4e 44 49 c6			.text $05,$45,$4e,$44,$49,$c6          ; $0009 endif
>80b2	05 55 4e 54 49 cc			.text $05,$55,$4e,$54,$49,$cc          ; $000a until
>80b8	04 4e 45 58 d4				.text $04,$4e,$45,$58,$d4              ; $000b next
>80bd	01 aa					.text $01,$aa                          ; $000c *
>80bf	01 af					.text $01,$af                          ; $000d /
>80c1	03 4d 4f c4				.text $03,$4d,$4f,$c4                  ; $000e mod
>80c5	01 ab					.text $01,$ab                          ; $000f +
>80c7	01 ad					.text $01,$ad                          ; $0010 -
>80c9	03 41 4e c4				.text $03,$41,$4e,$c4                  ; $0011 and
>80cd	02 4f d2				.text $02,$4f,$d2                      ; $0012 or
>80d0	03 58 4f d2				.text $03,$58,$4f,$d2                  ; $0013 xor
>80d4	03 53 48 cc				.text $03,$53,$48,$cc                  ; $0014 shl
>80d8	03 53 48 d2				.text $03,$53,$48,$d2                  ; $0015 shr
>80dc	01 bd					.text $01,$bd                          ; $0016 =
>80de	02 3c be				.text $02,$3c,$be                      ; $0017 <>
>80e1	01 be					.text $01,$be                          ; $0018 >
>80e3	01 bc					.text $01,$bc                          ; $0019 <
>80e5	02 3e bd				.text $02,$3e,$bd                      ; $001a >=
>80e8	02 3c bd				.text $02,$3c,$bd                      ; $001b <=
>80eb	02 43 c0				.text $02,$43,$c0                      ; $001c c@
>80ee	02 43 a1				.text $02,$43,$a1                      ; $001d c!
>80f1	01 c0					.text $01,$c0                          ; $001e @
>80f3	01 a1					.text $01,$a1                          ; $001f !
>80f5	02 44 a1				.text $02,$44,$a1                      ; $0020 d!
>80f8	05 41 4c 4c 4f c3			.text $05,$41,$4c,$4c,$4f,$c3          ; $0021 alloc
>80fe	01 de					.text $01,$de                          ; $0022 ^
>8100	01 db					.text $01,$db                          ; $0023 [
>8102	01 dd					.text $01,$dd                          ; $0024 ]
>8104	03 53 59 d3				.text $03,$53,$59,$d3                  ; $0025 sys
>8108	01 bf					.text $01,$bf                          ; $0026 ?
>810a	01 a3					.text $01,$a3                          ; $0027 #
>810c	03 41 42 d3				.text $03,$41,$42,$d3                  ; $0028 abs
>8110	06 4e 45 47 41 54 c5			.text $06,$4e,$45,$47,$41,$54,$c5      ; $0029 negate
>8117	03 4e 4f d4				.text $03,$4e,$4f,$d4                  ; $002a not
>811b	02 2b ab				.text $02,$2b,$ab                      ; $002b ++
>811e	02 2d ad				.text $02,$2d,$ad                      ; $002c --
>8121	05 42 53 57 41 d0			.text $05,$42,$53,$57,$41,$d0          ; $002d bswap
>8127	02 3c bc				.text $02,$3c,$bc                      ; $002e <<
>812a	02 3e be				.text $02,$3e,$be                      ; $002f >>
>812d	03 53 47 ce				.text $03,$53,$47,$ce                  ; $0030 sgn
>8131	03 52 4e c4				.text $03,$52,$4e,$c4                  ; $0031 rnd
>8135	03 43 4c d2				.text $03,$43,$4c,$d2                  ; $0032 clr
>8139	04 44 52 4f d0				.text $04,$44,$52,$4f,$d0              ; $0033 drop
>813e	03 44 55 d0				.text $03,$44,$55,$d0                  ; $0034 dup
>8142	03 4e 49 d0				.text $03,$4e,$49,$d0                  ; $0035 nip
>8146	04 4f 56 45 d2				.text $04,$4f,$56,$45,$d2              ; $0036 over
>814b	04 53 57 41 d0				.text $04,$53,$57,$41,$d0              ; $0037 swap
>8150	04 45 4c 53 c5				.text $04,$45,$4c,$53,$c5              ; $0038 else
>8155	05 49 4e 44 45 d8			.text $05,$49,$4e,$44,$45,$d8          ; $0039 index
>815b	01 bb					.text $01,$bb                          ; $003a ;
>815d	06 41 53 53 45 52 d4			.text $06,$41,$53,$53,$45,$52,$d4      ; $003b assert
>8164	04 4c 49 53 d4				.text $04,$4c,$49,$53,$d4              ; $003c list
>8169	03 4e 45 d7				.text $03,$4e,$45,$d7                  ; $003d new
>816d	03 4f 4c c4				.text $03,$4f,$4c,$c4                  ; $003e old
>8171	04 53 54 4f d0				.text $04,$53,$54,$4f,$d0              ; $003f stop
>8176	03 52 55 ce				.text $03,$52,$55,$ce                  ; $0040 run
>817a	03 45 4e c4				.text $03,$45,$4e,$c4                  ; $0041 end
>817e	04 53 41 56 c5				.text $04,$53,$41,$56,$c5              ; $0042 save
>8183	04 4c 4f 41 c4				.text $04,$4c,$4f,$41,$c4              ; $0043 load
>8188	00					.byte 0
>8189						.align 2
.818a					DispatchHandler:
>818a	6a 85					.word ExecuteNextLine          ; $0000 %eol
>818c	a1 85					.word LongConstant             ; $0001 %const
>818e	95 93					.word Command_Call             ; $0002 %call
>8190	6a 85					.word ExecuteComment           ; $0003 %comment
>8192	b2 85					.word StringConstant           ; $0004 %qstring
>8194	92 84					.word SyntaxError              ; $0005 %define
>8196	0b 94					.word Structure_If             ; $0006 if
>8198	bf 94					.word Struct_Repeat            ; $0007 repeat
>819a	fb 94					.word Struct_For               ; $0008 for
>819c	48 94					.word Structure_Endif          ; $0009 endif
>819e	cb 94					.word Struct_Until             ; $000a until
>81a0	3e 95					.word Struct_Next              ; $000b next
>81a2	99 92					.word MulInteger16             ; $000c *
>81a4	17 92					.word DivInteger16             ; $000d /
>81a6	88 92					.word ModInteger16             ; $000e mod
>81a8	03 91					.word Stack_Add                ; $000f +
>81aa	1b 91					.word Stack_Sub                ; $0010 -
>81ac	33 91					.word Stack_And                ; $0011 and
>81ae	61 91					.word Stack_Or                 ; $0012 or
>81b0	4a 91					.word Stack_Xor                ; $0013 xor
>81b2	78 91					.word Stack_Shl                ; $0014 shl
>81b4	7c 91					.word Stack_Shr                ; $0015 shr
>81b6	ad 91					.word Comp_Equal               ; $0016 =
>81b8	b1 91					.word Comp_NotEqual            ; $0017 <>
>81ba	fa 91					.word Comp_Greater             ; $0018 >
>81bc	d5 91					.word Comp_Less                ; $0019 <
>81be	d9 91					.word Comp_GreaterEqual        ; $001a >=
>81c0	f6 91					.word Comp_LessEqual           ; $001b <=
>81c2	6d 8e					.word Mem_Peek                 ; $001c c@
>81c4	9f 8e					.word Mem_Poke                 ; $001d c!
>81c6	83 8e					.word Mem_WPeek                ; $001e @
>81c8	b4 8e					.word Mem_WPoke                ; $001f !
>81ca	d2 8e					.word Mem_DWPoke               ; $0020 d!
>81cc	ec 8e					.word Mem_Alloc                ; $0021 alloc
>81ce	09 90					.word Command_Store            ; $0022 ^
>81d0	93 85					.word CommandAssemblerOn       ; $0023 [
>81d2	9b 85					.word CommandAssemblerOff      ; $0024 ]
>81d4	9a 90					.word Command_Sys              ; $0025 sys
>81d6	bc 90					.word Command_DumpStack        ; $0026 ?
>81d8	92 84					.word SyntaxError              ; $0027 #
>81da	d7 92					.word Unary_Absolute           ; $0028 abs
>81dc	e0 92					.word Unary_Negate             ; $0029 negate
>81de	f5 92					.word Unary_Not                ; $002a not
>81e0	09 93					.word Unary_Increment          ; $002b ++
>81e2	15 93					.word Unary_Decrement          ; $002c --
>81e4	24 93					.word Unary_BSwap              ; $002d bswap
>81e6	36 93					.word Unary_Shl                ; $002e <<
>81e8	40 93					.word Unary_Shr                ; $002f >>
>81ea	4a 93					.word Unary_Sgn                ; $0030 sgn
>81ec	6d 93					.word Random_Handler           ; $0031 rnd
>81ee	a9 8f					.word Stack_Empty              ; $0032 clr
>81f0	af 8f					.word Stack_Drop               ; $0033 drop
>81f2	b4 8f					.word Stack_Dup                ; $0034 dup
>81f4	c5 8f					.word Stack_Nip                ; $0035 nip
>81f6	d6 8f					.word Stack_Over               ; $0036 over
>81f8	e7 8f					.word Stack_Swap               ; $0037 swap
>81fa	2e 94					.word Structure_Else           ; $0038 else
>81fc	1f 95					.word Struct_Index             ; $0039 index
>81fe	eb 93					.word Command_Return           ; $003a ;
>8200	83 90					.word Command_Assert           ; $003b assert
>8202	7e 8c					.word Cmd_List                 ; $003c list
>8204	48 90					.word Command_New              ; $003d new
>8206	4f 90					.word Command_Old              ; $003e old
>8208	79 90					.word Command_Stop             ; $003f stop
>820a	f0 84					.word ExecuteProgram           ; $0040 run
>820c	75 90					.word Command_End              ; $0041 end
>820e	1a 8f					.word System_Save              ; $0042 save
>8210	35 8f					.word System_Load              ; $0043 load

;******  Return to file: main.asm


;******  Processing file: generated/assembler.inc

=2					ASM_FIRST_2BYTE = 2
=10					ASM_FIRST_3BYTE = 10
=0					ASM_MODE_IMP = 0
=1					ASM_MODE_A = 1
=2					ASM_MODE_IMM = 2
=3					ASM_MODE_RL = 3
=4					ASM_MODE_ZP = 4
=5					ASM_MODE_ZX = 5
=6					ASM_MODE_ZY = 6
=7					ASM_MODE_IX = 7
=8					ASM_MODE_IY = 8
=9					ASM_MODE_IN = 9
=10					ASM_MODE_AB = 10
=11					ASM_MODE_AX = 11
=12					ASM_MODE_AY = 12
=13					ASM_MODE_IA = 13
=14					ASM_MODE_IAX = 14
.8212					LowBytes:
>8212	2b 21 00 00 42 21 4c 00			.byte $2b,$21,$00,$00,$42,$21,$4c,$00,$f0,$21,$4c,$00,$42,$21,$4c,$00,$ec,$21,$21,$00,$22,$21,$4c,$00,$63,$21,$a3,$00,$22,$21,$4c,$00,$52,$a4,$00,$00,$14,$a4,$cc,$00,$70,$a4,$cc,$00,$14,$a4,$cc,$00,$89,$a4,$a4,$00,$14,$a4,$cc,$00,$83,$a4,$83,$00,$14,$a4,$cc,$00,$69,$d2,$00,$00,$00,$d2,$52,$00,$e1,$d2,$52,$00,$90,$d2,$52,$00,$a3,$d2,$d2,$00,$00,$d2,$52,$00,$69,$d2,$f9,$00,$00,$d2,$52,$00,$73,$63,$00,$00,$7a,$63,$d2,$00,$61,$63,$d2,$00,$90,$63,$d2,$00,$b3,$63,$63,$00,$7a,$63,$d2,$00,$89,$63,$79,$00,$90,$63,$d2,$00,$21,$61,$00,$00,$79,$61,$78,$00,$99,$14,$e1,$00,$79,$61,$78,$00,$43,$61,$61,$00,$79,$61,$78,$00,$01,$61,$f3,$00,$7a,$61,$7a,$00,$79,$61,$78,$00,$79,$61,$78,$00,$19,$61,$18,$00,$79,$61,$78,$00,$53,$61,$61,$00,$79,$61,$78,$00,$76,$61,$58,$00,$79,$61,$78,$00,$f9,$90,$00,$00,$f9,$90,$83,$00,$b9,$90,$98,$00,$f9,$90,$83,$00,$a5,$90,$90,$00,$00,$90,$83,$00,$64,$90,$f8,$00,$00,$90,$83,$00,$f8,$23,$00,$00,$f8,$23,$a3,$00,$b8,$23,$d0,$00,$f8,$23,$a3,$00,$91,$23,$23,$00,$00,$23,$a3,$00,$84,$23,$78,$00,$00,$23,$a3,$00
>821a	f0 21 4c 00 42 21 4c 00 ec 21 21 00 22 21 4c 00
>822a	63 21 a3 00 22 21 4c 00 52 a4 00 00 14 a4 cc 00
>823a	70 a4 cc 00 14 a4 cc 00 89 a4 a4 00 14 a4 cc 00
>824a	83 a4 83 00 14 a4 cc 00 69 d2 00 00 00 d2 52 00
>825a	e1 d2 52 00 90 d2 52 00 a3 d2 d2 00 00 d2 52 00
>826a	69 d2 f9 00 00 d2 52 00 73 63 00 00 7a 63 d2 00
>827a	61 63 d2 00 90 63 d2 00 b3 63 63 00 7a 63 d2 00
>828a	89 63 79 00 90 63 d2 00 21 61 00 00 79 61 78 00
>829a	99 14 e1 00 79 61 78 00 43 61 61 00 79 61 78 00
>82aa	01 61 f3 00 7a 61 7a 00 79 61 78 00 79 61 78 00
>82ba	19 61 18 00 79 61 78 00 53 61 61 00 79 61 78 00
>82ca	76 61 58 00 79 61 78 00 f9 90 00 00 f9 90 83 00
>82da	b9 90 98 00 f9 90 83 00 a5 90 90 00 00 90 83 00
>82ea	64 90 f8 00 00 90 83 00 f8 23 00 00 f8 23 a3 00
>82fa	b8 23 d0 00 f8 23 a3 00 91 23 23 00 00 23 a3 00
>830a	84 23 78 00 00 23 a3 00
.8312					HighBytes:
>8312	0b 3f 00 00 53 3f 07 00			.byte $0b,$3f,$00,$00,$53,$3f,$07,$00,$41,$3f,$07,$00,$53,$3f,$07,$00,$0a,$3f,$3f,$00,$53,$3f,$07,$00,$0e,$3f,$26,$00,$53,$3f,$07,$00,$2b,$06,$00,$00,$0a,$06,$4a,$00,$42,$06,$4a,$00,$0a,$06,$4a,$00,$0a,$06,$06,$00,$0a,$06,$4a,$00,$4d,$06,$11,$00,$0a,$06,$4a,$00,$4b,$16,$00,$00,$00,$16,$33,$00,$41,$16,$33,$00,$2a,$16,$33,$00,$0b,$16,$16,$00,$00,$16,$33,$00,$0e,$16,$41,$00,$00,$16,$33,$00,$4b,$05,$00,$00,$4f,$05,$4a,$00,$42,$05,$4a,$00,$2a,$05,$4a,$00,$0b,$05,$05,$00,$4f,$05,$4a,$00,$4d,$05,$42,$00,$2a,$05,$4a,$00,$0b,$4f,$00,$00,$4f,$4f,$4f,$00,$11,$0a,$53,$00,$4f,$4f,$4f,$00,$09,$4f,$4f,$00,$4f,$4f,$4f,$00,$54,$4f,$53,$00,$4f,$4f,$4f,$00,$31,$31,$31,$00,$31,$31,$31,$00,$51,$31,$51,$00,$31,$31,$31,$00,$09,$31,$31,$00,$31,$31,$31,$00,$0e,$31,$53,$00,$31,$31,$31,$00,$0e,$0e,$00,$00,$0e,$0e,$11,$00,$26,$0e,$11,$00,$0e,$0e,$11,$00,$0a,$0e,$0e,$00,$00,$0e,$11,$00,$0e,$0e,$41,$00,$00,$0e,$11,$00,$0e,$4d,$00,$00,$0e,$4d,$26,$00,$26,$4d,$3a,$00,$0e,$4d,$26,$00,$09,$4d,$4d,$00,$00,$4d,$26,$00,$4d,$4d,$42,$00,$00,$4d,$26,$00
>831a	41 3f 07 00 53 3f 07 00 0a 3f 3f 00 53 3f 07 00
>832a	0e 3f 26 00 53 3f 07 00 2b 06 00 00 0a 06 4a 00
>833a	42 06 4a 00 0a 06 4a 00 0a 06 06 00 0a 06 4a 00
>834a	4d 06 11 00 0a 06 4a 00 4b 16 00 00 00 16 33 00
>835a	41 16 33 00 2a 16 33 00 0b 16 16 00 00 16 33 00
>836a	0e 16 41 00 00 16 33 00 4b 05 00 00 4f 05 4a 00
>837a	42 05 4a 00 2a 05 4a 00 0b 05 05 00 4f 05 4a 00
>838a	4d 05 42 00 2a 05 4a 00 0b 4f 00 00 4f 4f 4f 00
>839a	11 0a 53 00 4f 4f 4f 00 09 4f 4f 00 4f 4f 4f 00
>83aa	54 4f 53 00 4f 4f 4f 00 31 31 31 00 31 31 31 00
>83ba	51 31 51 00 31 31 31 00 09 31 31 00 31 31 31 00
>83ca	0e 31 53 00 31 31 31 00 0e 0e 00 00 0e 0e 11 00
>83da	26 0e 11 00 0e 0e 11 00 0a 0e 0e 00 00 0e 11 00
>83ea	0e 0e 41 00 00 0e 11 00 0e 4d 00 00 0e 4d 26 00
>83fa	26 4d 3a 00 0e 4d 26 00 09 4d 4d 00 00 4d 26 00
>840a	4d 4d 42 00 00 4d 26 00
.8412					ModeNibbles:
>8412	07 ff 44 4f 02 1f aa af			.byte $07,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$45,$5f,$0c,$1f,$ab,$bf,$17,$ff,$44,$4f,$02,$1f,$aa,$af,$38,$9f,$55,$5f,$0c,$1f,$bb,$bf,$07,$ff,$f4,$4f,$02,$1f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$07,$ff,$44,$4f,$02,$1f,$da,$af,$38,$9f,$55,$5f,$0c,$0f,$eb,$bf,$37,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$ab,$bf,$27,$2f,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$55,$6f,$0c,$0f,$bb,$cf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf,$27,$ff,$44,$4f,$02,$0f,$aa,$af,$38,$9f,$f5,$5f,$0c,$0f,$fb,$bf
>841a	38 9f 45 5f 0c 1f ab bf 17 ff 44 4f 02 1f aa af
>842a	38 9f 55 5f 0c 1f bb bf 07 ff f4 4f 02 1f aa af
>843a	38 9f f5 5f 0c 0f fb bf 07 ff 44 4f 02 1f da af
>844a	38 9f 55 5f 0c 0f eb bf 37 ff 44 4f 02 0f aa af
>845a	38 9f 55 6f 0c 0f ab bf 27 2f 44 4f 02 0f aa af
>846a	38 9f 55 6f 0c 0f bb cf 27 ff 44 4f 02 0f aa af
>847a	38 9f f5 5f 0c 0f fb bf 27 ff 44 4f 02 0f aa af
>848a	38 9f f5 5f 0c 0f fb bf

;******  Return to file: main.asm


;******  Processing file: core/error.asm

.8492					SyntaxError:
.8492	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8495	53 59 4e 54 41 58 00				.text 	"SYNTAX",0
.849c					ErrorHandler:
.849c	fa		plx				plx 								; pull address off.
.849d	7a		ply				ply
.849e	e8		inx				inx 								; point to message
.849f	d0 01		bne $84a2			bne 	_EHNoCarry
.84a1	c8		iny				iny
.84a2					_EHNoCarry:
.84a2	20 d5 84	jsr $84d5			jsr 	PrintStringXY 				; print string at XY
.84a5	b2 00		lda ($00)			lda 	(codePtr) 					; gone off the end, like in structures ?
.84a7	f0 13		beq $84bc			beq 	_EHNoLine
.84a9	a2 c4		ldx #$c4			ldx 	#_EHMessage & $FF 			; print " AT "
.84ab	a0 84		ldy #$84			ldy 	#_EHMessage >> 8
.84ad	20 d5 84	jsr $84d5			jsr 	PrintStringXY
.84b0	a0 01		ldy #$01			ldy 	#1 							; line# into YX.
.84b2	b1 00		lda ($00),y			lda 	(codePtr),y
.84b4	aa		tax				tax
.84b5	c8		iny				iny
.84b6	b1 00		lda ($00),y			lda 	(codePtr),y
.84b8	a8		tay				tay
.84b9	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.84bc					_EHNoLine:
.84bc	a9 0d		lda #$0d			lda 	#13
.84be	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.84c1	4c 1b 80	jmp $801b			jmp 	WarmStart
.84c4					_EHMessage:
>84c4	20 41 54 20 00					.text	" AT ",0
.84c9					PrintIntegerUnsigned:
.84c9	20 fc 88	jsr $88fc			jsr 	IntToString
.84cc	a2 e0		ldx #$e0			ldx 	#ConvertBuffer & $FF 		; print number
.84ce	a0 08		ldy #$08			ldy 	#ConvertBuffer >> 8
.84d0	20 d5 84	jsr $84d5			jsr 	PrintStringXY
.84d3	98		tya				tya
.84d4	60		rts				rts
.84d5					PrintStringXY:
.84d5	86 02		stx $02				stx 	zTemp0
.84d7	84 03		sty $03				sty 	zTemp0+1
.84d9	a0 00		ldy #$00			ldy 	#0
.84db	b1 02		lda ($02),y	_PSLoop:lda 	(zTemp0),y
.84dd	f0 06		beq $84e5			beq 	_PSExit
.84df	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.84e2	c8		iny				iny
.84e3	80 f6		bra $84db			bra 	_PSLoop
.84e5	60		rts		_PSExit:rts
.84e6					PrintCharacter:
.84e6	48		pha				pha
.84e7	da		phx				phx
.84e8	5a		phy				phy
.84e9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.84ec	7a		ply				ply
.84ed	fa		plx				plx
.84ee	68		pla				pla
.84ef	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/execute.asm

.84f0					ExecuteProgram:
.84f0	a2 00		ldx #$00			ldx 	#ProgramStart & $FF
.84f2	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.84f4					ExecuteFromXY:
.84f4	20 f3 87	jsr $87f3			jsr 	ResetMemory 				; reset alloc pointers, variables etc.
.84f7	20 2f 88	jsr $882f			jsr 	StackReset 					; reset the CPU stack.
.84fa	64 1a		stz $1a				stz 	assemblerMode 				; not in assembler mode.
.84fc	a2 ff		ldx #$ff			ldx 	#$FF 						; empty the data stack
.84fe	80 0a		bra $850a			bra 	ExecuteLoop
.8500					ShortConstant:
.8500	c8		iny				iny 								; skip short const
.8501	e8		inx				inx 								; space on stack
.8502	29 3f		and #$3f			and 	#$3F 						; the value
.8504	9d 00 06	sta $0600,x			sta 	lowStack,x 					; put on stack..
.8507	9e 00 07	stz $0700,x			stz 	highStack,x
.850a					ExecuteLoop:
.850a	e6 18		inc $18				inc 	breakCount 					; check break sometimes.
.850c	d0 03		bne $8511			bne 	_EXNoBreak
.850e	20 de 85	jsr $85de			jsr 	ExternCheckBreak
.8511					_EXNoBreak:
.8511	e0 fe		cpx #$fe			cpx		#254 						; stack underflow
.8513	f0 4b		beq $8560			beq 	_ELUnderflow
.8515	b1 00		lda ($00),y			lda 	(codePtr),y 				; get next character
.8517	30 07		bmi $8520			bmi 	_ELNotToken
.8519	c8		iny				iny 								; skip the token
.851a	da		phx				phx 								; save X on the stack
.851b	0a		asl a				asl 	a 							; double the token, put into X
.851c	aa		tax				tax
.851d	7c 8a 81	jmp ($818a,x)			jmp 	(DispatchHandler,x)
.8520					_ELNotToken:
.8520	c9 c0		cmp #$c0			cmp 	#$C0 						; is it 80-BF
.8522	90 dc		bcc $8500			bcc 	ShortConstant 				; yes, it's a short constant
.8524	c9 e0		cmp #$e0			cmp 	#$E0 						; is it E0-FF - i.e. it is one letter variable.
.8526	90 1e		bcc $8546			bcc 	_ELNotFastVariable
.8528	c8		iny				iny 								; get the next token.
.8529	b1 00		lda ($00),y			lda 	(codePtr),y
.852b	88		dey				dey
.852c	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; if not [ then it is a simple variable
.852e	f0 16		beq $8546			beq 	_ELNotFastVariable 			; which we can optimise.
.8530	5a		phy				phy 								; save Y
.8531	b1 00		lda ($00),y			lda 	(codePtr),y 				; variable E0-FF
.8533	0a		asl a				asl 	a 							; it is now C0-FE, steps of 2.
.8534	a8		tay				tay 								; access via Y
.8535	e8		inx				inx 								; make space on the stack.
.8536	b9 40 0e	lda $0e40,y			lda 	FastVariables-$C0,y 		; copy the fast variable
.8539	9d 00 06	sta $0600,x			sta 	lowStack,x
.853c	b9 41 0e	lda $0e41,y			lda 	FastVariables-$C0+1,y
.853f	9d 00 07	sta $0700,x			sta 	highStack,x
.8542	7a		ply				ply 								; restore code pointer
.8543	c8		iny				iny 								; skip variable.
.8544	80 c4		bra $850a			bra 	ExecuteLoop
.8546					_ELNotFastVariable:
.8546	18		clc				clc									; do not autocreate if not found.
.8547	20 47 89	jsr $8947			jsr 	VariableFind				; find the variable.
.854a	90 34		bcc $8580			bcc 	ELUnknown
.854c	20 ba 86	jsr $86ba			jsr 	IndexCheck
.854f	5a		phy				phy 								; copy to stack
.8550	e8		inx				inx
.8551	b2 02		lda ($02)			lda 	(zTemp0)
.8553	9d 00 06	sta $0600,x			sta 	lowStack,x
.8556	a0 01		ldy #$01			ldy 	#1
.8558	b1 02		lda ($02),y			lda 	(zTemp0),y
.855a	9d 00 07	sta $0700,x			sta 	highStack,x
.855d	7a		ply				ply
.855e	80 aa		bra $850a			bra 	ExecuteLoop
.8560					_ELUnderflow:
.8560	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8563	53 54 41 43 4b 3f 00				.text 	"STACK?",0
.856a					ExecuteNextLine:
.856a					ExecuteComment:
.856a	fa		plx				plx
.856b	18		clc				clc 								; skip forward
.856c	b2 00		lda ($00)			lda 	(codePtr)
.856e	18		clc				clc
.856f	65 00		adc $00				adc 	codePtr
.8571	85 00		sta $00				sta 	codePtr
.8573	90 02		bcc $8577			bcc 	_ENLNoCarry
.8575	e6 01		inc $01				inc 	codePtr+1
.8577					_ENLNoCarry:
.8577	a0 03		ldy #$03			ldy 	#3 							; start of next line
.8579	b2 00		lda ($00)			lda 	(codePtr) 					; check offset non zero
.857b	d0 8d		bne $850a			bne 	ExecuteLoop
.857d	4c 75 90	jmp $9075			jmp	 	Command_End 				; if zero end program.
.8580					ELUnknown:
.8580	a5 1a		lda $1a				lda 	assemblerMode 				; error if not in assembler mode.
.8582	d0 0c		bne $8590			bne 	_ELCheckAssembler
.8584					_ELUnknown:
.8584	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8587	55 4e 4b 4e 4f 57 4e 3f				.text 	"UNKNOWN?",0
>858f	00
.8590					_ELCheckAssembler:
>8590	ff						.byte 	$FF
.8591	80 f1		bra $8584			bra 	_ELUnknown
.8593					CommandAssemblerOn:
.8593	fa		plx				plx
.8594	a9 01		lda #$01			lda 	#1
.8596	85 1a		sta $1a				sta 	assemblerMode
.8598	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.859b					CommandAssemblerOff:
.859b	fa		plx				plx
.859c	64 1a		stz $1a				stz 	assemblerMode
.859e	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.85a1					LongConstant:
.85a1	fa		plx				plx
.85a2	e8		inx				inx 								; space for constant
.85a3	b1 00		lda ($00),y			lda 	(codePtr),y 				; copy it in.
.85a5	9d 00 06	sta $0600,x			sta 	lowStack,x
.85a8	c8		iny				iny
.85a9	b1 00		lda ($00),y			lda 	(codePtr),y
.85ab	9d 00 07	sta $0700,x			sta 	highStack,x
.85ae	c8		iny				iny
.85af	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.85b2					StringConstant:
.85b2	fa		plx				plx
.85b3	e8		inx				inx
.85b4	18		clc				clc 								; copy Y + codePtr in.
.85b5	98		tya				tya
.85b6	65 00		adc $00				adc 	codePtr
.85b8	9d 00 06	sta $0600,x			sta 	lowStack,x
.85bb	a5 01		lda $01				lda 	codePtr+1
.85bd	69 00		adc #$00			adc 	#0
.85bf	9d 00 07	sta $0700,x			sta 	highStack,x
.85c2	98		tya				tya 								; add 1 + length to Y
.85c3	38		sec				sec
.85c4	71 00		adc ($00),y			adc 	(codePtr),y
.85c6	a8		tay				tay
.85c7	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: core/extern.asm

.85ca					ExternInitialise:
.85ca	a9 02		lda #$02			lda 	#$02 						; set colour
.85cc	8d c9 02	sta $02c9			sta 	713
.85cf	a9 0e		lda #$0e			lda 	#14							; lower case
.85d1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85d4	a9 93		lda #$93			lda 	#147 						; clear screen
.85d6	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85d9	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.85db	4c fc 85	jmp $85fc			jmp 	ExternColour
.85de					ExternCheckBreak:
.85de	da		phx				phx 								; make sure we keep XY
.85df	5a		phy				phy
.85e0	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.85e3	f0 03		beq $85e8			beq		_ECBExit 					; stopped
.85e5	7a		ply				ply 								; restore and exit.
.85e6	fa		plx				plx
.85e7	60		rts				rts
.85e8					_ECBExit:
.85e8	20 9c 84	jsr $849c			jsr 	ErrorHandler
>85eb	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.85f2					ExternPrint:
.85f2	48		pha				pha
.85f3	da		phx				phx
.85f4	5a		phy				phy
.85f5	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.85f8	7a		ply				ply
.85f9	fa		plx				plx
.85fa	68		pla				pla
.85fb	60		rts				rts
.85fc					ExternColour:
.85fc	48		pha				pha
.85fd	da		phx				phx
.85fe	48		pha				pha
.85ff	29 08		and #$08			and 	#8
.8601	0a		asl a				asl 	a
.8602	0a		asl a				asl 	a
.8603	0a		asl a				asl 	a
.8604	0a		asl a				asl 	a
.8605	49 92		eor #$92			eor 	#$92
.8607	20 f2 85	jsr $85f2			jsr 	ExternPrint
.860a	68		pla				pla
.860b	29 07		and #$07			and 	#7
.860d	aa		tax				tax
.860e	bd 17 86	lda $8617,x			lda 	_ECTable,x
.8611	20 f2 85	jsr $85f2			jsr 	ExternPrint
.8614	fa		plx				plx
.8615	68		pla				pla
.8616	60		rts				rts
.8617					_ECTable:
>8617	90						.byte 	144
>8618	1c						.byte 	28
>8619	1e						.byte 	30
>861a	9e						.byte 	158
>861b	1f						.byte 	31
>861c	9c						.byte 	156
>861d	9f						.byte 	159
>861e	05						.byte 	5
.861f					ExternInput:
.861f	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.8621	85 02		sta $02				sta 	zTemp0
.8623	a9 08		lda #$08			lda 	#(InputBuffer >> 8)
.8625	85 03		sta $03				sta 	zTemp0+1
.8627	a9 07		lda #$07			lda 	#COL_WHITE
.8629	20 fc 85	jsr $85fc			jsr 	ExternColour
.862c	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.862f	29 7f		and #$7f			and 	#$7F
.8631	c9 0d		cmp #$0d			cmp 	#13
.8633	f0 0a		beq $863f			beq 	_EIExit
.8635	92 02		sta ($02)			sta 	(zTemp0)
.8637	e6 02		inc $02				inc 	zTemp0
.8639	d0 f1		bne $862c			bne 	_EIRead
.863b	e6 03		inc $03				inc 	zTemp0+1
.863d	80 ed		bra $862c			bra 	_EIRead
.863f	a9 00		lda #$00	_EIExit:lda 	#0
.8641	92 02		sta ($02)			sta 	(zTemp0)
.8643	a9 0d		lda #$0d			lda 	#13
.8645	20 f2 85	jsr $85f2			jsr 	ExternPrint
.8648	60		rts				rts
.8649					ExternSave:
.8649	da		phx				phx
.864a	5a		phy				phy
.864b	85 06		sta $06				sta 	zTemp2 						; save start
.864d	84 07		sty $07				sty 	zTemp2+1
.864f	20 b1 86	jsr $86b1			jsr 	EXGetLength 				; get length of file into A
.8652	a6 02		ldx $02				ldx 	zTemp0
.8654	a4 03		ldy $03				ldy 	zTemp0+1
.8656	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.8659	a9 01		lda #$01			lda 	#1
.865b	a2 01		ldx #$01			ldx 	#1	 						; device #1
.865d	a0 00		ldy #$00			ldy 	#0
.865f	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.8662	a6 04		ldx $04				ldx 	zTemp1 						; end address
.8664	a4 05		ldy $05				ldy 	zTemp1+1
.8666	a9 06		lda #$06			lda 	#zTemp2
.8668	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.866b	b0 03		bcs $8670			bcs 	_ESSave
.866d	7a		ply				ply
.866e	fa		plx				plx
.866f	60		rts				rts
.8670					_ESSave:
.8670	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8673	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>867b	4c 45 44 00
.867f					ExternLoad:
.867f	da		phx				phx 								; save XY
.8680	5a		phy				phy
.8681	48		pha				pha 								; save target
.8682	5a		phy				phy
.8683	20 b1 86	jsr $86b1			jsr 	EXGetLength 				; get length of file into A
.8686	a6 02		ldx $02				ldx 	zTemp0
.8688	a4 03		ldy $03				ldy 	zTemp0+1
.868a	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.868d	a9 01		lda #$01			lda 	#1
.868f	a2 01		ldx #$01			ldx 	#1	 						; device #1
.8691	a0 00		ldy #$00			ldy 	#0
.8693	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.8696	7a		ply				ply 								; restore target to YX and call load
.8697	fa		plx				plx
.8698	a9 00		lda #$00			lda 	#0 							; load command
.869a	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.869d	b0 03		bcs $86a2			bcs 	_ESLoad
.869f	7a		ply				ply
.86a0	fa		plx				plx
.86a1	60		rts				rts
.86a2					_ESLoad:
.86a2	20 9c 84	jsr $849c			jsr 	ErrorHandler
>86a5	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>86ad	4c 45 44 00
.86b1					EXGetLength:
.86b1	b2 02		lda ($02)			lda 	(zTemp0) 					; get name length
.86b3	e6 02		inc $02				inc 	zTemp0 						; bump ptr past it
.86b5	d0 02		bne $86b9			bne 	_EXGLExit
.86b7	e6 03		inc $03				inc 	zTemp0+1
.86b9					_EXGLExit:
.86b9	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/index.asm

.86ba					IndexCheck:
.86ba	b1 00		lda ($00),y			lda 	(codePtr),y 			; do we have a [
.86bc	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.86be	f0 01		beq $86c1			beq 	_ICFound
.86c0	60		rts				rts
.86c1					_ICFound:
.86c1	c8		iny				iny 							; get next
.86c2	b1 00		lda ($00),y			lda 	(codePtr),y
.86c4	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; is it ], then stack value index.
.86c6	f0 2b		beq $86f3			beq 	_ICStackIndex
.86c8	38		sec				sec
.86c9	e9 80		sbc #$80			sbc 	#$80 					; this will shift 00-3F into that range
.86cb	c9 40		cmp #$40			cmp 	#$40
.86cd	b0 1a		bcs $86e9			bcs 	_ICError
.86cf	0a		asl a				asl 	a 						; double index clear carry
.86d0	5a		phy				phy 							; put into Y
.86d1	72 02		adc ($02)			adc 	(zTemp0) 				; follow the vector adding the index
.86d3	48		pha				pha
.86d4	a0 01		ldy #$01			ldy 	#1
.86d6	b1 02		lda ($02),y			lda 	(zTemp0),y
.86d8	69 00		adc #$00			adc 	#0
.86da	85 03		sta $03				sta 	zTemp0+1
.86dc	68		pla				pla
.86dd	85 02		sta $02				sta 	zTemp0
.86df	7a		ply				ply 							; restore position.
.86e0	c8		iny				iny								; skip index
.86e1	b1 00		lda ($00),y			lda 	(codePtr),y 			; get & skip next
.86e3	c8		iny				iny
.86e4	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN 			; should be ]
.86e6	d0 01		bne $86e9			bne 	_ICError
.86e8	60		rts				rts
.86e9					_ICError:
.86e9	20 9c 84	jsr $849c			jsr 	ErrorHandler
>86ec	49 4e 44 45 58 3f 00				.text 	"INDEX?",0
.86f3					_ICStackIndex:
.86f3	c8		iny				iny 							; skip the ]
.86f4	bd 00 06	lda $0600,x			lda 	lowStack,x 				; get tos -> zTemp1 doubled
.86f7	0a		asl a				asl 	a
.86f8	85 04		sta $04				sta 	zTemp1
.86fa	bd 00 07	lda $0700,x			lda 	highStack,x
.86fd	2a		rol a				rol 	a
.86fe	85 05		sta $05				sta 	zTemp1+1
.8700	ca		dex				dex 							; throw TOS.
.8701	5a		phy				phy
.8702	a0 01		ldy #$01			ldy 	#1 						; calculate new address
.8704	b2 02		lda ($02)			lda 	(zTemp0)
.8706	65 04		adc $04				adc 	zTemp1
.8708	48		pha				pha
.8709	b1 02		lda ($02),y			lda 	(zTemp0),y
.870b	65 05		adc $05				adc 	zTemp1+1
.870d	85 03		sta $03				sta 	zTemp0+1
.870f	68		pla				pla
.8710	85 02		sta $02				sta 	zTemp0
.8712	7a		ply				ply 							; restore pos and exit.
.8713	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/program.asm

.8714					EditProgram:
.8714	86 0d		stx $0d				stx 	zTemp5+1 					; save line number.
.8716	85 0c		sta $0c				sta 	zTemp5
.8718	5a		phy				phy 								; save token buffer offset
.8719	20 3c 87	jsr $873c			jsr 	EDFindLine					; find line address -> zTemp1
.871c	90 0f		bcc $872d			bcc 	_EPNotFound 				; if missing don't delete it.
.871e	a5 04		lda $04				lda 	zTemp1 						; save line address
.8720	48		pha				pha
.8721	a5 05		lda $05				lda 	zTemp1+1
.8723	48		pha				pha
.8724	20 71 87	jsr $8771			jsr 	EDDeleteLine 				; delete the line
.8727	68		pla				pla 								; restore line address
.8728	85 05		sta $05				sta 	zTemp1+1
.872a	68		pla				pla
.872b	85 04		sta $04				sta 	zTemp1
.872d					_EPNotFound:
.872d	7a		ply				ply 								; get offset
.872e	b9 00 0a	lda $0a00,y			lda 	TokenBuffer,y 				; if something after line#
.8731	f0 03		beq $8736			beq 	_EPNoInsert
.8733	20 94 87	jsr $8794			jsr 	EDInsertLine 				; insert line back in.
.8736					_EPNoInsert:
.8736	20 f3 87	jsr $87f3			jsr 	ResetMemory
.8739	4c 1b 80	jmp $801b			jmp 	WarmStart
.873c					EDFindLine:
.873c	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.873e	85 04		sta $04				sta 	zTemp1
.8740	a9 10		lda #$10			lda 	#ProgramStart >> 8
.8742	85 05		sta $05				sta 	zTemp1+1
.8744					_EDFLLoop:
.8744	a0 00		ldy #$00			ldy 	#0 							; reached the end
.8746	b1 04		lda ($04),y			lda 	(zTemp1),y
.8748	f0 23		beq $876d			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.874a	c8		iny				iny
.874b	38		sec				sec
.874c	a5 0c		lda $0c				lda 	zTemp5						; subtract the current from the target
.874e	f1 04		sbc ($04),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.8750	aa		tax				tax	 								; this will return 10.
.8751	a5 0d		lda $0d				lda 	zTemp5+1
.8753	c8		iny				iny
.8754	f1 04		sbc ($04),y			sbc 	(zTemp1),y
.8756	90 15		bcc $876d			bcc 	_EDFLFail					; if target < current then failed.
.8758	d0 04		bne $875e			bne 	_EDFLNext 					; if non-zero then goto next
.875a	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.875c	f0 11		beq $876f			beq 	_EDFLFound
.875e					_EDFLNext:
.875e	a0 00		ldy #$00			ldy 	#0 							; get offset
.8760	18		clc				clc
.8761	b1 04		lda ($04),y			lda 	(zTemp1),y
.8763	65 04		adc $04				adc 	zTemp1 						; add to pointer
.8765	85 04		sta $04				sta 	zTemp1
.8767	90 db		bcc $8744			bcc 	_EDFLLoop
.8769	e6 05		inc $05				inc 	zTemp1+1 					; carry out.
.876b	80 d7		bra $8744			bra 	_EDFLLoop
.876d					_EDFLFail:
.876d	18		clc				clc
.876e	60		rts				rts
.876f					_EDFLFound:
.876f	38		sec				sec
.8770	60		rts				rts
.8771					EDDeleteLine:
.8771	20 11 88	jsr $8811			jsr 	ResetVarMemory
.8774	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.8776	a2 00		ldx #$00			ldx 	#0
.8778	b1 04		lda ($04),y			lda 	(zTemp1),y
.877a	a8		tay				tay 								; put in Y
.877b					_EDDelLoop:
.877b	b1 04		lda ($04),y			lda 	(zTemp1),y 					; get it
.877d	81 04		sta ($04,x)			sta 	(zTemp1,x) 					; write it.
.877f	a5 04		lda $04				lda 	zTemp1 						; check if pointer has reached the end of
.8781	c5 13		cmp $13				cmp		memVarPtr 					; low memory. We will have copied down an
.8783	d0 06		bne $878b			bne 	_EDDelNext 					; extra pile of stuff - technically should
.8785	a5 05		lda $05				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.8787	c5 14		cmp $14				cmp 	memVarPtr+1					; doesn't really matter.
.8789	f0 08		beq $8793			beq		_EDDelExit
.878b					_EDDelNext:
.878b	e6 04		inc $04				inc 	zTemp1 						; go to next byte.
.878d	d0 ec		bne $877b			bne 	_EDDelLoop
.878f	e6 05		inc $05				inc 	zTemp1+1
.8791	80 e8		bra $877b			bra 	_EDDelLoop
.8793					_EDDelExit:
.8793	60		rts				rts
.8794					EDInsertLine:
.8794	84 02		sty $02				sty 	zTemp0						; zTemp0 = address of code.
.8796	a9 0a		lda #$0a			lda 	#TokenBuffer >> 8
.8798	85 03		sta $03				sta 	zTemp0+1
.879a	20 11 88	jsr $8811			jsr 	ResetVarMemory
.879d	a5 13		lda $13				lda 	memVarPtr 					; copy high memory to zTemp3
.879f	85 08		sta $08				sta 	zTemp3
.87a1	a5 14		lda $14				lda 	memVarPtr+1
.87a3	85 09		sta $09				sta 	zTemp3+1
.87a5	a5 19		lda $19				lda 	TokenOffset 				; work out the space needed.
.87a7	38		sec				sec
.87a8	e5 02		sbc $02				sbc 	zTemp0
.87aa	18		clc				clc
.87ab	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.87ad	48		pha				pha 								; save total size (e.g. offset)
.87ae	85 0a		sta $0a				sta 	zTemp4 						; save for copying
.87b0	a8		tay				tay 								; in Y
.87b1	a2 00		ldx #$00			ldx 	#0
.87b3					_EDInsLoop:
.87b3	a1 08		lda ($08,x)			lda 	(zTemp3,x)					; copy it up
.87b5	91 08		sta ($08),y			sta 	(zTemp3),y
.87b7	a5 08		lda $08				lda 	zTemp3 						; reached the insert point (zTemp1)
.87b9	c5 04		cmp $04				cmp 	zTemp1
.87bb	d0 06		bne $87c3			bne 	_EDINextShift
.87bd	a5 09		lda $09				lda 	zTemp3+1
.87bf	c5 05		cmp $05				cmp 	zTemp1+1
.87c1	f0 0a		beq $87cd			beq 	_EDIShiftOver
.87c3					_EDINextShift:
.87c3	a5 08		lda $08				lda 	zTemp3 					; decrement the copy pointer.
.87c5	d0 02		bne $87c9			bne 	_EDINoBorrow
.87c7	c6 09		dec $09				dec 	zTemp3+1
.87c9					_EDINoBorrow:
.87c9	c6 08		dec $08				dec 	zTemp3
.87cb	80 e6		bra $87b3			bra 	_EDInsLoop
.87cd					_EDIShiftOver:
.87cd	68		pla				pla 								; this is the size + others, e.g. offset
.87ce	a0 00		ldy #$00			ldy 	#0
.87d0	91 08		sta ($08),y			sta 	(zTemp3),y 					; write that out.
.87d2	a5 0c		lda $0c				lda 	zTemp5 						; write Line# out
.87d4	c8		iny				iny
.87d5	91 08		sta ($08),y			sta 	(zTemp3),y
.87d7	a5 0d		lda $0d				lda 	zTemp5+1
.87d9	c8		iny				iny
.87da	91 08		sta ($08),y			sta 	(zTemp3),y
.87dc	c8		iny				iny 								; where the code goes.
.87dd	a2 00		ldx #$00			ldx 	#0 							; comes from
.87df					_EDICopyCode:
.87df	a1 02		lda ($02,x)			lda 	(zTemp0,x)					; read from the current line
.87e1	91 08		sta ($08),y			sta 	(zTemp3),y 					; write out
.87e3	c8		iny				iny 								; bump pointers
.87e4	e6 02		inc $02				inc 	zTemp0
.87e6	d0 02		bne $87ea			bne 	_EDINoCarry
.87e8	e6 03		inc $03				inc 	zTemp0+1
.87ea					_EDINoCarry:
.87ea	c6 0a		dec $0a				dec 	zTemp4 						; copy data in
.87ec	a5 0a		lda $0a				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.87ee	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.87f0	d0 ed		bne $87df			bne 	_EDICopyCode
.87f2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/reset.asm

.87f3					ResetMemory:
.87f3	da		phx				phx									; save run address
.87f4	5a		phy				phy
.87f5	a9 00		lda #$00			lda 	#(highMemory) & $FF
.87f7	85 11		sta $11				sta 	allocPtr
.87f9	a9 7f		lda #$7f			lda 	#(highMemory) >> 8
.87fb	85 12		sta $12				sta 	allocPtr+1
.87fd	20 11 88	jsr $8811			jsr 	ResetVarMemory
.8800	a2 1f		ldx #$1f			ldx 	#HashTableSize*2-1 			; bytes to erase
.8802					_RMEraseHash:
.8802	9e 40 0f	stz $0f40,x			stz 	VariableHashTable,x
.8805	ca		dex				dex
.8806	10 fa		bpl $8802			bpl 	_RMEraseHash
.8808	7a		ply				ply 								; restore and set run address
.8809	fa		plx				plx
.880a	84 01		sty $01				sty 	codePtr+1
.880c	86 00		stx $00				stx 	codePtr
.880e	a0 03		ldy #$03			ldy 	#3
.8810	60		rts				rts
.8811					ResetVarMemory:
.8811	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8813	85 13		sta $13				sta 	memVarPtr
.8815	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.8817	85 14		sta $14				sta 	memVarPtr+1
.8819					_RMFindEnd:
.8819	b2 13		lda ($13)			lda 	(memVarPtr)					; offset 0, found end.
.881b	f0 0b		beq $8828			beq 	_RMFoundEnd 				; advance to next.
.881d	18		clc				clc
.881e	65 13		adc $13				adc 	memVarPtr
.8820	85 13		sta $13				sta 	memVarPtr
.8822	90 f5		bcc $8819			bcc 	_RMFindEnd
.8824	e6 14		inc $14				inc 	memVarPtr+1
.8826	80 f1		bra $8819			bra 	_RMFindEnd
.8828					_RMFoundEnd:
.8828	e6 13		inc $13				inc 	memVarPtr 					; advance past last offset $00
.882a	d0 02		bne $882e			bne 	_RMNoCarry
.882c	e6 14		inc $14				inc 	memVarPtr+1
.882e					_RMNoCarry:
.882e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/stack.asm

.882f					StackReset:
.882f	a9 ff		lda #$ff			lda 	#IntStack & $FF 			; reset SP
.8831	85 0e		sta $0e				sta 	iStack
.8833	a9 09		lda #$09			lda 	#IntStack >> 8
.8835	85 0f		sta $0f				sta 	iStack+1
.8837	a9 ff		lda #$ff			lda 	#$FF						; dummy TOS value
.8839	92 0e		sta ($0e)			sta 	(iStack)
.883b	60		rts				rts
.883c					StackPushByte:
.883c	c6 0e		dec $0e				dec 	iStack
.883e	92 0e		sta ($0e)			sta 	(iStack)
.8840	f0 01		beq $8843			beq 	_SPBUnderflow
.8842	60		rts				rts
.8843					_SPBUnderflow:
.8843	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8846	53 54 41 43 4b 00				.text 	"STACK",0
.884c					StackPushPosition:
.884c	98		tya				tya
.884d	20 3c 88	jsr $883c			jsr 	StackPushByte
.8850	a5 01		lda $01				lda 	codePtr+1
.8852	20 3c 88	jsr $883c			jsr 	StackPushByte
.8855	a5 00		lda $00				lda 	codePtr
.8857	20 3c 88	jsr $883c			jsr 	StackPushByte
.885a	60		rts				rts
.885b					StackCheckTop:
.885b	d2 0e		cmp ($0e)			cmp 	(iStack)
.885d	f0 02		beq $8861			beq 	_SCTOk
.885f	18		clc				clc
.8860	60		rts				rts
.8861	38		sec		_SCTOk:	sec
.8862	60		rts				rts
.8863					StackPop:
.8863	18		clc				clc
.8864	65 0e		adc $0e				adc 	iStack
.8866	85 0e		sta $0e				sta 	iStack
.8868	60		rts				rts
.8869					StackRestorePosition:
.8869	b1 0e		lda ($0e),y			lda 	(iStack),y
.886b	85 00		sta $00				sta 	codePtr
.886d	c8		iny				iny
.886e	b1 0e		lda ($0e),y			lda 	(iStack),y
.8870	85 01		sta $01				sta 	codePtr+1
.8872	c8		iny				iny
.8873	b1 0e		lda ($0e),y			lda 	(iStack),y
.8875	a8		tay				tay
.8876	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tointeger.asm

.8877					StringToInt:
.8877	86 08		stx $08				stx 	zTemp3 						; save string
.8879	84 09		sty $09				sty 	zTemp3+1
.887b	64 10		stz $10				stz 	signCount 					; signcount is the number of chars copied.
.887d	a2 10		ldx #$10			ldx 	#16 						; base to use.
.887f	a0 01		ldy #$01			ldy 	#1 							; character offset.
.8881	b2 08		lda ($08)			lda 	(zTemp3) 					; first character
.8883	c9 24		cmp #$24			cmp 	#"$"						; is it hexadecimal
.8885	f0 03		beq $888a			beq 	_STIConvert 				; convert from character 1, base 16.
.8887	88		dey				dey 								; from character 0
.8888	a2 0a		ldx #$0a			ldx 	#10 						; base 10.
.888a					_STIConvert:
.888a	86 04		stx $04				stx 	zTemp1 						; save base in zTemp1
.888c	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get first character
.888e	f0 5f		beq $88ef			beq 	_STIFail 					; if zero, then it has failed anyway.
.8890	64 02		stz $02				stz 	zTemp0 						; clear the result.
.8892	64 03		stz $03				stz 	zTemp0+1
.8894					_STILoop:
.8894	b1 08		lda ($08),y			lda 	(zTemp3),y 					; check in range 0-9 A-F
.8896	c9 30		cmp #$30			cmp 	#"0"
.8898	90 55		bcc $88ef			bcc 	_STIFail
.889a	c9 3a		cmp #$3a			cmp 	#"9"+1
.889c	90 08		bcc $88a6			bcc 	_STIOkay
.889e	c9 41		cmp #$41			cmp 	#"A"
.88a0	90 4d		bcc $88ef			bcc 	_STIFail
.88a2	c9 47		cmp #$47			cmp 	#"F"+1
.88a4	b0 49		bcs $88ef			bcs 	_STIFail
.88a6					_STIOkay:
.88a6	a5 02		lda $02				lda 	zTemp0 						; copy current to zTemp2
.88a8	85 06		sta $06				sta 	zTemp2
.88aa	a5 03		lda $03				lda 	zTemp0+1
.88ac	85 07		sta $07				sta 	zTemp2+1
.88ae	64 02		stz $02				stz 	zTemp0 						; clear result
.88b0	64 03		stz $03				stz 	zTemp0+1
.88b2	a6 04		ldx $04				ldx 	zTemp1 						; X contains the base.
.88b4					_STIMultiply:
.88b4	8a		txa				txa 								; shift Y right into carry.
.88b5	4a		lsr a				lsr 	a
.88b6	aa		tax				tax
.88b7	90 0d		bcc $88c6			bcc 	_STINoAdd 					; skip if CC, e.g. LSB was zero
.88b9	18		clc				clc
.88ba	a5 06		lda $06				lda 	zTemp2 						; add zTemp2 into zTemp0
.88bc	65 02		adc $02				adc 	zTemp0
.88be	85 02		sta $02				sta 	zTemp0
.88c0	a5 07		lda $07				lda 	zTemp2+1
.88c2	65 03		adc $03				adc 	zTemp0+1
.88c4	85 03		sta $03				sta 	zTemp0+1
.88c6					_STINoAdd:
.88c6	06 06		asl $06				asl 	zTemp2 						; shift zTemp2 left e.g. x 2
.88c8	26 07		rol $07				rol 	zTemp2+1
.88ca	e0 00		cpx #$00			cpx 	#0 							; multiply finished ?
.88cc	d0 e6		bne $88b4			bne 	_STIMultiply
.88ce	38		sec				sec 								; hex adjust
.88cf	b1 08		lda ($08),y			lda 	(zTemp3),y 					; get digit.
.88d1	c9 3a		cmp #$3a			cmp 	#58
.88d3	90 03		bcc $88d8			bcc 	_STIDecimal
.88d5	38		sec				sec
.88d6	e9 07		sbc #$07			sbc 	#7
.88d8					_STIDecimal:
.88d8	38		sec				sec
.88d9	e9 30		sbc #$30			sbc 	#48
.88db	c5 04		cmp $04				cmp 	zTemp1  					; if >= base then fail.
.88dd	b0 10		bcs $88ef			bcs 	_STIFail
.88df	d8		cld				cld
.88e0	65 02		adc $02				adc 	zTemp0 						; add into the current value
.88e2	85 02		sta $02				sta 	zTemp0
.88e4	90 02		bcc $88e8			bcc 	_STINoCarry
.88e6	e6 03		inc $03				inc 	zTemp0+1
.88e8					_STINoCarry:
.88e8	b1 08		lda ($08),y			lda 	(zTemp3),y					; get character just done.
.88ea	c8		iny				iny 								; point to next
.88eb	e6 10		inc $10				inc 	SignCount
.88ed	80 a5		bra $8894			bra 	_STILoop 					; and go round again.
.88ef					_STIFail:
.88ef	a5 10		lda $10				lda 	SignCount 					; if converted 0 charactes, fail.
.88f1	f0 07		beq $88fa			beq 	_STINoConvert
.88f3	98		tya				tya 								; convert count in A.
.88f4	a6 02		ldx $02				ldx 	zTemp0 						; return result
.88f6	a4 03		ldy $03				ldy 	zTemp0+1
.88f8	38		sec				sec
.88f9	60		rts				rts
.88fa					_STINoConvert:
.88fa	18		clc				clc
.88fb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: core/tostring.asm

.88fc					IntToString:
.88fc	86 02		stx $02				stx 	zTemp0 						; count is in zTemp0
.88fe	84 03		sty $03				sty 	zTemp0+1
.8900	a0 00		ldy #$00			ldy 	#0 							; index into token buffer (out)
.8902	a2 00		ldx #$00			ldx 	#0 							; index into the word table
.8904					_ITSLoop:
.8904	64 04		stz $04				stz 	zTemp1 						; this is the count of subtracts.
.8906					_ITSSubtractLoop:
.8906	38		sec				sec
.8907	a5 02		lda $02				lda 	zTemp0 						; try to calculate
.8909	fd 3f 89	sbc $893f,x			sbc 	_ITSWords,x
.890c	48		pha				pha
.890d	a5 03		lda $03				lda 	zTemp0+1
.890f	fd 40 89	sbc $8940,x			sbc 	_ITSWords+1,x
.8912	90 09		bcc $891d			bcc 	_ITSEndSub 					; can't subtract any more.
.8914	85 03		sta $03				sta 	zTemp0+1 					; update zTemp
.8916	68		pla				pla
.8917	85 02		sta $02				sta 	zTemp0
.8919	e6 04		inc $04				inc 	zTemp1 						; bump subtract count.
.891b	80 e9		bra $8906			bra 	_ITSSubtractLoop
.891d					_ITSEndSub:
.891d	68		pla				pla 								; throw away the interim result
.891e	a5 04		lda $04				lda 	zTemp1 						; if the subtract count is non zero
.8920	d0 04		bne $8926			bne 	_ITSWriteOut 				; always write it out
.8922	c0 00		cpy #$00			cpy 	#0 							; don't write if this is the first
.8924	f0 06		beq $892c			beq 	_ITSNext 					; suppressing leading zeros.
.8926					_ITSWriteOut:
.8926	09 30		ora #$30			ora 	#48 						; output digit.
.8928	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y
.892b	c8		iny				iny
.892c					_ITSNext:
.892c	e8		inx				inx
.892d	e8		inx				inx
.892e	e0 08		cpx #$08			cpx 	#_ITSWordsEnd-_ITSWords 	; done all subtractors
.8930	d0 d2		bne $8904			bne 	_ITSLoop 					; do the new digits
.8932	a5 02		lda $02				lda 	zTemp0 						; output the last digit
.8934	09 30		ora #$30			ora 	#48
.8936	99 e0 08	sta $08e0,y			sta 	ConvertBuffer,y 				; make it ASCIIZ.
.8939	a9 00		lda #$00			lda 	#0
.893b	99 e1 08	sta $08e1,y			sta 	ConvertBuffer+1,y
.893e	60		rts				rts
.893f					_ITSWords:
>893f	10 27 e8 03 64 00 0a 00				.word 	10000,1000,100,10
.8947					_ITSWordsEnd:

;******  Return to file: main.asm


;******  Processing file: core/variables.asm

.8947					VariableFind:
.8947	da		phx				phx 								; save the stack position
.8948	08		php				php 								; save the create flag
.8949	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first identifier character
.894b	c9 e0		cmp #$e0			cmp 	#$E0						; if it is E0-FF the first is the last
.894d	90 10		bcc $895f			bcc		_VFIsNotFastVariable 		; so it is a fast variable.
.894f	29 1f		and #$1f			and 	#$1F 						; make it an offset
.8951	0a		asl a				asl 	a 							; double clear carry
.8952	69 00		adc #$00			adc 	#FastVariables & $FF 		; put the final address in zTemp0
.8954	85 02		sta $02				sta 	zTemp0
.8956	a9 0f		lda #$0f			lda		#FastVariables >>8
.8958	85 03		sta $03				sta 	zTemp0+1
.895a	28		plp				plp 								; create flag is irrelevant.
.895b	fa		plx				plx									; restore the old stack position
.895c	c8		iny				iny 								; skip over the single identifier character
.895d	38		sec				sec 								; return with CS
.895e	60		rts				rts
.895f					_VFIsNotFastVariable:
.895f	20 31 8a	jsr $8a31			jsr 	VFSetupHashPointer 			; set up the hash pointer
.8962	20 8c 89	jsr $898c			jsr 	VFSearch 					; try to find the variable.
.8965	b0 0d		bcs $8974			bcs 	_VFEndSearch 				; found it, so exit
.8967	28		plp				plp 								; do we want autocreate
.8968	b0 03		bcs $896d			bcs 	_VFCreate
.896a	fa		plx				plx 								; restore stack position and return CC
.896b	18		clc				clc
.896c	60		rts				rts
.896d					_VFCreate:
.896d	20 31 8a	jsr $8a31			jsr 	VFSetupHashPointer 			; reset the hash pointer
.8970	20 c8 89	jsr $89c8			jsr 	VFCreate 					; create a new record and link it in.
.8973	08		php				php 								; save a dummy P to be popped.
.8974					_VFEndSearch:
.8974	18		clc				clc 								; the data is at offset + 4
.8975	a5 04		lda $04				lda 	zTemp1
.8977	69 04		adc #$04			adc 	#4
.8979	85 02		sta $02				sta 	zTemp0
.897b	a5 05		lda $05				lda 	zTemp1+1
.897d	69 00		adc #$00			adc 	#0
.897f	85 03		sta $03				sta 	zTemp0+1
.8981	28		plp				plp 								; dump the create flag
.8982					_VFSkipExit:
.8982	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep read and skip until end-identifier.
.8984	c8		iny				iny
.8985	c9 e0		cmp #$e0			cmp 	#$E0
.8987	90 f9		bcc $8982			bcc 	_VFSkipExit
.8989	fa		plx				plx 								; restore X
.898a	38		sec				sec
.898b	60		rts				rts
.898c					VFSearch:
.898c	48		pha				pha 								; save AXY.
.898d	da		phx				phx
.898e	5a		phy				phy
.898f	98		tya				tya									; add Y to codePtr, put in zTemp2
.8990	18		clc				clc 								; so it points to the identifier.
.8991	65 00		adc $00				adc 	codePtr
.8993	85 06		sta $06				sta 	zTemp2
.8995	a5 01		lda $01				lda 	codePtr+1
.8997	69 00		adc #$00			adc 	#0
.8999	85 07		sta $07				sta 	zTemp2+1
.899b					_VFSLoop:
.899b	a0 01		ldy #$01			ldy 	#1 							; get MSB of next.
.899d	b1 04		lda ($04),y			lda 	(zTemp1),y 					; if this is zero, then end link (0)
.899f	f0 22		beq $89c3			beq 	_VFSFailed 					; failed.
.89a1	aa		tax				tax 								; MSB in X
.89a2	b2 04		lda ($04)			lda 	(zTemp1) 					; LSB in A
.89a4	85 04		sta $04				sta 	zTemp1 						; and update to the next record.
.89a6	86 05		stx $05				stx 	zTemp1+1
.89a8	a0 02		ldy #$02			ldy 	#2 							; put the name pointer in zTemp3
.89aa	b1 04		lda ($04),y			lda 	(zTemp1),y
.89ac	85 08		sta $08				sta 	zTemp3
.89ae	c8		iny				iny
.89af	b1 04		lda ($04),y			lda 	(zTemp1),y
.89b1	85 09		sta $09				sta 	zTemp3+1
.89b3	a0 ff		ldy #$ff			ldy 	#255 						; now compare the identifiers.
.89b5					_VFSCheckName:
.89b5	c8		iny				iny
.89b6	b1 06		lda ($06),y			lda 	(zTemp2),y 					; if different, try next
.89b8	d1 08		cmp ($08),y			cmp 	(zTemp3),y
.89ba	d0 df		bne $899b			bne 	_VFSLoop
.89bc	c9 e0		cmp #$e0			cmp 	#$E0 						; is it the ending identifier token
.89be	90 f5		bcc $89b5			bcc 	_VFSCheckName
.89c0	38		sec				sec 								; return with Carry set, and zTemp1 set up
.89c1	80 01		bra $89c4			bra		_VFSExit
.89c3					_VFSFailed:
.89c3	18		clc				clc
.89c4					_VFSExit:
.89c4	7a		ply				ply 								; restore registers and exit.
.89c5	fa		plx				plx
.89c6	68		pla				pla
.89c7	60		rts				rts
.89c8					VFCreate:
.89c8	48		pha				pha 								; save registers
.89c9	da		phx				phx
.89ca	5a		phy				phy
.89cb	18		clc				clc 								; add 6 to memVarPtr, saving its
.89cc	a5 13		lda $13				lda 	memVarPtr 					; address in zTemp0 as we go.
.89ce	85 02		sta $02				sta 	zTemp0
.89d0	69 06		adc #$06			adc 	#6
.89d2	85 13		sta $13				sta 	memVarPtr
.89d4	a5 14		lda $14				lda 	memVarPtr+1
.89d6	85 03		sta $03				sta 	zTemp0+1
.89d8	69 00		adc #$00			adc 	#0
.89da	85 14		sta $14				sta 	memVarPtr+1
.89dc	c5 12		cmp $12				cmp 	allocPtr+1 					; out of memory ?
.89de	f0 46		beq $8a26			beq 	_VFCMemory
.89e0	98		tya				tya 								; work out identifier address
.89e1	18		clc				clc
.89e2	65 00		adc $00				adc 	codePtr
.89e4	48		pha				pha
.89e5	c8		iny				iny
.89e6	a5 01		lda $01				lda 	codePtr+1
.89e8	69 00		adc #$00			adc 	#0
.89ea	c9 10		cmp #$10			cmp 	#ProgramStart >> 8 			; it must be >= program start
.89ec	b0 0b		bcs $89f9			bcs 	_VFCInProgram 				; otherwise variable created from command line.
.89ee	20 9c 84	jsr $849c			jsr 	ErrorHandler
>89f1	43 52 45 41 54 45 3f 00				.text 	"CREATE?",0
.89f9					_VFCInProgram:
.89f9	a0 03		ldy #$03			ldy 	#3 							; store in new record
.89fb	91 02		sta ($02),y			sta 	(zTemp0),y
.89fd	88		dey				dey
.89fe	68		pla				pla
.89ff	91 02		sta ($02),y			sta 	(zTemp0),y
.8a01	a0 04		ldy #$04			ldy 	#4 							; clear new data
.8a03	a9 00		lda #$00			lda 	#0
.8a05	91 02		sta ($02),y			sta 	(zTemp0),y
.8a07	c8		iny				iny
.8a08	91 02		sta ($02),y			sta 	(zTemp0),y
.8a0a	a0 01		ldy #$01			ldy 	#1 							; copy old first link to this link
.8a0c	b2 04		lda ($04)			lda 	(zTemp1)
.8a0e	92 02		sta ($02)			sta 	(zTemp0)
.8a10	b1 04		lda ($04),y			lda 	(zTemp1),y
.8a12	91 02		sta ($02),y			sta 	(zTemp0),y
.8a14	a5 02		lda $02				lda 	zTemp0 						; put the new record at the front of the
.8a16	92 04		sta ($04)			sta 	(zTemp1) 					; list.
.8a18	a5 03		lda $03				lda 	zTemp0+1
.8a1a	91 04		sta ($04),y			sta 	(zTemp1),y
.8a1c	85 05		sta $05				sta 	zTemp1+1 					; copy into zTemp1
.8a1e	a5 02		lda $02				lda 	zTemp0
.8a20	85 04		sta $04				sta 	zTemp1
.8a22	7a		ply				ply
.8a23	fa		plx				plx
.8a24	68		pla				pla
.8a25	60		rts				rts
.8a26					_VFCMemory:
.8a26	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8a29	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0
.8a31					VFSetupHashPointer:
.8a31	48		pha				pha
.8a32	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.8a34	29 0f		and #$0f			and 	#(HashTableSize-1) 			; make it in range 0..hash-1
.8a36	0a		asl a				asl 	a 							; double it, also clears carry
.8a37	69 40		adc #$40			adc 	#VariableHashTable & $FF 	; add to the base and store in zTemp1
.8a39	85 04		sta $04				sta 	zTemp1
.8a3b	a9 0f		lda #$0f			lda 	#VariableHashTable >> 8
.8a3d	85 05		sta $05				sta 	zTemp1+1
.8a3f	68		pla				pla
.8a40	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tokeniser.asm

.8a41					TokeniseInputBuffer:
.8a41	48		pha				pha
.8a42	da		phx				phx
.8a43	5a		phy				phy
.8a44	64 19		stz $19				stz 	TokenOffset					; reset index into TokenBuffer
.8a46	9c 00 0a	stz $0a00			stz 	TokenBuffer 				; empty that buffer
.8a49	a9 00		lda #$00			lda 	#0 							; create faux line by writing 3 bytes out.
.8a4b	20 b4 8a	jsr $8ab4			jsr 	TokWriteToken
.8a4e	20 b4 8a	jsr $8ab4			jsr 	TokWriteToken
.8a51	20 b4 8a	jsr $8ab4			jsr 	TokWriteToken
.8a54	a2 ff		ldx #$ff			ldx 	#255 						; find the end.
.8a56					_TIBForward:
.8a56	e8		inx				inx
.8a57	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8a5a	d0 fa		bne $8a56			bne 	_TIBForward
.8a5c					_TIBBackward:
.8a5c	ca		dex				dex 								; back one.
.8a5d	e0 ff		cpx #$ff			cpx 	#255 						; gone too far.
.8a5f	f0 4f		beq $8ab0			beq 	_TIBExit					; return empty buffer
.8a61	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8a64	c9 20		cmp #$20			cmp 	#" "
.8a66	f0 f4		beq $8a5c			beq 	_TIBBackward
.8a68	9e 01 08	stz $0801,x			stz 	InputBuffer+1,x 			; truncate at last non space.
.8a6b	a2 00		ldx #$00			ldx		#0 							; start of the input bufferr.
.8a6d					_TIBMainLoop:
.8a6d	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; next character
.8a70	f0 3e		beq $8ab0			beq 	_TIBExit 					; done the buffer if zero.
.8a72	e8		inx				inx
.8a73	c9 20		cmp #$20			cmp 	#" " 						; skip over spaces
.8a75	f0 f6		beq $8a6d			beq 	_TIBMainLoop
.8a77	ca		dex				dex 								; undo the last inx.
.8a78	c9 24		cmp #$24			cmp 	#"$"						; is it $ ?
.8a7a	f0 08		beq $8a84			beq 	_TIBConstant
.8a7c	c9 30		cmp #$30			cmp 	#"0"						; check 0-9
.8a7e	90 09		bcc $8a89			bcc 	_TIBNotConstant
.8a80	c9 3a		cmp #$3a			cmp 	#"9"+1
.8a82	b0 05		bcs $8a89			bcs 	_TIBNotConstant
.8a84					_TIBConstant:
.8a84	20 37 8b	jsr $8b37			jsr 	TOKConvertConstant
.8a87	80 e4		bra $8a6d			bra 	_TIBMainLoop
.8a89					_TIBNotConstant:
.8a89	c9 3a		cmp #$3a			cmp 	#":"						; definition
.8a8b	d0 05		bne $8a92			bne 	_TIBNotDefinition
.8a8d	20 89 8b	jsr $8b89			jsr 	TOKConvertDefinition
.8a90	80 db		bra $8a6d			bra 	_TIBMainLoop
.8a92					_TIBNotDefinition:
.8a92	c9 27		cmp #$27			cmp 	#"'"
.8a94	f0 04		beq $8a9a			beq 	_TIBIsCommentString
.8a96	c9 22		cmp #$22			cmp 	#'"'
.8a98	d0 05		bne $8a9f			bne 	_TIBNotCommentString
.8a9a					_TIBIsCommentString:
.8a9a	20 ed 8b	jsr $8bed			jsr 	TOKConvertCommentString
.8a9d	80 ce		bra $8a6d			bra 	_TIBMainLoop
.8a9f					_TIBNotCommentString:
.8a9f	20 34 8c	jsr $8c34			jsr 	TOKCheckIsToken 			; check if a token.
.8aa2	b0 c9		bcs $8a6d			bcs 	_TIBMainLoop
.8aa4	a5 19		lda $19				lda 	TokenOffset 				; save token offset.
.8aa6	48		pha				pha
.8aa7	20 c8 8b	jsr $8bc8			jsr 	TOKCopyIdentifier 			; copy identifier.
.8aaa	68		pla				pla
.8aab	20 e5 8a	jsr $8ae5			jsr 	TOKCheckIdentifierIsCall 	; convert if call.
.8aae	80 bd		bra $8a6d			bra 	_TIBMainLoop
.8ab0					_TIBExit:
.8ab0	7a		ply				ply
.8ab1	fa		plx				plx
.8ab2	68		pla				pla
.8ab3	60		rts				rts
.8ab4					TOKWriteToken:
.8ab4	da		phx				phx
.8ab5	a6 19		ldx $19				ldx 	TokenOffset
.8ab7	9d 00 0a	sta $0a00,x			sta 	TokenBuffer,x
.8aba	9e 01 0a	stz $0a01,x			stz 	TokenBuffer+1,x
.8abd	e6 19		inc $19				inc 	TokenOffset
.8abf	fa		plx				plx
.8ac0	60		rts				rts
.8ac1					TOKFixUpLast:
.8ac1	da		phx				phx
.8ac2	a6 19		ldx $19				ldx 	TokenOffset
.8ac4	bd ff 09	lda $09ff,x			lda 	TokenBuffer-1,x
.8ac7	09 e0		ora #$e0			ora 	#$E0
.8ac9	9d ff 09	sta $09ff,x			sta 	TokenBuffer-1,x
.8acc	fa		plx				plx
.8acd	60		rts				rts
.8ace					TOKConvertIdentifier:
.8ace	c9 2e		cmp #$2e			cmp 	#"."						; dot is special case.
.8ad0	f0 0f		beq $8ae1			beq 	_TKCIDot
.8ad2	38		sec				sec 								; A-Z -> 1-27
.8ad3	e9 40		sbc #$40			sbc 	#64
.8ad5	f0 08		beq $8adf			beq 	_TKCIFail
.8ad7	c9 1b		cmp #$1b			cmp 	#27
.8ad9	b0 04		bcs $8adf			bcs 	_TKCIFail
.8adb	09 c0		ora #$c0			ora 	#$C0 						; fix up
.8add	38		sec				sec
.8ade	60		rts				rts
.8adf					_TKCIFail:
.8adf	18		clc				clc
.8ae0	60		rts				rts
.8ae1					_TKCIDot:
.8ae1	a9 db		lda #$db			lda 	#$C0+27
.8ae3	38		sec				sec
.8ae4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_check_call.asm

.8ae5					TOKCheckIdentifierIsCall:
.8ae5	48		pha				pha
.8ae6	da		phx				phx
.8ae7	5a		phy				phy
.8ae8	85 04		sta $04				sta 	zTemp1
.8aea	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8aec	85 02		sta $02				sta 	zTemp0
.8aee	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.8af0	85 03		sta $03				sta 	zTemp0+1
.8af2					_TKCIILoop:
.8af2	b2 02		lda ($02)			lda 	(zTemp0) 					; reached the end
.8af4	f0 3d		beq $8b33			beq 	_TKCIIExit
.8af6	a0 03		ldy #$03			ldy 	#3							; check if definition
.8af8	b1 02		lda ($02),y			lda 	(zTemp0),y
.8afa	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8afc	d0 28		bne $8b26			bne 	_TKCIINext 					; if not skip.
.8afe	a6 04		ldx $04				ldx 	zTemp1 						; position of identifier.
.8b00	c8		iny				iny 								; skip count
.8b01					_TKCIICheck:
.8b01	c8		iny				iny
.8b02	bd 00 0a	lda $0a00,x			lda 	TokenBuffer,x 				; compare identifiers
.8b05	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8b07	d0 1d		bne $8b26			bne 	_TKCIINext
.8b09	e8		inx				inx
.8b0a	c9 e0		cmp #$e0			cmp 	#$E0						; go back if not end identifier.
.8b0c	90 f3		bcc $8b01			bcc 	_TKCIICheck
.8b0e	a5 04		lda $04				lda 	zTemp1 						; get identifier position
.8b10	85 19		sta $19				sta 	TokenOffset 				; reset it.
.8b12	a9 02		lda #$02			lda 	#KWD_SYS_CALL 				; write call
.8b14	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b17	a0 01		ldy #$01			ldy 	#1
.8b19	b1 02		lda ($02),y			lda 	(zTemp0),y
.8b1b	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b1e	c8		iny				iny
.8b1f	b1 02		lda ($02),y			lda 	(zTemp0),y
.8b21	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b24	80 0d		bra $8b33			bra 	_TKCIIExit 					; and exit.
.8b26					_TKCIINext:
.8b26	18		clc				clc
.8b27	b2 02		lda ($02)			lda 	(zTemp0)
.8b29	65 02		adc $02				adc 	zTemp0
.8b2b	85 02		sta $02				sta 	zTemp0
.8b2d	90 c3		bcc $8af2			bcc 	_TKCIILoop
.8b2f	e6 03		inc $03				inc 	zTemp0+1
.8b31	80 bf		bra $8af2			bra 	_TKCIILoop
.8b33					_TKCIIExit:
.8b33	7a		ply				ply
.8b34	fa		plx				plx
.8b35	68		pla				pla
.8b36	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_const.asm

.8b37					TOKConvertConstant:
.8b37	a0 08		ldy #$08			ldy 	#InputBuffer >> 8 			; the buffer must be on a $00 page.
.8b39	da		phx				phx 								; save X position
.8b3a	20 77 88	jsr $8877			jsr 	StringToInt 				; try to convert
.8b3d	90 40		bcc $8b7f			bcc 	_TKCCError
.8b3f	84 03		sty $03				sty 	zTemp0+1 					; save result in zTemp0
.8b41	86 02		stx $02				stx 	zTemp0
.8b43	85 04		sta $04				sta 	zTemp1 						; save count
.8b45	68		pla				pla 								; restore X position, add the count
.8b46	18		clc				clc
.8b47	65 04		adc $04				adc 	zTemp1
.8b49	aa		tax				tax
.8b4a	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; followed by - ?
.8b4d	c9 2d		cmp #$2d			cmp 	#"-"
.8b4f	d0 0e		bne $8b5f			bne 	_TKCCNotNegative
.8b51	e8		inx				inx 								; consume the -
.8b52	38		sec				sec
.8b53	a9 00		lda #$00			lda 	#0 							; negate the constant.
.8b55	e5 02		sbc $02				sbc 	zTemp0
.8b57	85 02		sta $02				sta 	zTemp0
.8b59	a9 00		lda #$00			lda 	#0
.8b5b	e5 03		sbc $03				sbc 	zTemp0+1
.8b5d	85 03		sta $03				sta 	zTemp0+1
.8b5f					_TKCCNotNegative:
.8b5f	a5 03		lda $03				lda 	zTemp0+1 					; check short/long const ?
.8b61	d0 0c		bne $8b6f			bne 	_TKCCLongConstant
.8b63	a5 02		lda $02				lda 	zTemp0
.8b65	c9 40		cmp #$40			cmp 	#$40
.8b67	b0 06		bcs $8b6f			bcs 	_TKCCLongConstant
.8b69	09 80		ora #$80			ora 	#$80 						; write the short token out with bit 7 set
.8b6b	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b6e	60		rts				rts
.8b6f					_TKCCLongConstant:
.8b6f	a9 01		lda #$01			lda 	#KWD_SYS_CONST 				; write out long constant
.8b71	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b74	a5 02		lda $02				lda 	zTemp0
.8b76	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b79	a5 03		lda $03				lda 	zTemp0+1
.8b7b	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b7e	60		rts				rts
.8b7f					_TKCCError:
.8b7f	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8b82	43 4f 4e 53 54 3f 00				.text 	"CONST?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_def.asm

.8b89					TOKConvertDefinition:
.8b89	e8		inx				inx 								; skip over :
.8b8a	a9 05		lda #$05			lda 	#KWD_SYS_DEFINE 			; output define token
.8b8c	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8b8f					TOKConvertIdentifierOnly:
.8b8f	64 02		stz $02				stz 	zTemp0 						; count how many identifiers.
.8b91	da		phx				phx
.8b92					_TKCDCount:
.8b92	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8b95	20 ce 8a	jsr $8ace			jsr 	TOKConvertIdentifier
.8b98	90 05		bcc $8b9f			bcc 	_TKCDCounted
.8b9a	e8		inx				inx
.8b9b	e6 02		inc $02				inc 	zTemp0
.8b9d	80 f3		bra $8b92			bra 	_TKCDCount
.8b9f					_TKCDCounted:
.8b9f	a5 02		lda $02				lda 	zTemp0 						; get count
.8ba1	f0 16		beq $8bb9			beq 	_TKCDFail 					; can't be none
.8ba3	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken 				; write count
.8ba6	fa		plx				plx 								; restore X
.8ba7					_TKCDLoop:
.8ba7	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; output that many tokens.
.8baa	e8		inx				inx
.8bab	20 ce 8a	jsr $8ace			jsr 	TOKConvertIdentifier
.8bae	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8bb1	c6 02		dec $02				dec 	zTemp0
.8bb3	d0 f2		bne $8ba7			bne 	_TKCDLoop
.8bb5	20 c1 8a	jsr $8ac1			jsr 	TOKFixUpLast 				; set bit for last character.
.8bb8	60		rts				rts
.8bb9					_TKCDFail:
.8bb9	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8bbc	49 44 45 4e 54 49 46 49				.text 	"IDENTIFIER?",0
>8bc4	45 52 3f 00
.8bc8					TOKCopyIdentifier:
.8bc8	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8bcb	20 ce 8a	jsr $8ace			jsr 	TOKConvertIdentifier
.8bce	90 13		bcc $8be3			bcc 	_TKCIError
.8bd0					_TKCILoop:
.8bd0	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; get and output token till not found
.8bd3	e8		inx				inx
.8bd4	20 ce 8a	jsr $8ace			jsr 	TOKConvertIdentifier
.8bd7	90 05		bcc $8bde			bcc 	_TKCIEnd
.8bd9	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8bdc	80 f2		bra $8bd0			bra 	_TKCILoop
.8bde					_TKCIEnd:
.8bde	ca		dex				dex
.8bdf	20 c1 8a	jsr $8ac1			jsr 	TOKFixUpLast 				; set bit for last character.
.8be2	60		rts				rts
.8be3					_TKCIError:
.8be3	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8be6	50 41 52 53 45 3f 00				.text 	"PARSE?",0

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_cst.asm

.8bed					TOKConvertCommentString:
.8bed	c9 27		cmp #$27			cmp 	#"'"						; is it a comment
.8bef	f0 06		beq $8bf7			beq 	_TKCCSComment
.8bf1	a9 04		lda #$04			lda 	#KWD_SYS_QSTRING 			; token
.8bf3	a0 22		ldy #$22			ldy 	#'"'						; match character
.8bf5	80 04		bra $8bfb			bra 	_TKCCSContinue
.8bf7					_TKCCSComment:
.8bf7	a9 03		lda #$03			lda 	#KWD_SYS_COMMENT 			; token
.8bf9	a0 00		ldy #$00			ldy 	#0 							; match character
.8bfb					_TKCCSContinue:
.8bfb	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken 				; write initial token
.8bfe	e8		inx				inx 								; skip over ' or "
.8bff	84 02		sty $02				sty 	zTemp0 						; closing token to search for.
.8c01	a0 00		ldy #$00			ldy 	#0 							; count of characters
.8c03	da		phx				phx 								; save start position
.8c04					_TKCCSFindSize:
.8c04	bd 00 08	lda $0800,x			lda 	InputBuffer,x 				; found the end
.8c07	c5 02		cmp $02				cmp 	zTemp0
.8c09	f0 10		beq $8c1b			beq 	_TKCCSFoundEnd
.8c0b	e8		inx				inx 								; bump pos, count
.8c0c	c8		iny				iny
.8c0d	c9 00		cmp #$00			cmp 	#0 							; if end of line error - quote unmatched
.8c0f	d0 f3		bne $8c04			bne 	_TKCCSFindSize
.8c11	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8c14	51 55 4f 54 45 3f 00				.text 	"QUOTE?",0
.8c1b					_TKCCSFoundEnd:
.8c1b	98		tya				tya 								; length of element in Y
.8c1c	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8c1f	fa		plx				plx 								; restore start position and copy out
.8c20					_TKCCSCopyOut:
.8c20	c0 00		cpy #$00			cpy 	#0 							; complete ?
.8c22	f0 0a		beq $8c2e			beq 	_TKCCSExit
.8c24	bd 00 08	lda $0800,x			lda 	InputBuffer,x
.8c27	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken
.8c2a	e8		inx				inx
.8c2b	88		dey				dey
.8c2c	80 f2		bra $8c20			bra 	_TKCCSCopyOut
.8c2e					_TKCCSExit:
.8c2e	a5 02		lda $02				lda 	zTemp0 						; if closing token was non-zero, it's a quote so skip it
.8c30	f0 01		beq $8c33			beq 	_TKCSSNotComment
.8c32	e8		inx				inx
.8c33					_TKCSSNotComment:
.8c33	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: tokenise/tok_token.asm

.8c34					TOKCheckIsToken:
.8c34	a9 92		lda #$92			lda 	#(KeywordText) & $FF
.8c36	85 02		sta $02				sta 	zTemp0
.8c38	a9 80		lda #$80			lda 	#(KeywordText) >> 8
.8c3a	85 03		sta $03				sta 	zTemp0+1
.8c3c	64 04		stz $04				stz 	zTemp1 						; best match length
.8c3e	64 06		stz $06				stz 	zTemp2 						; current token.
.8c40					_TCTLoop:
.8c40	a0 01		ldy #$01			ldy 	#1 							; position to start comparing
.8c42	da		phx				phx 								; save start
.8c43					_TCTCompare:
.8c43	b1 02		lda ($02),y			lda 	(zTemp0),y 					; compare the characters using EOR.
.8c45	5d 00 08	eor $0800,x			eor 	InputBuffer,x 				; because bit 7 of keyword table => end of word.
.8c48	e8		inx				inx 								; bump both pointers.
.8c49	c8		iny				iny
.8c4a	0a		asl a				asl 	a 							; A will now be 0 if the same. CS => end.
.8c4b	d0 0e		bne $8c5b			bne 	_TCTNext 					; different, go to next.
.8c4d	90 f4		bcc $8c43			bcc 	_TCTCompare 				; still comparing.
.8c4f	b2 02		lda ($02)			lda 	(zTemp0) 					; get current length
.8c51	c5 04		cmp $04				cmp 	zTemp1						; best so far
.8c53	90 06		bcc $8c5b			bcc 	_TCTNext 					; if not, skip to next.
.8c55	85 04		sta $04				sta 	zTemp1 						; new best score
.8c57	a5 06		lda $06				lda 	zTemp2 						; copy current token to result
.8c59	85 07		sta $07				sta 	zTemp2+1
.8c5b					_TCTNext:
.8c5b	fa		plx				plx 								; restore start position.
.8c5c	e6 06		inc $06				inc 	zTemp2 						; increment current token.
.8c5e	b2 02		lda ($02)			lda 	(zTemp0) 					; add the length + 1 to the keyword pointer
.8c60	38		sec				sec
.8c61	65 02		adc $02				adc 	zTemp0
.8c63	85 02		sta $02				sta 	zTemp0
.8c65	90 02		bcc $8c69			bcc		_TCTNoCarry
.8c67	e6 03		inc $03				inc 	zTemp0+1
.8c69					_TCTNoCarry:
.8c69	b2 02		lda ($02)			lda 	(zTemp0)					; have we finished ?
.8c6b	d0 d3		bne $8c40			bne 	_TCTLoop 					; no, check the next keyword.
.8c6d	18		clc				clc
.8c6e	a5 04		lda $04				lda 	zTemp1 						; best length is zero, exit with CC
.8c70	f0 0b		beq $8c7d			beq 	_TCTExit
.8c72	8a		txa				txa 								; add that length to the input index.
.8c73	18		clc				clc
.8c74	65 04		adc $04				adc 	zTemp1
.8c76	aa		tax				tax
.8c77	a5 07		lda $07				lda 	zTemp2+1 					; token number
.8c79	20 b4 8a	jsr $8ab4			jsr 	TOKWriteToken 				; write it out.
.8c7c	38		sec				sec 								; set carry and exit
.8c7d					_TCTExit:
.8c7d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/list.asm

.8c7e					Cmd_List:
.8c7e	fa		plx				plx
.8c7f	64 06		stz $06				stz 	zTemp2						; clear the lowest-number
.8c81	64 07		stz $07				stz 	zTemp2+1
.8c83	e0 ff		cpx #$ff			cpx 	#$FF 						; empty stack
.8c85	f0 0b		beq $8c92			beq 	_CLNoStart
.8c87	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS in
.8c8a	85 06		sta $06				sta 	zTemp2
.8c8c	bd 00 07	lda $0700,x			lda 	highStack,x
.8c8f	85 07		sta $07				sta 	zTemp2+1
.8c91	ca		dex				dex
.8c92					_CLNoStart:
.8c92					_CLNoStartLine:
.8c92	a9 00		lda #$00			lda 	#(programStart) & $FF
.8c94	85 00		sta $00				sta 	codePtr
.8c96	a9 10		lda #$10			lda 	#(programStart) >> 8
.8c98	85 01		sta $01				sta 	codePtr+1
.8c9a					_CLILoop:
.8c9a	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.8c9c	f0 24		beq $8cc2			beq 	_CLIEnd
.8c9e	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.8ca0	38		sec				sec
.8ca1	b1 00		lda ($00),y			lda 	(codePtr),y
.8ca3	e5 06		sbc $06				sbc 	zTemp2
.8ca5	c8		iny				iny
.8ca6	b1 00		lda ($00),y			lda 	(codePtr),y
.8ca8	e5 07		sbc $07				sbc 	zTemp2+1
.8caa	90 09		bcc $8cb5			bcc 	_CLISkip
.8cac	da		phx				phx
.8cad	20 c5 8c	jsr $8cc5			jsr 	ListCurrent 				; list the line.
.8cb0	fa		plx				plx
.8cb1	c6 08		dec $08				dec 	zTemp3 						; done all lines
.8cb3	f0 0d		beq $8cc2			beq 	_CLIEnd
.8cb5					_CLISkip:
.8cb5	18		clc				clc
.8cb6	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.8cb8	65 00		adc $00				adc 	codePtr
.8cba	85 00		sta $00				sta 	codePtr
.8cbc	90 dc		bcc $8c9a			bcc 	_CLILoop
.8cbe	e6 01		inc $01				inc 	codePtr+1
.8cc0	80 d8		bra $8c9a			bra 	_CLILoop
.8cc2					_CLIEnd:
.8cc2	4c 1b 80	jmp $801b			jmp 	WarmStart
.8cc5					ListCurrent:
.8cc5	a9 02		lda #$02			lda 	#COL_GREEN
.8cc7	20 fc 85	jsr $85fc			jsr 	ExternColour
.8cca	a0 01		ldy #$01			ldy 	#1							; print line#
.8ccc	b1 00		lda ($00),y			lda 	(codePtr),y
.8cce	aa		tax				tax
.8ccf	c8		iny				iny
.8cd0	b1 00		lda ($00),y			lda 	(codePtr),y
.8cd2	a8		tay				tay
.8cd3	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.8cd6	a8		tay				tay
.8cd7					_LCPadOut:
.8cd7	a9 20		lda #$20			lda 	#' '
.8cd9	20 f2 85	jsr $85f2			jsr 	ExternPrint
.8cdc	c8		iny				iny
.8cdd	c0 06		cpy #$06			cpy 	#6
.8cdf	d0 f6		bne $8cd7			bne 	_LCPadOut
.8ce1	a0 03		ldy #$03			ldy 	#3 							; start here
.8ce3	64 17		stz $17				stz 	PrefixCharacter				; no prefix
.8ce5					_LCLoop:
.8ce5	b1 00		lda ($00),y			lda 	(codePtr),y 				; [ ] never have a prefix.
.8ce7	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.8ce9	f0 0b		beq $8cf6			beq 	_LCNoPrefix
.8ceb	c9 24		cmp #$24			cmp 	#KWD_RSQPAREN
.8ced	f0 07		beq $8cf6			beq 	_LCNoPrefix
.8cef	a5 17		lda $17				lda 	PrefixCharacter 			; output prefix, reset to space
.8cf1	f0 03		beq $8cf6			beq		_LCNoPrefix
.8cf3	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8cf6					_LCNoPrefix:
.8cf6	a9 20		lda #$20			lda 	#32
.8cf8	85 17		sta $17				sta 	PrefixCharacter
.8cfa	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next
.8cfc	f0 13		beq $8d11			beq 	_LCExit
.8cfe	10 4d		bpl $8d4d			bpl 	_LCIsToken 					; +ve goto token.
.8d00	c9 c0		cmp #$c0			cmp 	#$C0 						; C0-FF
.8d02	b0 13		bcs $8d17			bcs 	_LCIsIdentifier
.8d04	29 3f		and #$3f			and 	#$3F 						; 80-BF 0-63
.8d06	aa		tax				tax
.8d07	c8		iny				iny
.8d08	5a		phy				phy 								; push pos
.8d09	a0 00		ldy #$00			ldy 	#0
.8d0b	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.8d0e	7a		ply				ply
.8d0f	80 d4		bra $8ce5			bra 	_LCLoop
.8d11					_LCExit:
.8d11	a9 0d		lda #$0d			lda 	#13
.8d13	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8d16	60		rts				rts
.8d17					_LCIsIdentifier:
.8d17					_LCIdentLoop:
.8d17	b1 00		lda ($00),y			lda 	(codePtr),y 				; keep printing
.8d19	20 2a 8e	jsr $8e2a			jsr 	ListPrintIDChar
.8d1c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get current
.8d1e	c8		iny				iny
.8d1f	c9 e0		cmp #$e0			cmp 	#$E0 						; was it an end marker
.8d21	b0 c2		bcs $8ce5			bcs 	_LCLoop 					; if so, do next
.8d23	80 f2		bra $8d17			bra 	_LCIdentLoop				; if not loop round
.8d25					_LCConstant:
.8d25	c8		iny				iny
.8d26	b1 00		lda ($00),y			lda 	(codePtr),y 				; get LSB into X
.8d28	aa		tax				tax
.8d29	c8		iny				iny 								; get MSB into Y
.8d2a	b1 00		lda ($00),y			lda 	(codePtr),y
.8d2c	c8		iny				iny
.8d2d	5a		phy				phy
.8d2e	a8		tay				tay
.8d2f	5a		phy				phy 								; save sign
.8d30	10 0c		bpl $8d3e			bpl 	_LCNotNegative
.8d32	98		tya				tya 								; YX = |YX|
.8d33	49 ff		eor #$ff			eor 	#$FF
.8d35	a8		tay				tay
.8d36	8a		txa				txa
.8d37	49 ff		eor #$ff			eor 	#$FF
.8d39	aa		tax				tax
.8d3a	e8		inx				inx
.8d3b	d0 01		bne $8d3e			bne 	_LCNotNegative
.8d3d	c8		iny				iny
.8d3e					_LCNotNegative:
.8d3e					_LCPrintYX:
.8d3e	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.8d41	68		pla				pla 								; restore sign
.8d42	10 05		bpl $8d49			bpl 	_LCNoTrail
.8d44	a9 2d		lda #$2d			lda 	#"-"
.8d46	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8d49					_LCNoTrail:
.8d49	7a		ply				ply 								; restore Y
.8d4a	4c e5 8c	jmp $8ce5			jmp 	_LCLoop
.8d4d					_LCIsToken:
.8d4d	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 				; check for constant.
.8d4f	f0 d4		beq $8d25			beq 	_LCConstant
.8d51	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL
.8d53	90 3e		bcc $8d93			bcc 	_LCControl
.8d55					_LCIsKeywordToken:
.8d55	85 02		sta $02				sta 	zTemp0 						; save token #
.8d57	a9 92		lda #$92			lda 	#(KeywordText) & $FF
.8d59	85 04		sta $04				sta 	zTemp1
.8d5b	a9 80		lda #$80			lda 	#(KeywordText) >> 8
.8d5d	85 05		sta $05				sta 	zTemp1+1
.8d5f	5a		phy				phy 								; save code offset
.8d60					_LCForward:
.8d60	a5 02		lda $02				lda 	zTemp0 						; done if token number is zero.
.8d62	f0 0f		beq $8d73			beq 	_LCFoundToken
.8d64	c6 02		dec $02				dec 	zTemp0						; dec count.
.8d66	38		sec				sec 								; go to next keyword.
.8d67	b2 04		lda ($04)			lda 	(zTemp1)
.8d69	65 04		adc $04				adc 	zTemp1
.8d6b	85 04		sta $04				sta 	zTemp1
.8d6d	90 f1		bcc $8d60			bcc 	_LCForward
.8d6f	e6 05		inc $05				inc 	zTemp1+1
.8d71	80 ed		bra $8d60			bra 	_LCForward
.8d73					_LCFoundToken:
.8d73	a0 01		ldy #$01			ldy 	#1 							; output the token.
.8d75					_LCOutToken:
.8d75	b1 04		lda ($04),y			lda 	(zTemp1),y 					; print character
.8d77	29 7f		and #$7f			and 	#$7F
.8d79	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8d7c	b1 04		lda ($04),y			lda 	(zTemp1),y 					; reget, put bit 7 in C
.8d7e	c8		iny				iny
.8d7f	0a		asl a				asl 	a
.8d80	90 f3		bcc $8d75			bcc 	_LCOutToken
.8d82	7a		ply				ply 								; restore code offset
.8d83	b1 00		lda ($00),y			lda 	(codePtr),y 				; what did we print ?
.8d85	c8		iny				iny
.8d86	c9 22		cmp #$22			cmp 	#KWD_HAT 					; for ^ and [, do not print space following.
.8d88	f0 04		beq $8d8e			beq 	_LCCancelPrefix
.8d8a	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN
.8d8c	d0 02		bne $8d90			bne 	_LCGoLoop
.8d8e					_LCCancelPrefix:
.8d8e	64 17		stz $17				stz 	PrefixCharacter
.8d90					_LCGoLoop:
.8d90	4c e5 8c	jmp $8ce5			jmp 	_LCLoop
.8d93					_LCControl:
.8d93	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.8d95	f0 3b		beq $8dd2			beq 	_LCDecodeCall
.8d97	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8d99	f0 22		beq $8dbd			beq 	_LCDecodeDefine
.8d9b	5a		phy				phy 								; save Y
.8d9c	a0 22		ldy #$22			ldy 	#'"'						; setup for String
.8d9e	c9 04		cmp #$04			cmp 	#KWD_SYS_QSTRING
.8da0	f0 07		beq $8da9			beq 	_LCDecodeString
.8da2	a0 27		ldy #$27			ldy 	#"'"						; setup for comment
.8da4	a9 07		lda #$07			lda 	#COL_WHITE 					; highlight comment.
.8da6	20 fc 85	jsr $85fc			jsr 	ExternColour
.8da9					_LCDecodeString
.8da9	98		tya				tya
.8daa	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8dad	7a		ply				ply 								; restore Y pos
.8dae	48		pha				pha 								; save end character on stack.
.8daf	20 0a 8e	jsr $8e0a			jsr 	ListPrintCodeIdentifier
.8db2	68		pla				pla 								; last character
.8db3	c9 27		cmp #$27			cmp 	#"'"						; don't print last
.8db5	f0 03		beq $8dba			beq 	_LCEDNoQuote
.8db7	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8dba					_LCEDNoQuote:
.8dba	4c e5 8c	jmp $8ce5			jmp 	_LCLoop
.8dbd					_LCDecodeDefine:
.8dbd	a9 03		lda #$03			lda 	#COL_YELLOW 				; highlight definition.
.8dbf	20 fc 85	jsr $85fc			jsr 	ExternColour
.8dc2	a9 3a		lda #$3a			lda 	#":"
.8dc4	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8dc7	20 0a 8e	jsr $8e0a			jsr 	ListPrintCodeIdentifier
.8dca	a9 02		lda #$02			lda 	#COL_GREEN
.8dcc	20 fc 85	jsr $85fc			jsr 	ExternColour
.8dcf	4c e5 8c	jmp $8ce5			jmp 	_LCLoop
.8dd2					_LCDecodeCall:
.8dd2	a9 06		lda #$06			lda 	#COL_CYAN
.8dd4	20 fc 85	jsr $85fc			jsr 	ExternColour
.8dd7	c8		iny				iny 								; get line number into XA
.8dd8	b1 00		lda ($00),y			lda 	(codePtr),y
.8dda	48		pha				pha
.8ddb	c8		iny				iny
.8ddc	b1 00		lda ($00),y			lda 	(codePtr),y
.8dde	c8		iny				iny
.8ddf	aa		tax				tax
.8de0	68		pla				pla
.8de1	20 3c 8e	jsr $8e3c			jsr 	ListFindLine 				; find that line.
.8de4	90 19		bcc $8dff			bcc 	_LCNoDefinition
.8de6	5a		phy				phy
.8de7	a0 03		ldy #$03			ldy 	#3 							; look at first character
.8de9	b1 02		lda ($02),y			lda 	(zTemp0),y
.8deb	7a		ply				ply
.8dec	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.8dee	d0 0f		bne $8dff			bne 	_LCNoDefinition 			; not define
.8df0	5a		phy				phy
.8df1	a0 03		ldy #$03			ldy 	#3
.8df3	20 14 8e	jsr $8e14			jsr 	ListPrintIdentifier
.8df6	7a		ply				ply
.8df7	a9 02		lda #$02			lda 	#COL_GREEN
.8df9	20 fc 85	jsr $85fc			jsr 	ExternColour
.8dfc	4c e5 8c	jmp $8ce5			jmp 	_LCLoop
.8dff					_LCNoDefinition:
.8dff	a9 25		lda #$25			lda 	#"%"						; print a %
.8e01	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8e04	88		dey				dey 								; unpick Y changes
.8e05	88		dey				dey
.8e06	88		dey				dey
.8e07	4c 25 8d	jmp $8d25			jmp 	_LCConstant 				; output # as constant
.8e0a					ListPrintCodeIdentifier:
.8e0a	48		pha				pha 								; copy codePtr -> zTemp0
.8e0b	a5 00		lda $00				lda 	codePtr
.8e0d	85 02		sta $02				sta 	zTemp0
.8e0f	a5 01		lda $01				lda 	codePtr+1
.8e11	85 03		sta $03				sta 	zTemp0+1
.8e13	68		pla				pla
.8e14					ListPrintIdentifier:
.8e14	48		pha				pha
.8e15	da		phx				phx
.8e16	c8		iny				iny 								; skip over the type
.8e17	b1 02		lda ($02),y			lda 	(zTemp0),y 					; count in X
.8e19	aa		tax				tax
.8e1a					_LPILoop:
.8e1a	c8		iny				iny
.8e1b	e0 00		cpx #$00			cpx 	#0
.8e1d	f0 08		beq $8e27			beq 	_LPIExit
.8e1f	b1 02		lda ($02),y			lda 	(zTemp0),y
.8e21	20 2a 8e	jsr $8e2a			jsr 	ListPrintIDChar
.8e24	ca		dex				dex
.8e25	80 f3		bra $8e1a			bra 	_LPILoop
.8e27					_LPIExit:
.8e27	fa		plx				plx
.8e28	68		pla				pla
.8e29	60		rts				rts
.8e2a					ListPrintIDChar:
.8e2a	c9 00		cmp #$00			cmp 	#0 							; check if ID char, if not just print
.8e2c	10 0a		bpl $8e38			bpl	 	_LCNotDot
.8e2e	29 1f		and #$1f			and 	#$1F 						; 1-26 A-Z 27 .
.8e30	09 40		ora #$40			ora 	#$40 						; ASCII except .
.8e32	c9 5b		cmp #$5b			cmp 	#$40+27
.8e34	d0 02		bne $8e38			bne 	_LCNotDot
.8e36	a9 2e		lda #$2e			lda 	#"."
.8e38					_LCNotDot:
.8e38	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.8e3b	60		rts				rts
.8e3c					ListFindLine:
.8e3c	5a		phy				phy
.8e3d	86 05		stx $05				stx 	zTemp1+1
.8e3f	85 04		sta $04				sta 	zTemp1
.8e41	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.8e43	85 02		sta $02				sta 	zTemp0
.8e45	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.8e47	85 03		sta $03				sta 	zTemp0+1
.8e49					_LFLSearch:
.8e49	18		clc				clc									; reached the end.
.8e4a	b2 02		lda ($02)			lda 	(zTemp0)
.8e4c	f0 1d		beq $8e6b			beq 	_LFLExit 					; exit with CC
.8e4e	a0 01		ldy #$01			ldy 	#1
.8e50	a5 04		lda $04				lda 	zTemp1
.8e52	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8e54	d0 07		bne $8e5d			bne 	_LFLNext
.8e56	c8		iny				iny
.8e57	a5 05		lda $05				lda 	zTemp1+1
.8e59	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8e5b	f0 0d		beq $8e6a			beq 	_LFLFound
.8e5d					_LFLNext:
.8e5d	18		clc				clc
.8e5e	b2 02		lda ($02)			lda 	(zTemp0)
.8e60	65 02		adc $02				adc 	zTemp0
.8e62	85 02		sta $02				sta 	zTemp0
.8e64	90 e3		bcc $8e49			bcc 	_LFLSearch
.8e66	e6 03		inc $03				inc 	zTemp0+1
.8e68	80 df		bra $8e49			bra 	_LFLSearch
.8e6a					_LFLFound:
.8e6a	38		sec				sec
.8e6b					_LFLExit:
.8e6b	7a		ply				ply
.8e6c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/memory.asm

.8e6d					Mem_Peek:
.8e6d	fa		plx				plx
.8e6e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8e71	85 02		sta $02				sta 	zTemp0
.8e73	bd 00 07	lda $0700,x			lda 	highStack,x
.8e76	85 03		sta $03				sta 	zTemp0+1
.8e78	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.8e7a	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.8e7d	9e 00 07	stz $0700,x			stz 	highStack,x
.8e80	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8e83					Mem_WPeek:
.8e83	fa		plx				plx
.8e84	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8e87	85 02		sta $02				sta 	zTemp0
.8e89	bd 00 07	lda $0700,x			lda 	highStack,x
.8e8c	85 03		sta $03				sta 	zTemp0+1
.8e8e	b2 02		lda ($02)			lda 	(zTemp0)					; read byte
.8e90	9d 00 06	sta $0600,x			sta 	lowStack,x 					; write to stack
.8e93	5a		phy				phy 								; read msb
.8e94	a0 01		ldy #$01			ldy 	#1
.8e96	b1 02		lda ($02),y			lda 	(zTemp0),y
.8e98	7a		ply				ply
.8e99	9d 00 07	sta $0700,x			sta 	highStack,x 				; write to stack
.8e9c	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8e9f					Mem_Poke:
.8e9f	fa		plx				plx
.8ea0	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8ea3	85 02		sta $02				sta 	zTemp0
.8ea5	bd 00 07	lda $0700,x			lda 	highStack,x
.8ea8	85 03		sta $03				sta 	zTemp0+1
.8eaa	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8ead	92 02		sta ($02)			sta 	(zTemp0)
.8eaf	ca		dex				dex
.8eb0	ca		dex				dex
.8eb1	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8eb4					Mem_WPoke:
.8eb4	fa		plx				plx
.8eb5	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8eb8	85 02		sta $02				sta 	zTemp0
.8eba	bd 00 07	lda $0700,x			lda 	highStack,x
.8ebd	85 03		sta $03				sta 	zTemp0+1
.8ebf	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8ec2	92 02		sta ($02)			sta 	(zTemp0)
.8ec4	5a		phy				phy
.8ec5	a0 01		ldy #$01			ldy 	#1
.8ec7	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.8eca	91 02		sta ($02),y			sta 	(zTemp0),y
.8ecc	7a		ply				ply
.8ecd	ca		dex				dex
.8ece	ca		dex				dex
.8ecf	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8ed2					Mem_DWPoke:
.8ed2	fa		plx				plx
.8ed3	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy address
.8ed6	85 02		sta $02				sta 	zTemp0
.8ed8	bd 00 07	lda $0700,x			lda 	highStack,x
.8edb	85 03		sta $03				sta 	zTemp0+1
.8edd	bd ff 05	lda $05ff,x			lda 	lowStack-1,x 				; byte to write
.8ee0	92 02		sta ($02)			sta 	(zTemp0)
.8ee2	bd ff 06	lda $06ff,x			lda 	highStack-1,x 				; byte to write
.8ee5	92 02		sta ($02)			sta 	(zTemp0)
.8ee7	ca		dex				dex
.8ee8	ca		dex				dex
.8ee9	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8eec					Mem_Alloc:
.8eec	fa		plx				plx
.8eed	38		sec				sec 								; subtract count from alloc ptr
.8eee	a5 11		lda $11				lda 	allocPtr
.8ef0	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.8ef3	85 11		sta $11				sta 	allocPtr
.8ef5	48		pha				pha 								; save low.
.8ef6	a5 12		lda $12				lda 	allocPtr+1
.8ef8	fd 00 07	sbc $0700,x			sbc 	highStack,x
.8efb	85 12		sta $12				sta 	allocPtr+1
.8efd	90 10		bcc $8f0f			bcc 	_MAError 					; borrow ?
.8eff	c5 14		cmp $14				cmp 	memVarPtr+1 				; if <= memVarPtr then error ?
.8f01	90 0c		bcc $8f0f			bcc 	_MAError
.8f03	f0 0a		beq $8f0f			beq 	_MAError
.8f05	9d 00 07	sta $0700,x			sta 	highStack,x 				; update address
.8f08	68		pla				pla
.8f09	9d 00 06	sta $0600,x			sta 	lowStack,x
.8f0c	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8f0f					_MAError:
.8f0f	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8f12	4d 45 4d 4f 52 59 3f 00				.text 	"MEMORY?",0

;******  Return to file: main.asm


;******  Processing file: words/saveload.asm

.8f1a					System_Save:
.8f1a	fa		plx				plx
.8f1b	da		phx				phx
.8f1c	20 11 88	jsr $8811			jsr 	ResetVarMemory 				; make sure start/end are right
.8f1f	20 46 8f	jsr $8f46			jsr 	SLGetFileName 				; get filename -> zTemp0
.8f22	a5 13		lda $13				lda 	memVarPtr 					; end address
.8f24	85 04		sta $04				sta 	zTemp1
.8f26	a5 14		lda $14				lda 	memVarPtr+1
.8f28	85 05		sta $05				sta 	zTemp1+1
.8f2a	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.8f2c	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.8f2e	20 49 86	jsr $8649			jsr 	ExternSave
.8f31	7a		ply				ply
.8f32	4c 1b 80	jmp $801b			jmp 	WarmStart
.8f35					System_Load:
.8f35	fa		plx				plx
.8f36	20 46 8f	jsr $8f46			jsr 	SLGetFileName 				; get filename -> zTemp0
.8f39	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.8f3b	a0 10		ldy #$10			ldy 	#ProgramStart >> 8
.8f3d	20 7f 86	jsr $867f			jsr 	ExternLoad
.8f40	20 f3 87	jsr $87f3			jsr 	ResetMemory 				; reset everything.
.8f43	4c 1b 80	jmp $801b			jmp 	WarmStart
.8f46					SLGetFileName:
.8f46	e0 ff		cpx #$ff			cpx 	#255 						; gotta be something on the stack
.8f48	f0 4a		beq $8f94			beq 	_SLFNFail
.8f4a	bd 00 07	lda $0700,x			lda 	highStack,x 				; should be something in token buffer
.8f4d	c9 0a		cmp #$0a			cmp 	#TokenBuffer >> 8
.8f4f	d0 43		bne $8f94			bne 	_SLFNFail
.8f51	85 05		sta $05				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.8f53	bd 00 06	lda $0600,x			lda 	lowStack,x
.8f56	85 04		sta $04				sta 	zTemp1
.8f58	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.8f5a	85 02		sta $02				sta 	zTemp0
.8f5c	a9 08		lda #$08			lda 	#InputBuffer >> 8
.8f5e	85 03		sta $03				sta 	zTemp0+1
.8f60	b2 04		lda ($04)			lda 	(zTemp1) 					; copy string to input buffer
.8f62	1a		inc a				inc 	a
.8f63	aa		tax				tax
.8f64	a0 00		ldy #$00			ldy 	#0
.8f66	b1 04		lda ($04),y	_SLCopy:lda 	(zTemp1),y
.8f68	91 02		sta ($02),y			sta 	(zTemp0),y
.8f6a	c8		iny				iny
.8f6b	ca		dex				dex
.8f6c	d0 f8		bne $8f66			bne 	_SLCopy
.8f6e	a2 03		ldx #$03			ldx 	#3 							; check if it ends in .RPL
.8f70					_SLCheckEnd:
.8f70	88		dey				dey
.8f71	bd a4 8f	lda $8fa4,x			lda 	_SLFNExtension,x
.8f74	d1 02		cmp ($02),y			cmp 	(zTemp0),y
.8f76	d0 05		bne $8f7d			bne 	_SLNoExtension
.8f78	ca		dex				dex
.8f79	10 f5		bpl $8f70			bpl 	_SLCheckEnd
.8f7b	80 16		bra $8f93			bra 	_SLExit
.8f7d					_SLNoExtension:
.8f7d	a0 00		ldy #$00			ldy 	#0							; add the extension.
.8f7f					_SLExtend:
.8f7f	ee 00 08	inc $0800			inc 	InputBuffer
.8f82	ae 00 08	ldx $0800			ldx 	InputBuffer
.8f85	b9 a4 8f	lda $8fa4,y			lda 	_SLFNExtension,y
.8f88	c8		iny				iny
.8f89	9d 00 08	sta $0800,x			sta 	InputBuffer,x
.8f8c	c9 00		cmp #$00			cmp		#0
.8f8e	d0 ef		bne $8f7f			bne 	_SLExtend
.8f90	ce 00 08	dec $0800			dec 	InputBuffer 				; because wrote the $00
.8f93					_SLExit:
.8f93	60		rts				rts
.8f94					_SLFNFail:
.8f94	20 9c 84	jsr $849c			jsr 	ErrorHandler
>8f97	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>8f9f	4e 41 4d 45 00
.8fa4					_SLFNExtension:
>8fa4	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: words/stack.asm

.8fa9					Stack_Empty:
.8fa9	fa		plx				plx
.8faa	a2 00		ldx #$00			ldx 	#0
.8fac	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8faf					Stack_Drop:
.8faf	fa		plx				plx
.8fb0	ca		dex				dex
.8fb1	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8fb4					Stack_Dup:
.8fb4	fa		plx				plx
.8fb5	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to next up
.8fb8	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.8fbb	bd 00 07	lda $0700,x			lda 	highStack,x
.8fbe	9d 01 07	sta $0701,x			sta 	highStack+1,x
.8fc1	e8		inx				inx 								; bump stack pointer
.8fc2	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8fc5					Stack_Nip:
.8fc5	fa		plx				plx
.8fc6	bd 00 06	lda $0600,x			lda 	lowStack,x	 				; copy top to 2nd
.8fc9	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.8fcc	bd 00 07	lda $0700,x			lda 	highStack,x
.8fcf	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.8fd2	ca		dex				dex 								; drop tos
.8fd3	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8fd6					Stack_Over:
.8fd6	fa		plx				plx
.8fd7	bd ff 05	lda $05ff,x			lda 	lowStack-1,x				; copy to next up
.8fda	9d 01 06	sta $0601,x			sta 	lowStack+1,x
.8fdd	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.8fe0	9d 01 07	sta $0701,x			sta 	highStack+1,x
.8fe3	e8		inx				inx 							; bump stack pointer
.8fe4	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.8fe7					Stack_Swap:
.8fe7	fa		plx				plx
.8fe8	5a		phy				phy
.8fe9	bd 00 06	lda $0600,x			lda 	lowStack,x
.8fec	a8		tay				tay
.8fed	bd ff 05	lda $05ff,x			lda 	lowStack-1,x
.8ff0	9d 00 06	sta $0600,x			sta 	lowStack,x
.8ff3	98		tya				tya
.8ff4	9d ff 05	sta $05ff,x			sta 	lowStack-1,x
.8ff7	bd 00 07	lda $0700,x			lda 	highStack,x
.8ffa	a8		tay				tay
.8ffb	bd ff 06	lda $06ff,x			lda 	highStack-1,x
.8ffe	9d 00 07	sta $0700,x			sta 	highStack,x
.9001	98		tya				tya
.9002	9d ff 06	sta $06ff,x			sta 	highStack-1,x
.9005	7a		ply				ply
.9006	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/store.asm

.9009					Command_Store:
.9009	fa		plx				plx
.900a	b1 00		lda ($00),y			lda 	(codePtr),y 				; next character
.900c	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a single letter variable ?
.900e	90 1f		bcc $902f			bcc 	_CSLongVariable
.9010	c8		iny				iny 								; get the next
.9011	b1 00		lda ($00),y			lda 	(codePtr),y
.9013	88		dey				dey
.9014	c9 23		cmp #$23			cmp 	#KWD_LSQPAREN 				; followed by indexing, use long variable
.9016	f0 17		beq $902f			beq 	_CSLongVariable
.9018	b1 00		lda ($00),y			lda 	(codePtr),y 				; get variable back.
.901a	c8		iny				iny 								; skip over it and push on stack
.901b	5a		phy				phy
.901c	0a		asl a				asl 	a 							; double it, now C0-FE
.901d	a8		tay				tay 								; put in Y
.901e	bd 00 06	lda $0600,x			lda 	lowStack,x 					; copy TOS into it
.9021	99 40 0e	sta $0e40,y			sta 	FastVariables-$C0,y
.9024	bd 00 07	lda $0700,x			lda 	highStack,x
.9027	99 41 0e	sta $0e41,y			sta 	FastVariables-$C0+1,y
.902a	ca		dex				dex 								; pop off stack
.902b	7a		ply				ply 								; restore position and do next
.902c	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.902f					_CSLongVariable:
.902f	38		sec				sec 								; create variable if not found.
.9030	20 47 89	jsr $8947			jsr 	VariableFind 				; find it - create if not - is in zTemp0
.9033	20 ba 86	jsr $86ba			jsr 	IndexCheck 					; check indexing.
.9036	bd 00 06	lda $0600,x			lda 	lowStack,x					; write it out.
.9039	92 02		sta ($02)			sta 	(zTemp0)
.903b	5a		phy				phy
.903c	a0 01		ldy #$01			ldy 	#1
.903e	bd 00 07	lda $0700,x			lda 	highStack,x
.9041	91 02		sta ($02),y			sta 	(zTemp0),y
.9043	7a		ply				ply
.9044	ca		dex				dex 								; pop off stack
.9045	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/system.asm

.9048					Command_New:
.9048	fa		plx				plx
.9049	9c 00 10	stz $1000			stz 	ProgramStart
.904c	4c 1b 80	jmp $801b			jmp 	WarmStart
.904f					Command_Old:
.904f	fa		plx				plx
.9050	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.9052	85 00		sta $00				sta 	codePtr
.9054	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.9056	85 01		sta $01				sta 	codePtr+1
.9058	a0 03		ldy #$03			ldy 	#3
.905a					_COAdvance:
.905a	c0 c0		cpy #$c0			cpy 	#192 						; first lines > this can't be recovered
.905c	b0 0e		bcs $906c			bcs		_COFail
.905e	20 80 94	jsr $9480			jsr 	AdvanceInCode
.9061	b1 00		lda ($00),y			lda 	(codePtr),y
.9063	d0 f5		bne $905a			bne 	_COAdvance
.9065	c8		iny				iny 								; byte after end of line
.9066	8c 00 10	sty $1000			sty 	ProgramStart 				; overwrite first byte with offset.
.9069					_CONotDeleted:
.9069	4c 1b 80	jmp $801b			jmp 	WarmStart
.906c					_COFail:
.906c	20 9c 84	jsr $849c			jsr 	ErrorHandler
>906f	43 41 4e 54 3f 00				.text 	"CANT?",0
.9075					Command_End:
.9075	fa		plx				plx
.9076	4c 1b 80	jmp $801b			jmp 	WarmStart
.9079					Command_Stop:
>9079	ff						.byte 	$FF
.907a	fa		plx				plx
.907b	20 9c 84	jsr $849c			jsr 	ErrorHandler
>907e	53 54 4f 50 00					.text 	"STOP",0
.9083					Command_Assert:
.9083	fa		plx				plx
.9084	bd 00 06	lda $0600,x			lda 	lowStack,x 					; check TOS = 0 ?
.9087	1d 00 07	ora $0700,x			ora 	highStack,x
.908a	f0 04		beq $9090			beq 	_CAFail
.908c	ca		dex				dex 								; throw if not.
.908d	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9090					_CAFail:
.9090	20 9c 84	jsr $849c			jsr 	ErrorHandler
>9093	41 53 53 45 52 54 00				.text 	"ASSERT",0
.909a					Command_Sys:
.909a	fa		plx				plx
.909b	bd 00 06	lda $0600,x			lda 	lowStack,x 					; save call address
.909e	85 02		sta $02				sta 	zTemp0
.90a0	bd 00 07	lda $0700,x			lda 	highStack,x
.90a3	85 03		sta $03				sta 	zTemp0+1
.90a5	ca		dex				dex 								; pop tos
.90a6	da		phx				phx 								; save XY
.90a7	5a		phy				phy
.90a8	ad 02 0f	lda $0f02			lda 	FastVariables+('A'-'A'+1)*2 ; load AXY
.90ab	ae 30 0f	ldx $0f30			ldx 	FastVariables+('X'-'A'+1)*2
.90ae	ac 32 0f	ldy $0f32			ldy 	FastVariables+('Y'-'A'+1)*2
.90b1	20 b9 90	jsr $90b9			jsr 	_CSCallInd
.90b4	7a		ply				ply 								; restore XY
.90b5	fa		plx				plx
.90b6	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.90b9					_CSCallInd:
.90b9	6c 02 00	jmp ($0002)			jmp 	(zTemp0)
.90bc					Command_DumpStack:
.90bc	fa		plx				plx
.90bd	da		phx				phx 								; save pos and sp
.90be	5a		phy				phy
.90bf	86 10		stx $10				stx 	SignCount
.90c1	a2 ff		ldx #$ff			ldx 	#$FF
.90c3					_CDSLoop:
.90c3	e4 10		cpx $10				cpx 	SignCount 					; done all ?
.90c5	f0 2a		beq $90f1			beq 	_CDSExit
.90c7	e8		inx				inx
.90c8	da		phx				phx 								; save SP
.90c9	bd 00 07	lda $0700,x			lda 	highStack,x 				; get tos
.90cc	a8		tay				tay
.90cd	bd 00 06	lda $0600,x			lda 	lowStack,x
.90d0	aa		tax				tax
.90d1	c0 00		cpy #$00			cpy 	#0
.90d3	10 11		bpl $90e6			bpl 	_CDSPositive
.90d5	a9 2d		lda #$2d			lda 	#"-" 						; minus
.90d7	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.90da	98		tya				tya 								; negate YX
.90db	49 ff		eor #$ff			eor 	#$FF
.90dd	a8		tay				tay
.90de	8a		txa				txa
.90df	49 ff		eor #$ff			eor 	#$FF
.90e1	aa		tax				tax
.90e2	e8		inx				inx
.90e3	d0 01		bne $90e6			bne 	_CDSPositive
.90e5	c8		iny				iny
.90e6					_CDSPositive:
.90e6	20 c9 84	jsr $84c9			jsr 	PrintIntegerUnsigned
.90e9	a9 20		lda #$20			lda 	#" " 						; space
.90eb	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.90ee	fa		plx				plx
.90ef	80 d2		bra $90c3			bra 	_CDSLoop
.90f1					_CDSExit:
.90f1	a9 3c		lda #$3c			lda 	#"<"
.90f3	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.90f6	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.90f9	a9 0d		lda #$0d			lda 	#13 						; CR
.90fb	20 e6 84	jsr $84e6			jsr 	PrintCharacter
.90fe	7a		ply				ply
.90ff	fa		plx				plx
.9100	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/binary.asm

.9103					Stack_Add:
.9103	fa		plx				plx
.9104	ca		dex				dex
.9105	18		clc				clc
.9106	bd 00 06	lda $0600,x			lda		lowStack,x
.9109	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.910c	9d 00 06	sta $0600,x			sta 	lowStack,x
.910f	bd 00 07	lda $0700,x			lda		highStack,x
.9112	7d 01 07	adc $0701,x			adc 	highStack+1,x
.9115	9d 00 07	sta $0700,x			sta 	highStack,x
.9118	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.911b					Stack_Sub:
.911b	fa		plx				plx
.911c	ca		dex				dex
.911d	38		sec				sec
.911e	bd 00 06	lda $0600,x			lda		lowStack,x
.9121	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.9124	9d 00 06	sta $0600,x			sta 	lowStack,x
.9127	bd 00 07	lda $0700,x			lda		highStack,x
.912a	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.912d	9d 00 07	sta $0700,x			sta 	highStack,x
.9130	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9133					Stack_And:
.9133	fa		plx				plx
.9134	ca		dex				dex
.9135	bd 00 06	lda $0600,x			lda		lowStack,x
.9138	3d 01 06	and $0601,x			and		lowStack+1,x
.913b	9d 00 06	sta $0600,x			sta 	lowStack,x
.913e	bd 00 07	lda $0700,x			lda		highStack,x
.9141	3d 01 07	and $0701,x			and 	highStack+1,x
.9144	9d 00 07	sta $0700,x			sta 	highStack,x
.9147	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.914a					Stack_Xor:
.914a	fa		plx				plx
.914b	ca		dex				dex
.914c	bd 00 06	lda $0600,x			lda		lowStack,x
.914f	5d 01 06	eor $0601,x			eor		lowStack+1,x
.9152	9d 00 06	sta $0600,x			sta 	lowStack,x
.9155	bd 00 07	lda $0700,x			lda		highStack,x
.9158	5d 01 07	eor $0701,x			eor 	highStack+1,x
.915b	9d 00 07	sta $0700,x			sta 	highStack,x
.915e	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9161					Stack_Or:
.9161	fa		plx				plx
.9162	ca		dex				dex
.9163	bd 00 06	lda $0600,x			lda		lowStack,x
.9166	1d 01 06	ora $0601,x			ora		lowStack+1,x
.9169	9d 00 06	sta $0600,x			sta 	lowStack,x
.916c	bd 00 07	lda $0700,x			lda		highStack,x
.916f	1d 01 07	ora $0701,x			ora 	highStack+1,x
.9172	9d 00 07	sta $0700,x			sta 	highStack,x
.9175	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9178					Stack_Shl:
.9178	fa		plx				plx
.9179	38		sec				sec
.917a	80 02		bra $917e			bra 	StackShift
.917c					Stack_Shr:
.917c	fa		plx				plx
.917d	18		clc				clc
.917e					StackShift:
.917e	08		php				php
.917f	ca		dex				dex
.9180	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; if the shift >= 32
.9183	29 e0		and #$e0			and 	#$E0 							; going to be zero.
.9185	1d 01 07	ora $0701,x			ora 	highStack+1,x
.9188	d0 19		bne $91a3			bne 	_SSZero
.918a					_SSLoop:
.918a	de 01 06	dec $0601,x			dec 	lowStack+1,x 				; dec check count
.918d	30 1a		bmi $91a9			bmi 	_SSDone 					; completed ?
.918f	28		plp				plp 								; restore flag
.9190	08		php				php
.9191	b0 08		bcs $919b			bcs 	_SSLeft 					; do either shift.
.9193	5e 00 07	lsr $0700,x			lsr 	highStack,x
.9196	7e 00 06	ror $0600,x			ror 	lowStack,x
.9199	80 ef		bra $918a			bra 	_SSLoop
.919b					_SSLeft:
.919b	1e 00 06	asl $0600,x			asl 	lowStack,x
.919e	3e 00 07	rol $0700,x			rol 	highStack,x
.91a1	80 e7		bra $918a			bra 	_SSLoop
.91a3					_SSZero:
.91a3	9e 00 06	stz $0600,x			stz 	lowStack,x 					; too many shifts.
.91a6	9e 00 07	stz $0700,x			stz 	highStack,x
.91a9					_SSDone:
.91a9	28		plp				plp 								; throw flag.
.91aa	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/compare.asm

.91ad					Comp_Equal:
.91ad	fa		plx				plx
.91ae	38		sec				sec
.91af	80 02		bra $91b3			bra 	Comp_CheckEqual
.91b1					Comp_NotEqual:
.91b1	fa		plx				plx
.91b2	18		clc				clc
.91b3					Comp_CheckEqual:
.91b3	08		php				php
.91b4	ca		dex				dex
.91b5	bd 00 06	lda $0600,x			lda		lowStack,x
.91b8	5d 01 06	eor $0601,x			eor 	lowStack+1,x
.91bb	d0 06		bne $91c3			bne 	_CCENonZero
.91bd	bd 00 07	lda $0700,x			lda		highStack,x
.91c0	5d 01 07	eor $0701,x			eor 	highStack+1,x
.91c3					_CCENonZero:
.91c3	f0 02		beq $91c7			beq 	_CCENotSet
.91c5	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.91c7					_CCENotSet:
.91c7					CompCheckFlip:
.91c7	28		plp				plp 								; if carry set, we want $FF if equal
.91c8	90 02		bcc $91cc			bcc 	CompReturn
.91ca	49 ff		eor #$ff			eor 	#$FF
.91cc					CompReturn:
.91cc	9d 00 06	sta $0600,x			sta 	lowStack,x 					; save result on stack.
.91cf	9d 00 07	sta $0700,x			sta 	highStack,x
.91d2	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.91d5					Comp_Less:
.91d5	fa		plx				plx
.91d6	18		clc				clc
.91d7	80 02		bra $91db			bra 	Comp_LessCont
.91d9					Comp_GreaterEqual:
.91d9	fa		plx				plx
.91da	38		sec				sec
.91db					Comp_LessCont:
.91db	08		php				php
.91dc	ca		dex				dex
.91dd	38		sec				sec
.91de	bd 00 06	lda $0600,x			lda 	lowStack,x 					; do a subtraction w/o storing the result
.91e1	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.91e4	bd 00 07	lda $0700,x			lda 	highStack,x
.91e7	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.91ea	50 02		bvc $91ee			bvc 	_CLNoFlip 					; unsigned -> signed
.91ec	49 80		eor #$80			eor 	#$80
.91ee					_CLNoFlip:
.91ee	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.91f0	f0 d5		beq $91c7			beq 	CompCheckFlip
.91f2	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.91f4	80 d1		bra $91c7			bra 	CompCheckFlip
.91f6					Comp_LessEqual:
.91f6	fa		plx				plx
.91f7	38		sec				sec
.91f8	80 02		bra $91fc			bra 	Comp_LessEqualCont
.91fa					Comp_Greater:
.91fa	fa		plx				plx
.91fb	18		clc				clc
.91fc					Comp_LessEqualCont:
.91fc	08		php				php
.91fd	ca		dex				dex
.91fe	38		sec				sec
.91ff	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; do a subtraction w/o storing the result, backwards
.9202	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.9205	bd 01 07	lda $0701,x			lda 	highStack+1,x
.9208	fd 00 07	sbc $0700,x			sbc 	highStack,x
.920b	50 02		bvc $920f			bvc 	_CLENoFlip 					; unsigned -> signed
.920d	49 80		eor #$80			eor 	#$80
.920f					_CLENoFlip:
.920f	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.9211	f0 b4		beq $91c7			beq 	CompCheckFlip
.9213	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.9215	80 b0		bra $91c7			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/divide.asm

.9217					DivInteger16:
.9217	fa		plx				plx
.9218	20 1e 92	jsr $921e			jsr 	IntegerDivide
.921b	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.921e					IntegerDivide:
.921e	ca		dex				dex
.921f	bd 01 06	lda $0601,x			lda 	lowStack+1,x 					; check for division by zero.
.9222	1d 01 07	ora $0701,x			ora 	highStack+1,x
.9225	d0 14		bne $923b			bne 	_BFDOkay
.9227	20 9c 84	jsr $849c			jsr 	ErrorHandler
>922a	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>9232	20 42 59 20 5a 45 52 4f 00
.923b					_BFDOkay:
.923b	64 04		stz $04				stz 	zTemp1 						; Q/Dividend/Left in +0
.923d	64 05		stz $05				stz 	zTemp1+1 					; M/Divisor/Right in +4
.923f	64 10		stz $10				stz 	SignCount 					; Count of signs.
.9241	20 7d 92	jsr $927d			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.9244	e8		inx				inx
.9245	20 7d 92	jsr $927d			jsr 	CheckIntegerNegate
.9248	ca		dex				dex
.9249	5a		phy				phy 								; Y is the counter
.924a	a0 10		ldy #$10			ldy 	#16 						; 16 iterations of the loop.
.924c					_BFDLoop:
.924c	1e 00 06	asl $0600,x			asl 	lowStack,x 					; shift AQ left.
.924f	3e 00 07	rol $0700,x			rol 	highStack,x
.9252	26 04		rol $04				rol 	zTemp1
.9254	26 05		rol $05				rol 	zTemp1+1
.9256	38		sec				sec
.9257	a5 04		lda $04				lda 	zTemp1+0 					; Calculate A-M on stack.
.9259	fd 01 06	sbc $0601,x			sbc 	lowStack+1,x
.925c	48		pha				pha
.925d	a5 05		lda $05				lda 	zTemp1+1
.925f	fd 01 07	sbc $0701,x			sbc 	highStack+1,x
.9262	90 0f		bcc $9273			bcc 	_BFDNoAdd
.9264	85 05		sta $05				sta 	zTemp1+1
.9266	68		pla				pla
.9267	85 04		sta $04				sta 	zTemp1+0
.9269	bd 00 06	lda $0600,x			lda 	lowStack,x 					; set Q bit 1.
.926c	09 01		ora #$01			ora 	#1
.926e	9d 00 06	sta $0600,x			sta 	lowStack,x
.9271	80 01		bra $9274			bra 	_BFDNext
.9273					_BFDNoAdd:
.9273	68		pla				pla 								; Throw away the intermediate calculations
.9274					_BFDNext:
.9274	88		dey				dey
.9275	d0 d5		bne $924c			bne 	_BFDLoop
.9277	7a		ply				ply 								; restore Y
.9278	46 10		lsr $10				lsr 	SignCount 					; if sign count odd,
.927a	b0 07		bcs $9283			bcs		IntegerNegateAlways 		; negate the result
.927c	60		rts				rts
.927d					CheckIntegerNegate:
.927d	bd 00 07	lda $0700,x			lda 	highStack,x 				; is it -ve = MSB set ?
.9280	30 01		bmi $9283			bmi 	IntegerNegateAlways 		; if so negate it
.9282	60		rts				rts
.9283					IntegerNegateAlways:
.9283	e6 10		inc $10				inc 	SignCount 					; bump the count of signs
.9285	4c e0 92	jmp $92e0			jmp 	Unary_Negate
.9288					ModInteger16:
.9288	fa		plx				plx
.9289	20 1e 92	jsr $921e			jsr 	IntegerDivide
.928c	a5 04		lda $04				lda 	zTemp1
.928e	9d 00 06	sta $0600,x			sta 	lowStack,x
.9291	a5 05		lda $05				lda 	zTemp1+1
.9293	9d 00 07	sta $0700,x			sta 	highStack,x
.9296	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/multiply.asm

.9299					MulInteger16:
.9299	fa		plx				plx
.929a	ca		dex				dex
.929b	bd 00 06	lda $0600,x			lda 	lowStack,x					; copy to workspace
.929e	85 04		sta $04				sta 	zTemp1
.92a0	bd 00 07	lda $0700,x			lda 	highStack,x
.92a3	85 05		sta $05				sta 	zTemp1+1
.92a5	9e 00 06	stz $0600,x			stz 	lowStack,x 					; zero where the result goes.
.92a8	9e 00 07	stz $0700,x			stz 	highStack,x
.92ab					_BFMMultiply:
.92ab	a5 04		lda $04				lda 	zTemp1 						; get LSBit
.92ad	29 01		and #$01			and 	#1
.92af	f0 13		beq $92c4			beq 	_BFMNoAdd
.92b1	18		clc				clc 								; add old tos to current tos.
.92b2	bd 00 06	lda $0600,x			lda		lowStack,x
.92b5	7d 01 06	adc $0601,x			adc 	lowStack+1,x
.92b8	9d 00 06	sta $0600,x			sta 	lowStack,x
.92bb	bd 00 07	lda $0700,x			lda		highStack,x
.92be	7d 01 07	adc $0701,x			adc 	highStack+1,x
.92c1	9d 00 07	sta $0700,x			sta 	highStack,x
.92c4					_BFMNoAdd:
.92c4	1e 01 06	asl $0601,x			asl 	lowStack+1,x 				; shift left
.92c7	3e 01 07	rol $0701,x			rol 	highStack+1,x
.92ca	46 05		lsr $05				lsr 	zTemp1+1 					; shift right
.92cc	66 04		ror $04				ror 	zTemp1+0
.92ce	a5 04		lda $04				lda 	zTemp1 						; continue if is nonzero
.92d0	05 05		ora $05				ora 	zTemp1+1
.92d2	d0 d7		bne $92ab			bne 	_BFMMultiply
.92d4	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/arithmetic/unary.asm

.92d7					Unary_Absolute:
.92d7	fa		plx				plx
.92d8	bd 00 07	lda $0700,x			lda 	highStack,x
.92db	30 04		bmi $92e1			bmi 	Unary_Negate_Code
.92dd	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.92e0					Unary_Negate:
.92e0	fa		plx				plx
.92e1					Unary_Negate_Code:
.92e1	38		sec				sec
.92e2	a9 00		lda #$00			lda		#0
.92e4	fd 00 06	sbc $0600,x			sbc 	lowStack,x
.92e7	9d 00 06	sta $0600,x			sta 	lowStack,x
.92ea	a9 00		lda #$00			lda		#0
.92ec	fd 00 07	sbc $0700,x			sbc 	highStack,x
.92ef	9d 00 07	sta $0700,x			sta 	highStack,x
.92f2	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.92f5					Unary_Not:
.92f5	fa		plx				plx
.92f6	bd 00 06	lda $0600,x			lda 	lowStack,x
.92f9	49 ff		eor #$ff			eor 	#$FF
.92fb	9d 00 06	sta $0600,x			sta 	lowStack,x
.92fe	bd 00 07	lda $0700,x			lda 	highStack,x
.9301	49 ff		eor #$ff			eor 	#$FF
.9303	9d 00 07	sta $0700,x			sta 	highStack,x
.9306	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9309					Unary_Increment:
.9309	fa		plx				plx
.930a	fe 00 06	inc $0600,x			inc 	lowStack,x
.930d	d0 03		bne $9312			bne 	_UIExit
.930f	fe 00 07	inc $0700,x			inc 	highStack,x
.9312					_UIExit:
.9312	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9315					Unary_Decrement:
.9315	fa		plx				plx
.9316	bd 00 06	lda $0600,x			lda 	lowStack,x
.9319	d0 03		bne $931e			bne 	_UDNoBorrow
.931b	de 00 07	dec $0700,x			dec 	highStack,x
.931e					_UDNoBorrow:
.931e	de 00 06	dec $0600,x			dec 	lowStack,x
.9321	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9324					Unary_BSwap:
.9324	fa		plx				plx
.9325	bd 00 06	lda $0600,x			lda 	lowStack,x
.9328	48		pha				pha
.9329	bd 00 07	lda $0700,x			lda 	highStack,x
.932c	9d 00 06	sta $0600,x			sta 	lowStack,x
.932f	68		pla				pla
.9330	9d 00 07	sta $0700,x			sta 	highStack,x
.9333	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9336					Unary_Shl:
.9336	fa		plx				plx
.9337	1e 00 06	asl $0600,x			asl 	lowStack,x
.933a	3e 00 07	rol $0700,x			rol 	highStack,x
.933d	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9340					Unary_Shr:
.9340	fa		plx				plx
.9341	5e 00 07	lsr $0700,x			lsr 	highStack,x
.9344	7e 00 06	ror $0600,x			ror 	lowStack,x
.9347	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.934a					Unary_Sgn:
.934a	fa		plx				plx
.934b	bd 00 07	lda $0700,x			lda 	highStack,x 				; check bit 7.
.934e	10 0a		bpl $935a			bpl 	_USNotNeg
.9350	a9 ff		lda #$ff			lda 	#$FF 						; if -ve set to -1
.9352	9d 00 06	sta $0600,x			sta 	lowStack,x
.9355	9d 00 07	sta $0700,x			sta 	highStack,x
.9358	80 10		bra $936a			bra 	_USExit
.935a					_USNotNeg:
.935a	1d 00 06	ora $0600,x			ora 	lowStack,x 					; A = Low|High
.935d	9e 00 06	stz $0600,x			stz 	lowStack,x 					; Zero result
.9360	9e 00 07	stz $0700,x			stz 	highStack,x
.9363	c9 00		cmp #$00			cmp 	#0 							; if 0 return 0
.9365	f0 03		beq $936a			beq 	_USExit
.9367	fe 00 06	inc $0600,x			inc 	lowStack,x 					; else return 1.
.936a					_USExit:
.936a	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.936d					Random_Handler:
.936d	fa		plx				plx
.936e	a5 15		lda $15				lda 	randomSeed
.9370	05 16		ora $16				ora 	randomSeed+1
.9372	d0 08		bne $937c			bne 	_RH_NoInit
.9374	a9 7c		lda #$7c			lda 	#$7C
.9376	85 15		sta $15				sta 	randomSeed
.9378	a9 a1		lda #$a1			lda 	#$A1
.937a	85 16		sta $16				sta 	randomSeed+1
.937c					_RH_NoInit:
.937c	a5 15		lda $15				lda 	randomSeed
.937e	4a		lsr a		        lsr		a
.937f	26 16		rol $16		        rol 	randomSeed+1
.9381	90 02		bcc $9385	        bcc 	_RH_NoEor
.9383	49 b4		eor #$b4	        eor 	#$B4
.9385					_RH_NoEor:
.9385	85 15		sta $15		        sta 	randomSeed
.9387	45 16		eor $16		        eor 	randomSeed+1
.9389	e8		inx		        inx
.938a	9d 00 07	sta $0700,x	        sta 	highStack,x
.938d	a5 15		lda $15		        lda 	randomSeed
.938f	9d 00 06	sta $0600,x	        sta 	lowStack,x
.9392	4c 0a 85	jmp $850a			jmp 	ExecuteLoop

;******  Return to file: main.asm


;******  Processing file: words/structures/call.asm

.9395					Command_Call:
.9395	fa		plx				plx
.9396	20 4c 88	jsr $884c			jsr 	StackPushPosition 				; save stack position
.9399	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; push call marker
.939b	20 3c 88	jsr $883c			jsr 	StackPushByte
.939e	b1 00		lda ($00),y			lda 	(codePtr),y 					; copy target address into zTemp0
.93a0	85 02		sta $02				sta 	zTemp0
.93a2	c8		iny				iny
.93a3	b1 00		lda ($00),y			lda 	(codePtr),y
.93a5	85 03		sta $03				sta 	zTemp0+1
.93a7	a9 00		lda #$00			lda 	#(ProgramStart) & $FF
.93a9	85 00		sta $00				sta 	codePtr
.93ab	a9 10		lda #$10			lda 	#(ProgramStart) >> 8
.93ad	85 01		sta $01				sta 	codePtr+1
.93af	a0 01		ldy #$01			ldy 	#1
.93b1					_CCSearch:
.93b1	b2 00		lda ($00)			lda 	(codePtr)						; end of program
.93b3	f0 2d		beq $93e2			beq		_CCFail
.93b5	b1 00		lda ($00),y			lda 	(codePtr),y 					; compare line number LSB.
.93b7	c5 02		cmp $02				cmp 	zTemp0 							; if equal, go check the next.
.93b9	f0 0d		beq $93c8			beq 	_CCCheckMSB
.93bb	18		clc				clc 									; forward to next line.
.93bc	b2 00		lda ($00)			lda 	(codePtr)
.93be	65 00		adc $00				adc 	codePtr
.93c0	85 00		sta $00				sta 	codePtr
.93c2	90 ed		bcc $93b1			bcc 	_CCSearch
.93c4	e6 01		inc $01				inc 	codePtr+1
.93c6	80 e9		bra $93b1			bra 	_CCSearch
.93c8					_CCCheckMSB:
.93c8	c8		iny				iny 									; get MSB, keeping Y as 1
.93c9	b1 00		lda ($00),y			lda 	(codePtr),y
.93cb	88		dey				dey
.93cc	c5 03		cmp $03				cmp 	zTemp0+1						; not found go back.
.93ce	d0 e1		bne $93b1			bne 	_CCSearch
.93d0	a0 03		ldy #$03			ldy 	#3 								; start running from here.
.93d2	b1 00		lda ($00),y			lda 	(codePtr),y 					; check it's a define
.93d4	c9 05		cmp #$05			cmp 	#KWD_SYS_DEFINE
.93d6	d0 0a		bne $93e2			bne 	_CCFail
.93d8	c8		iny				iny 									; get the length of this.
.93d9	b1 00		lda ($00),y			lda 	(codePtr),y
.93db	18		clc				clc
.93dc	69 05		adc #$05			adc 	#5 								; move to the end of the definition
.93de	a8		tay				tay
.93df	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.93e2					_CCFail:
.93e2	20 9c 84	jsr $849c			jsr 	ErrorHandler
>93e5	43 41 4c 4c 3f 00				.text 	"CALL?",0
.93eb					Command_Return:
.93eb	fa		plx				plx
.93ec	a9 02		lda #$02			lda 	#KWD_SYS_CALL 					; check it's a call
.93ee	20 5b 88	jsr $885b			jsr 	StackCheckTop
.93f1	90 0f		bcc $9402			bcc 	_CRFail
.93f3	a0 01		ldy #$01			ldy		#1								; return. Add 2 to skip call address
.93f5	20 69 88	jsr $8869			jsr 	StackRestorePosition
.93f8	c8		iny				iny
.93f9	c8		iny				iny
.93fa	a9 04		lda #$04			lda 	#4 								; pop off stack
.93fc	20 63 88	jsr $8863			jsr 	StackPop
.93ff	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9402					_CRFail:
.9402	20 9c 84	jsr $849c			jsr 	ErrorHandler
>9405	43 41 4c 4c 3f 00				.text 	"CALL?",0

;******  Return to file: main.asm


;******  Processing file: words/structures/if.asm

.940b					Structure_If:
.940b	fa		plx				plx
.940c	a9 06		lda #$06			lda 	#KWD_IF 						; push if marker.
.940e	20 3c 88	jsr $883c			jsr 	StackPushByte
.9411	18		clc				clc
.9412	bd 00 06	lda $0600,x			lda 	lowStack,x 						; check TOS is zero
.9415	1d 00 07	ora $0700,x			ora 	highStack,x
.9418	ca		dex				dex 									; drop TOS
.9419	c9 00		cmp #$00			cmp 	#0 								; if zero, skip forward to ELSE or ENDIF
.941b	d0 0e		bne $942b			bne 	_SIFNoSkip 						; at this level.
.941d	da		phx				phx
.941e	a9 38		lda #$38			lda 	#KWD_ELSE
.9420	a2 09		ldx #$09			ldx 	#KWD_ENDIF
.9422	20 58 94	jsr $9458			jsr 	StructSkipForward
.9425	fa		plx				plx 									; restore X
.9426	c9 38		cmp #$38			cmp 	#KWD_ELSE 						; if it was ELSE skip over that and run ELSE
.9428	d0 01		bne $942b			bne 	_SIFNoSkip 						; clause.
.942a	c8		iny				iny
.942b					_SIFNoSkip:
.942b	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.942e					Structure_Else:
.942e	fa		plx				plx
.942f	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.9431	20 5b 88	jsr $885b			jsr 	StackCheckTop
.9434	90 0b		bcc $9441			bcc 	SIFail
.9436	da		phx				phx 									; got here by executing IF clause so skip
.9437	a9 09		lda #$09			lda 	#KWD_ENDIF 						; forward to ENDIF
.9439	aa		tax				tax
.943a	20 58 94	jsr $9458			jsr 	StructSkipForward
.943d	fa		plx				plx
.943e	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9441					SIFail:
.9441	20 9c 84	jsr $849c			jsr 	ErrorHandler
>9444	49 46 3f 00					.text 	"IF?",0
.9448					Structure_Endif:
.9448	fa		plx				plx
.9449	a9 06		lda #$06			lda 	#KWD_IF 						; check IF on top
.944b	20 5b 88	jsr $885b			jsr 	StackCheckTop
.944e	90 f1		bcc $9441			bcc 	SIFail
.9450	a9 01		lda #$01			lda 	#1 								; throw it.
.9452	20 63 88	jsr $8863			jsr 	StackPop
.9455	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9458					StructSkipForward:
.9458	85 02		sta $02				sta 	zTemp0 							; save the tokens to test
.945a	86 03		stx $03				stx 	zTemp0+1
.945c	64 04		stz $04				stz 	zTemp1 							; zero the level counter.
.945e					_SSFLoop:
.945e	b1 00		lda ($00),y			lda 	(codePtr),y 					; get current
.9460	a6 04		ldx $04				ldx 	zTemp1 							; if the structure level is non zero must fail
.9462	d0 08		bne $946c			bne		_SSFFail
.9464	c5 02		cmp $02				cmp 	zTemp0 							; check for match.
.9466	f0 17		beq $947f			beq 	_SSFEnd
.9468	c5 03		cmp $03				cmp 	zTemp0+1
.946a	f0 13		beq $947f			beq 	_SSFEnd
.946c					_SSFFail:
.946c	20 80 94	jsr $9480			jsr 	AdvanceInCode 					; skip over in code.
.946f	b0 ed		bcs $945e			bcs 	_SSFLoop 						; if not end of program, keep going.
.9471	20 9c 84	jsr $849c			jsr 	ErrorHandler
>9474	53 54 52 55 43 54 55 52				.text 	"STRUCTURE?",0
>947c	45 3f 00
.947f					_SSFEnd:
.947f	60		rts				rts
.9480					AdvanceInCode:
.9480	b1 00		lda ($00),y			lda 	(codePtr),y 					; look at current
.9482	f0 28		beq $94ac			beq 	_AICEndOfLine 					; end of line.
.9484	c8		iny				iny 									; advance one.
.9485	c9 06		cmp #$06			cmp 	#TOK_NOT_CONTROL 				; is it a control
.9487	90 10		bcc $9499			bcc 	_AICControl
.9489	c9 0c		cmp #$0c			cmp 	#TOK_STRUCT_NEUTRAL 			; neutral token ?
.948b	b0 0a		bcs $9497			bcs 	_AICExit
.948d	e6 04		inc $04				inc 	zTemp1 							; bump the structure count.
.948f	c9 09		cmp #$09			cmp 	#TOK_STRUCT_DEC 				; if decrement
.9491	90 04		bcc $9497			bcc 	_AICExit
.9493	c6 04		dec $04				dec 	zTemp1
.9495	c6 04		dec $04				dec 	zTemp1
.9497					_AICExit:
.9497	38		sec				sec
.9498	60		rts				rts
.9499					_AICControl:
.9499	c9 01		cmp #$01			cmp 	#KWD_SYS_CONST 					; constant and call advance +3
.949b	f0 0b		beq $94a8			beq 	_AICThree
.949d	c9 02		cmp #$02			cmp 	#KWD_SYS_CALL
.949f	f0 07		beq $94a8			beq 	_AICThree
.94a1	98		tya				tya										; skip over a string/comment/define.
.94a2	38		sec				sec
.94a3	71 00		adc ($00),y			adc 	(codePtr),y
.94a5	a8		tay				tay
.94a6	38		sec				sec
.94a7	60		rts				rts
.94a8					_AICThree:
.94a8	c8		iny				iny
.94a9	c8		iny				iny
.94aa	38		sec				sec
.94ab	60		rts				rts
.94ac					_AICEndOfLine:
.94ac	18		clc				clc 									; forward to next line.
.94ad	b2 00		lda ($00)			lda 	(codePtr)
.94af	65 00		adc $00				adc 	codePtr
.94b1	85 00		sta $00				sta 	codePtr
.94b3	90 02		bcc $94b7			bcc 	_AICNoCarry
.94b5	e6 01		inc $01				inc 	codePtr+1
.94b7					_AICNoCarry:
.94b7	a0 03		ldy #$03			ldy 	#3 								; start of new line
.94b9	b2 00		lda ($00)			lda 	(codePtr) 						; check offset is non zero
.94bb	d0 da		bne $9497			bne 	_AICExit
.94bd	18		clc				clc 									; program end.
.94be	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: words/structures/repeat.asm

.94bf					Struct_Repeat:
.94bf	fa		plx				plx
.94c0	20 4c 88	jsr $884c			jsr 	StackPushPosition 				; save stack position
.94c3	a9 07		lda #$07			lda 	#KWD_REPEAT 					; push repeat marker
.94c5	20 3c 88	jsr $883c			jsr 	StackPushByte
.94c8	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.94cb					Struct_Until:
.94cb	fa		plx				plx
.94cc	a9 07		lda #$07			lda 	#KWD_REPEAT 					; check it's a repeat
.94ce	20 5b 88	jsr $885b			jsr 	StackCheckTop
.94d1	90 1b		bcc $94ee			bcc 	_SUFail
.94d3	bd 00 06	lda $0600,x			lda		lowStack,x						; check it was zero ?
.94d6	1d 00 07	ora $0700,x			ora 	highStack,x
.94d9	ca		dex				dex
.94da	09 00		ora #$00			ora 	#0
.94dc	f0 08		beq $94e6			beq 	_SULoopBack 					; if so keep going.
.94de	a9 04		lda #$04			lda 	#4 								; pop 4 bytes off the stack
.94e0	20 63 88	jsr $8863			jsr 	StackPop
.94e3	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.94e6					_SULoopBack:
.94e6	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.94e8	20 69 88	jsr $8869			jsr 	StackRestorePosition
.94eb	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.94ee					_SUFail:
.94ee	20 9c 84	jsr $849c			jsr 	ErrorHandler
>94f1	4e 4f 20 52 45 50 45 41				.text 	"NO REPEAT",0
>94f9	54 00

;******  Return to file: main.asm


;******  Processing file: words/structures/for.asm

.94fb					Struct_For:
.94fb	fa		plx				plx
.94fc	18		clc				clc
.94fd	bd 00 06	lda $0600,x			lda 	lowStack,x 					; push ~ count on the stack
.9500	49 ff		eor #$ff			eor 	#$FF
.9502	69 01		adc #$01			adc 	#1
.9504	08		php				php
.9505	20 3c 88	jsr $883c			jsr 	StackPushByte
.9508	bd 00 07	lda $0700,x			lda 	highStack,x
.950b	49 ff		eor #$ff			eor 	#$FF
.950d	28		plp				plp
.950e	69 00		adc #$00			adc 	#0
.9510	20 3c 88	jsr $883c			jsr 	StackPushByte
.9513	ca		dex				dex 									; throw TOS
.9514	20 4c 88	jsr $884c			jsr 	StackPushPosition 				; save stack position
.9517	a9 08		lda #$08			lda 	#KWD_FOR 						; push for marker
.9519	20 3c 88	jsr $883c			jsr 	StackPushByte
.951c	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.951f					Struct_Index:
.951f	fa		plx				plx
.9520	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.9522	20 5b 88	jsr $885b			jsr 	StackCheckTop
.9525	90 43		bcc $956a			bcc 	SNFail
.9527	e8		inx				inx 									; new stack entry
.9528	5a		phy				phy
.9529	a0 04		ldy #$04			ldy 	#4 								; access index value
.952b	b1 0e		lda ($0e),y			lda 	(iStack),y
.952d	49 ff		eor #$ff			eor 	#$FF
.952f	9d 00 07	sta $0700,x			sta 	highStack,x
.9532	c8		iny				iny
.9533	b1 0e		lda ($0e),y			lda 	(iStack),y
.9535	49 ff		eor #$ff			eor 	#$FF
.9537	9d 00 06	sta $0600,x			sta 	lowStack,x
.953a	7a		ply				ply 									; restore code pointer
.953b	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.953e					Struct_Next:
.953e	fa		plx				plx
.953f	a9 08		lda #$08			lda 	#KWD_FOR 						; check it's a for
.9541	20 5b 88	jsr $885b			jsr 	StackCheckTop
.9544	90 24		bcc $956a			bcc 	SNFail
.9546	5a		phy				phy 									; save code position
.9547	a0 05		ldy #$05			ldy 	#5 								; bump the count
.9549	b1 0e		lda ($0e),y			lda 	(iStack),y
.954b	1a		inc a				inc 	a
.954c	91 0e		sta ($0e),y			sta 	(iStack),y
.954e	d0 11		bne $9561			bne 	_SNLoopBack
.9550	88		dey				dey
.9551	b1 0e		lda ($0e),y			lda 	(iStack),y
.9553	1a		inc a				inc 	a
.9554	91 0e		sta ($0e),y			sta 	(iStack),y
.9556	d0 09		bne $9561			bne 	_SNLoopBack  					; non-zero loop back.
.9558	7a		ply				ply 									; restore code position.
.9559	a9 06		lda #$06			lda 	#6 								; pop 6 bytes off the stack
.955b	20 63 88	jsr $8863			jsr 	StackPop
.955e	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.9561					_SNLoopBack:
.9561	7a		ply				ply 									; restore code position, being junked anyway.
.9562	a0 01		ldy #$01			ldy 	#1 								; transfer to position at (iStack),y
.9564	20 69 88	jsr $8869			jsr 	StackRestorePosition
.9567	4c 0a 85	jmp $850a			jmp 	ExecuteLoop
.956a					SNFail:
.956a	20 9c 84	jsr $849c			jsr 	ErrorHandler
>956d	4e 4f 20 46 4f 52 00				.text 	"NO FOR",0

;******  Return to file: main.asm


;******  End of listing
